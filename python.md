## Real Python Tutorials
[All Python Tutorial Topics](https://realpython.com/tutorials/all/)  


## python 在线环境
[Python Playground](https://programiz.pro/ide/python)  


## 设计模式
[The Factory Method Pattern and Its Implementation in Python](https://realpython.com/factory-method-python/)  
[Implementing an Interface in Python](https://realpython.com/python-interface/)  
[Inheritance and Composition: A Python OOP Guide](https://realpython.com/inheritance-composition-python/)  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  

## 最佳实践
[Your Guide to the Python print() Function](https://realpython.com/python-print/)  
[The Python return Statement: Usage and Best Practices](https://realpython.com/python-return-statement/)  
[Python args and kwargs: Demystified](https://realpython.com/python-kwargs-and-args/)  
[Structural Pattern Matching in Python](https://realpython.com/structural-pattern-matching/)  
[Operators and Expressions in Python](https://realpython.com/python-operators-expressions/)  
[Variables in Python: Usage and Best Practices](https://realpython.com/python-variables/)  
[Python's Built-in Functions: A Complete Exploration](https://realpython.com/python-built-in-functions/)  
[How to Flatten a List of Lists in Python](https://realpython.com/python-flatten-list/)  
[Getters and Setters: Manage Attributes in Python](https://realpython.com/python-getter-setter/)  
[Defining Main Functions in Python](https://realpython.com/python-main-function/)  
[Python Modules and Packages – An Introduction](https://realpython.com/python-modules-packages/)  
[Python import: Advanced Techniques and Tips](https://realpython.com/python-import/)  
[Absolute vs Relative Imports in Python](https://realpython.com/absolute-vs-relative-python-imports/)  
[What's a Python Namespace Package, and What's It For?](https://realpython.com/python-namespace-package/)  
[Using PyInstaller to Easily Distribute Python Applications](https://realpython.com/pyinstaller-python/)  
[Python Keywords: An Introduction](https://realpython.com/python-keywords/)  
[Python Protocols: Leveraging Structural Subtyping](https://realpython.com/python-protocol/)  
[Pydantic: Simplifying Data Validation in Python](https://realpython.com/python-pydantic/)  
[Python Type Checking (Guide)](https://realpython.com/python-type-checking/)  
[Build a Hash Table in Python With TDD](https://realpython.com/python-hash-table/)  
[How to Use Python Lambda Functions](https://realpython.com/python-lambda/)  
[Python's map(): Processing Iterables Without a Loop](https://realpython.com/python-map-function/)  
[Python's reduce(): From Functional to Pythonic Style](https://realpython.com/python-reduce-function/)  
[Sorting Algorithms in Python](https://realpython.com/sorting-algorithms-python/)  
[Python Stacks, Queues, and Priority Queues in Practice](https://realpython.com/queue-in-python/)  
[Linked Lists in Python: An Introduction](https://realpython.com/linked-lists-python/)  
[Duck Typing in Python: Writing Flexible and Decoupled Code](https://realpython.com/duck-typing-python/)  
[When Should You Use .__repr__() vs .__str__() in Python?](https://realpython.com/python-repr-vs-str/)  
[Python Class Constructors: Control Your Object Instantiation](https://realpython.com/python-class-constructor/)  
[Build Enumerations of Constants With Python's Enum](https://realpython.com/python-enum/)  
[Python mmap: Improved File I/O With Memory Mapping](https://realpython.com/python-mmap/)  
[Python eval(): Evaluate Expressions Dynamically](https://realpython.com/python-eval-function/)  
[Python's exec(): Execute Dynamically Generated Code](https://realpython.com/python-exec/)  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  

## unittest
[Python's unittest: Writing Unit Tests for Your Code](https://realpython.com/python-unittest/)  
[Getting Started With Testing in Python](https://realpython.com/python-testing/)  
[Effective Python Testing With pytest](https://realpython.com/pytest-python-testing/)  
[Write Unit Tests for Your Python Code With ChatGPT](https://realpython.com/chatgpt-unit-tests-python/)  

## 数据库
[Handling SQL Databases With PyQt: The Basics](https://realpython.com/python-pyqt-database/)  
[Data Management With Python, SQLite, and SQLAlchemy](https://realpython.com/python-sqlite-sqlalchemy/)  
[Introduction to Python SQL Libraries](https://realpython.com/python-sql-libraries/)  

## 图像处理
Image Processing With the Python Pillow Library](https://realpython.com/image-processing-with-the-python-pillow-library/)  

## GUI
[Build a Contact Book With Python, PyQt, and SQLite](https://realpython.com/python-contact-book/)  
[PythonGUIs](https://www.pythonguis.com/pyqt6-tutorial/)  
[Python and PyQt: Building a GUI Desktop Calculator](https://realpython.com/python-pyqt-gui-calculator/)  
[Python GUI Programming With Tkinter](https://realpython.com/python-gui-tkinter/)  
[Handling SQL Databases With PyQt: The Basics](https://realpython.com/python-pyqt-database/)  
[Python and PyQt: Creating Menus, Toolbars, and Status Bars](https://realpython.com/python-menus-toolbars/)  
[PyQt Layouts: Create Professional-Looking GUI Applications](https://realpython.com/python-pyqt-layout/)  
[Qt Designer and Python: Build Your GUI Applications Faster](https://realpython.com/qt-designer-python/)  
[]()  
[]()  
[]()  

## DSA
[Learn Python Programming](https://www.programiz.com/python-programming)  
[Getting Started with DSA](https://www.programiz.com/dsa/getting-started)  

## 面向对象
[Python's property(): Add Managed Attributes to Your Classes](https://realpython.com/python-property/)  
[self in Python, Demystified](https://www.programiz.com/article/python-self-why)  
[Namespaces and Scope in Python](https://realpython.com/python-namespaces-scope/)  
[Object-Oriented Programming (OOP) in Python 3](https://realpython.com/python3-object-oriented-programming/)  
[Python Classes: The Power of Object-Oriented Programming](https://realpython.com/python-classes/)  
[Python's Magic Methods: Leverage Their Power in Your Classes](https://realpython.com/python-magic-methods/)  
[Supercharge Your Classes With Python super()](https://realpython.com/python-super/)  

## 正则匹配
[Regular Expressions: Regexes in Python (Part 1)](https://realpython.com/regex-python/)  
[Regular Expressions: Regexes in Python (Part 2)](https://realpython.com/regex-python-part-2/)  

## Python Projects
[python beginner projects](https://github.com/Mrinank-Bhowmick/python-beginner-projects/tree/main)  
[Python Projects You Can Build](https://realpython.com/tutorials/projects/)  
[python mini projects](https://github.com/Python-World/python-mini-projects/tree/master)  

## 文件操作
[Working With Files in Python](https://realpython.com/working-with-files-in-python/)  
[Reading and Writing Files in Python (Guide)](https://realpython.com/read-write-files-python/)  
[Reading and Writing CSV Files in Python](https://realpython.com/python-csv/)  
[Working With JSON Data in Python](https://realpython.com/python-json/)  


## 远程登录
```python
import paramiko
import time
import re
from datetime import datetime
from typing import List, Tuple, Dict, Optional

EVC_NAME = "evc-cooker-zhisheng"
VMC_NAME = "vmc-1-cooker"
CM_MAC = "74:9b:e8:5c:bb:50"

class SSHSession:
    """
    SSH 会话管理类，用于封装 SSH 连接和命令执行
    """
    
    def __init__(self, hostname: str, username: str, password: str = None, 
                 port: int = 22, key_file: str = None, timeout: float = 10):
        """
        初始化 SSH 会话
        
        Args:
            hostname: 目标主机名或 IP
            username: 用户名
            password: 密码（可选，如果使用密钥则不需要）
            port: SSH 端口，默认 22
            key_file: 私钥文件路径（可选）
            timeout: 连接超时时间
        """
        self.hostname = hostname
        self.username = username
        self.password = password
        self.port = port
        self.key_file = key_file
        self.timeout = timeout
        
        self.client = paramiko.SSHClient()
        self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        self.channel = None
        self.is_connected = False

    def connect(self) -> None:
        """建立 SSH 连接并创建交互式 shell"""
        try:
            if self.key_file:
                private_key = paramiko.RSAKey.from_private_key_file(self.key_file)
                self.client.connect(
                    hostname=self.hostname,
                    port=self.port,
                    username=self.username,
                    pkey=private_key,
                    timeout=self.timeout
                )
            else:
                self.client.connect(
                    hostname=self.hostname,
                    port=self.port,
                    username=self.username,
                    password=self.password,
                    timeout=self.timeout
                )
            
            self.channel = self.client.invoke_shell()
            self.is_connected = True
            time.sleep(1)  # 等待 shell 初始化
            print(f"Connected to {self.hostname}")
            
        except paramiko.AuthenticationException as e:
            raise Exception(f"Authentication failed: {e}")
        except paramiko.SSHException as e:
            raise Exception(f"SSH connection failed: {e}")

    def disconnect(self) -> None:
        """关闭 SSH 连接"""
        if self.is_connected:
            self.client.close()
            self.is_connected = False
            self.channel = None
            print("SSH connection closed")

    def execute_command(self, command: str, wait_time: float = 2) -> str:
        """
        在当前会话中执行单条命令并返回输出
        
        Args:
            command: 要执行的命令
            wait_time: 等待输出时间
        Returns:
            命令执行的输出
        """
        if not self.is_connected or not self.channel:
            raise RuntimeError("No active SSH session. Please connect first.")
        
        self.channel.send(f"{command}\n")
        time.sleep(wait_time)
        output = self._get_output()
        print(f"Command '{command}' executed")
        return output

    def execute_commands(self, commands: List[Tuple[str, float]]) -> Dict[str, str]:
        """
        在当前会话中执行多条命令并返回所有输出
        
        Args:
            commands: 包含 (命令, 等待时间) 的列表
        Returns:
            命令及其输出的字典
        """
        if not self.is_connected or not self.channel:
            raise RuntimeError("No active SSH session. Please connect first.")
        
        results = {}
        for command, wait_time in commands:
            results[command] = self.execute_command(command, wait_time)
        return results

    def _get_output(self) -> str:
        """从通道读取输出"""
        output = ""
        while self.channel.recv_ready():
            output += self.channel.recv(1024).decode("utf-8")
            time.sleep(0.5)
        return output.strip()

    def __enter__(self):
        """支持上下文管理器"""
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出时自动关闭连接"""
        self.disconnect()


class CommandProcessor:
    """命令处理类"""
    def __init__(self, session: SSHSession):
        self.session = session

    def setup_session(self) -> None:
        """执行初始设置命令"""
        setup_commands = [
            (f"nomad alloc exec -task evc -job {EVC_NAME} sh", 1),
            ("ncs_cli -u admin", 1)
        ]
        self.session.execute_commands(setup_commands)

    def get_modem_info(self) -> str:
        """获取modem信息"""
        cmd = "show cable modem brief | tab | nomore"
        return self.session.execute_command(cmd, 2)

    def get_field_after_operational(self, text: str) -> str:
        # 匹配 operational 后跟一个或多个空格，然后捕获下一个非空字段
        pattern = r'operational[^\s]*\s+(\S+)'
        match = re.search(pattern, text)
        if match:
            return match.group(1)
        return "nomatch"

    def set_channel_state(self, channel: str, state: str) -> None:
        """设置通道状态"""
        cmd = f"vmc {VMC_NAME} mac-domain 0 ds ds-channels {channel} admin-state {state}"
        commands = [
            ("config", 1),
            (cmd, 1),
            ("commit", 2),
            ("top", 1),
            ("exit", 1)
        ]
        self.session.execute_commands(commands)

if __name__ == "__main__":
    # Configuration
    HOST = "10.254.25.106"
    USERNAME = "root"
    PASSWORD = "Gainsp33"
    
    with SSHSession(HOST, USERNAME, PASSWORD) as session:
        cmd_processor = CommandProcessor(session)
        cmd_processor.setup_session()
        
        pre_primary = ""
        ds_primary = ""
        for i in range(5):
            output = cmd_processor.get_modem_info()
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            print(f"{current_time}: {output}")
            
            lines = output.split("\n")
            for line in lines:
                # match exact mac address and operational status
                if CM_MAC in line and "operational" in line:
                    ds_primary = cmd_processor.get_field_after_operational(line)
                    if ds_primary == "nomatch":
                        print("get ds primary channel failed")
                        break
                    
                    # modem is still online with the same ds_primary after ds primary channel dowm
                    if pre_primary and pre_primary == ds_primary:
                        print(f"pre_primary and ds_primary are the same: {ds_primary}, wait for 60 seconds")
                        time.sleep(60)
                        break
                    
                    # up the pre_primary
                    if pre_primary and pre_primary != ds_primary:
                        cmd_processor.set_channel_state(pre_primary, "up")
                    
                    # down the current ds_primary
                    print(f"ds_primary: {ds_primary}")
                    cmd_processor.set_channel_state(ds_primary, "down")
                    
                    # update pre_primary
                    print(f"update pre_primary to {ds_primary}")
                    pre_primary = ds_primary
                    break
            
            time.sleep(10)
        
        if pre_primary:
            cmd_processor.set_channel_state(pre_primary, "up")
```

## logging
[Logging in Python](https://realpython.com/python-logging/)  
[Python Logging: A Stroll Through the Source Code](https://realpython.com/python-logging-source-code/)  

## 网络
[Python's Requests Library (Guide)](https://realpython.com/python-requests/)  
[Socket Programming in Python](https://realpython.com/python-sockets/)  
[Python and REST APIs: Interacting With Web Services](https://realpython.com/api-integration-in-python/)  


## 装饰器
[Python Descriptors: An Introduction](https://realpython.com/python-descriptors/)  
[Primer on Python Decorators](https://realpython.com/primer-on-python-decorators/)  
[Context Managers and Python's with Statement](https://realpython.com/python-with-statement/)  
```python
# 示例：timer 装饰器用来统计函数的执行时间
import time
# 装饰器内部的wrapper函数中的参数*args, **kwargs保证了其可以处理所有的参数类型，保证了参数传递的统一，使得装饰器的实现成为可能
# python程序解释器在运行时会解析函数所提供的参数，根据函数签名进行参数匹配，*args用于捕捉未匹配的位置参数（除了required parameters），**kwargs用于捕捉未匹配的关键字参数
# 当wrapper函数调用真正的函数被时，*args和**kwargs会被unpack，即*args展开为对应的位置参数，**kwargs展开为对应的关键字参数
def timer(func):
    def wrapper(*args, **kwargs):
        print("positional args:", args)
        print("keyword args:", kwargs)
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        print("-" * 20)
        return result
    return wrapper

@timer
def no_args():
    time.sleep(0.1)
    print("no args here")

@timer
def with_positional(num):
    time.sleep(0.2)
    print(f"with positional arg {num}")

@timer
def with_keyword(name, age=18):
    time.sleep(0.3)
    print(f"with keyword, name:{name}, age:{age}")


no_args()
with_positional(1)
with_keyword(name="Alice")


Output:
positional args: ()
keyword args: {}
no args here
no_args took 0.1002 seconds
--------------------
positional args: (1,)
keyword args: {}
with positional arg 1
with_positional took 0.2002 seconds
--------------------
positional args: ()
keyword args: {'name': 'Alice'}
with keyword, name:Alice, age:18
with_keyword took 0.3003 seconds
--------------------



# with ...
class SimpleClass:
    def __init__(self):
        print("__init__")

    def simple_method(self):
        print("simple_method")

    def _finalize(self):
        print("_finalize")
    
    def __enter__(self):
        print("__enter__")
        return self
    
    def __exit__(self, exc_type, exc_value, exc_tb):
        print("__exit__")
        self._finalize()


with SimpleClass() as sc:
    sc.simple_method()

Output:
__init__
__enter__
simple_method
__exit__
_finalize
```

## 迭代器
[Iterators and Iterables in Python: Run Efficient Iterations](https://realpython.com/python-iterators-iterables/)  
[How to Use Generators and yield in Python](https://realpython.com/introduction-to-python-generators/)  
[Python for Loops: The Pythonic Way](https://realpython.com/python-for-loop/)  
```python
# 使用 yield 的函数被称为生成器函数
# 当调用生成器函数时，它不会立即执行并返回结果，而是返回一个生成器对象（generator object）, 该生成器对象是一个迭代器，可以通过 next() 调用逐步执行，每次遇到 yield 时暂停并返回值，下次调用时从暂停处继续

# 底层机制：生成器对象和状态保存
1.生成器对象：一个封装了执行状态的结构体
2.字节码：控制执行流程的指令
3.调用帧（frame）：保存局部变量和执行位置

#a 生成器对象
当你调用 gen() 时，Python 不直接执行函数体，而是返回一个 PyGenObject（生成器对象）
这个对象包含：
1.代码对象（gi_code）：函数编译后的字节码（gen.__code__）
2.执行帧（gi_frame）：一个 PyFrameObject，保存当前执行状态
3.运行状态（gi_running）：标记生成器是否正在执行
def gen():
	yield 1
	yield 2

g = gen()
print(g.gi_code.co_code)   # 字节码
print(g.gi_frame)          # 当前帧

#b yield 如何暂停
当生成器执行到 yield 时：
1.字节码指令：YIELD_VALUE 指令被触发
2.暂停执行：解释器将当前值推送到调用者，并暂停生成器的执行
3.保存状态：当前帧（PyFrameObject）保留下来，而不是被销毁

#c 如何恢复
调用 next(g) 时：
1.恢复帧：解释器从 gi_frame 恢复上次的状态。
2.继续执行：从上次暂停的字节码位置开始运行，直到下个 yield 或函数结束。

# 查看帧状态
import inspect

def gen():
    x = 10
    yield x
    x += 5
    yield x

g = gen()
print(next(g))          # 10
frame = g.gi_frame
print(frame.f_locals)   # {'x': 10}
print(next(g))          # 15
print(frame.f_locals)   # {'x': 15}

# 内存和性能
内存：生成器高效是因为它只保存一个帧，而不是整个调用栈的副本。相比列表，内存占用低得多
性能：暂停和恢复的开销很小，主要是帧切换和栈操作，接近 O(1)
def infinite():
    x = 0
    while True:
        yield x
        x += 1

g = infinite()
print(next(g))  # 0
print(next(g))  # 1
```

## 异常处理
[Python Exceptions: An Introduction](https://realpython.com/python-exceptions/)  
[Python's Built-in Exceptions: A Walkthrough With Examples](https://realpython.com/python-built-in-exceptions/)  
[Python's raise: Effectively Raising Exceptions in Your Code](https://realpython.com/python-raise-exception/)  

## string 操作
[String Interpolation in Python: Exploring Available Tools](https://realpython.com/python-string-interpolation/)  
[Strings and Character Data in Python](https://realpython.com/python-strings/)  
[String Methods](https://docs.python.org/3/library/stdtypes.html#string-methods)  
[A Guide to Modern Python String Formatting Tools](https://realpython.com/python-formatted-output/)  
[Python String Formatting: Available Tools and Their Features](https://realpython.com/python-string-formatting/)  
[Python's F-String for String Interpolation and Formatting](https://realpython.com/python-f-strings/)  
[Python f-string: A Complete Guide](https://www.datacamp.com/tutorial/python-f-string)  
[How to Replace a String in Python](https://realpython.com/replace-string-python/)  
[How to Join Strings in Python](https://realpython.com/python-join-string/)  
[How to Split a String in Python](https://realpython.com/python-split-string/)  

## 列表，元组和字典
[Basic Data Types in Python: A Quick Exploration](https://realpython.com/python-data-types/)  
[Python's list Data Type: A Deep Dive With Examples](https://realpython.com/python-list/)  
[Python's tuple Data Type: A Deep Dive With Examples](https://realpython.com/python-tuple/)  
[Lists vs Tuples in Python](https://realpython.com/python-lists-tuples/)  
[Dictionaries in Python](https://realpython.com/python-dicts/)  
[Sets in Python](https://realpython.com/python-sets/)  
[Python Constants: Improve Your Code's Maintainability](https://realpython.com/python-constants/)  
[How to Remove Items From Lists in Python](https://realpython.com/remove-item-from-list-python/)  
[]()  
[]()  
[]()  

## pathlib
[Python's pathlib Module: Taming the File System](https://realpython.com/python-pathlib/)  

## 多线程
[An Intro to Threading in Python](https://realpython.com/intro-to-python-threading/)  
[Python Thread Safety: Using a Lock and Other Techniques](https://realpython.com/python-thread-lock/)  

## 异步 IO
[Speed Up Your Python Program With Concurrency](https://realpython.com/python-concurrency/)  
[Getting Started With Async Features in Python](https://realpython.com/python-async-features/)  
[Async IO in Python: A Complete Walkthrough](https://realpython.com/async-io-python/)  
```python
# 异步编程
异步编程是一种并发模型，允许程序在等待某些操作（如 I/O）完成时继续执行其他任务，而不是阻塞线程。它基于事件循环（event loop）和非阻塞调用，特别适合高并发场景
"""
[Event Loop] <-----------------------------+
  |                                        |
  |  调度和运行                             |
  v                                        |
[Task Queue]                               |
  |  +----------------+                    |
  |  | Task 1         | <---+              |
  |  |  - Coroutine A |     |              |
  |  |  - State: Run  |     |              |
  |  +----------------+     |              |
  |  +----------------+     |              |
  |  | Task 2         | <---+              |
  |  |  - Coroutine B |     |   await      |
  |  |  - State: Wait |     +------------> [I/O Operation]
  |  +----------------+     |                (e.g., asyncio.sleep)
  |                         |
  |  asyncio.gather --------+ 并发运行多个任务
  v
[Finished Tasks] ----------> 输出结果
"""

asyncio的核心组件：
1.事件循环（Event Loop）：调度和运行异步任务
事件循环是异步编程的核心，负责：
	a) 调度协程的执行
	b) 处理 I/O 事件（如网络数据到达）
	c) 管理任务的暂停和恢复
2.协程（Coroutines）：用 async def 定义的函数, 调用时返回一个协程对象（coroutine 类型）。它不会立即执行，必须通过事件循环调度
3.await：暂停协程，将控制权交回事件循环，等待某个 awaitable 对象（协程、任务或 Future）完成
4.asyncio.sleep:异步的，返回一个 Future，事件循环可以在等待时处理其他任务

import asyncio

async def task(name, delay):
    await asyncio.sleep(delay)
    print(f"Task {name} done after {delay}s")

async def main():
    tasks = [
        task("A", 1),
        task("B", 2),
        task("C", 0.5)
    ]
    await asyncio.gather(*tasks)

asyncio.run(main())

# async def：定义一个协程函数，返回协程对象
# await：暂停协程，等待 asyncio.sleep(1) 完成
# asyncio.gather：并发运行多个协程
# asyncio.run：启动事件循环，运行 main()
```

## function
[Defining Your Own Python Function](https://realpython.com/defining-your-own-python-function/)  

## 配置文件解析
```python
"""
需求场景	            推荐模块
简单键值对配置	        configparser
复杂嵌套结构	        json 或 yaml
现代、简洁、可读性强	 toml
环境变量或敏感信息	     dotenv
命令行与配置结合	    argparse + 其他
"""
# configparser(内置模块)
用途:
     处理类似 .ini 或 .cfg 的配置文件，格式简单，键值对形式
特点:
    支持分节(section)和键值对(key-value)
    适用于简单的配置需求
	简单易用，适合小型项目
	不支持复杂数据结构(如嵌套对象)
# config.ini
[database]
host = localhost
port = 3306

[server]
debug = True

# json(内置模块)
用途:
    处理 JSON 格式的配置文件，广泛用于现代应用
特点:
    支持复杂数据结构(如嵌套字典、列表)
    跨语言兼容性强
	支持复杂结构，易读，广泛支持
	不支持注释(标准 JSON 不支持，但某些库如 commentjson 可解决)
# config.json
{
  "database": {
    "host": "localhost",
    "port": 3306
  },
  "server": {
    "debug": true
  }
}

# yaml(第三方模块)
用途:
    处理 YAML 格式的配置文件，常用于复杂配置(如 Kubernetes)
特点:
    支持复杂数据结构(嵌套、列表等)
    人类可读性强，支持注释
	语法简洁，支持注释，适合复杂配置
	需要额外安装依赖，解析速度稍慢
# config.yaml
database:
  host: localhost
  port: 3306
server:
  debug: true

# toml(第三方模块)(tomllib(Python 3.11+))
用途:
    处理 TOML(Tom's Obvious, Minimal Language)格式，设计为简洁且易读
特点:
    支持嵌套结构和多种数据类型
    比 INI 更现代，比 JSON/YAML 更简单
	简洁直观，支持注释，Python 3.11+ 无需额外依赖
	生态较新，普及度不如 JSON/YAML
# config.toml
[database]
host = "localhost"
port = 3306

[server]
debug = true

# Python 3.11+ 使用内置 tomllib
import tomllib  # 仅支持读取
with open('config.toml', 'rb') as f:  # 注意：需要二进制模式
    config = tomllib.load(f)

# Python 3.10 及以下使用 toml 库
# import toml
# with open('config.toml', 'r') as f:
#     config = toml.load(f)

host = config['database']['host']  # 'localhost'
port = config['database']['port']  # 3306
debug = config['server']['debug']  # True
print(f"Host: {host}, Port: {port}, Debug: {debug}")

# dotenv(第三方模块)
用途:
    处理 .env 文件，常用于环境变量配置
特点:
    专注于键值对，类似 shell 环境变量
    常用于存储敏感信息(如 API 密钥)
    简单，适合环境变量管理
    不支持复杂结构，仅键值对

from dotenv import load_dotenv
import os

load_dotenv()  # 加载 .env 文件到环境变量
host = os.getenv("DB_HOST")  # 'localhost'
port = int(os.getenv("DB_PORT"))  # 3306
debug = os.getenv("DEBUG") == "true"  # True
print(f"Host: {host}, Port: {port}, Debug: {debug}")

# 支持多种格式的配置解析类
import configparser
import json
import yaml
import toml

class ConfigLoader:
    def __init__(self, filepath: str):
        self.filepath = filepath
        self.config = self._load_config()

    def _load_config(self):
        if self.filepath.endswith('.ini'):
            config = configparser.ConfigParser()
            config.read(self.filepath)
            return config
        elif self.filepath.endswith('.json'):
            with open(self.filepath, 'r') as f:
                return json.load(f)
        elif self.filepath.endswith('.yaml'):
            with open(self.filepath, 'r') as f:
                return yaml.safe_load(f)
        elif self.filepath.endswith('.toml'):
            with open(self.filepath, 'r') as f:
                return toml.load(f)
        else:
            raise ValueError("不支持的文件格式")

    def get(self, section: str, key: str = None):
        if isinstance(self.config, configparser.ConfigParser):
            return self.config[section][key] if key else dict(self.config[section])
        else:
            return self.config[section][key] if key else self.config[section]

# 使用
config = ConfigLoader('config.yaml')
host = config.get('database', 'host')  # 'localhost'
print(host)
```
### argparse 模块
[configparser module](https://docs.python.org/3/library/configparser.html)  
[Build Command-Line Interfaces With Python's argparse](https://realpython.com/command-line-interfaces-python-argparse/)  
[argparse](https://docs.python.org/3/library/argparse.html#module-argparse)  

### configparser 模块
[INI文件格式简介](https://programming-note-sylarliu.readthedocs.io/zh-cn/latest/data_format/INI/ini_brief.html)  
[Python ConfigParser: A Comprehensive Guide](https://medium.com/nerd-for-tech/python-configparser-a-comprehensive-guide-%EF%B8%8F-36331be5244f)  
[Configuring Like a Pro! A Comprehensive Guide to Python’s configparser](https://towardsdev.com/configuring-like-a-pro-a-comprehensive-guide-to-pythons-configparser-26c49b898629)  
```python
# hostConfig.ini:
; section 1
[SFTP_SERVER1]
; name = value
host = 10.120.98.12
port = 22
username = tester
password = password

; section 2
[SFTP_SERVER2]
host = 10.120.98.12
port = 23
username = tester
password = password

# hostParser.py
import configparser

class HostConfig:
    def __init__(self, configFile):
        self.configFile= configFile
        self.config= configparser.ConfigParser()
        
    def readConfig(self):
        # Reading the config file
        self.config.read(self.configFile)
    
    def getServers(self):
        # Returning all the sections defined in the config file
        return self.config.sections()
    
    def getData(self, host, key):
        # Getting the values from the particular section (host) 
        # by using the key       
        return self.config[host][key]
    
    def getHostDetails(self, host):
        # Getting all the values defined under the given section (host).
        # Assuming the keys are known and fixed.
        hostdata= self.config[host]
        return hostdata['host'],hostdata['port'],hostdata['username'],hostdata['password']

hostConfig= HostConfig('tempConfig.ini')  # creating object of HostConfig
hostConfig.readConfig()                   # Reading config file 

Servers= hostConfig.getServers()       # Getting the list of sections (servers)
print("Servers: ",Servers)

print("Server 0 data: \n",hostConfig.getHostDetails(Servers[0]))  # Getting items for Section No 0

print("Server1: Host ",hostConfig.getData(Servers[1], 'host'))  # Getting item for Section No 1
print("Server1: Port ",hostConfig.getData(Servers[1], 'port'))  # Getting item for Section No 1
```

## python 2 c converter
[Online Python to C Converter](https://www.codeconvert.ai/python-to-c-converter)  



## 类型提示
[typing — Support for type hints](https://docs.python.org/3/library/typing.html)  
[How to Use Type Hints for Multiple Return Types in Python](https://realpython.com/python-type-hints-multiple-types/)  

## Python for Network Automation
[Python for Network Automation](https://python-automation-book.readthedocs.io/en/stable/index.html)  

## modules
[Python Module of the Week](https://pymotw.com/2/contents.html)  
[Python Module Index](https://docs.python.org/3/py-modindex.html)  
[NCS Python API](https://developer.cisco.com/docs/nso/api/ncs/#package-ncs)  

## subprocess 模块
[The subprocess Module: Wrapping Programs With Python](https://realpython.com/python-subprocess/)  


## 执行 shell 命令
```python
import subprocess

class ShellCmdClient:
    def run_cmd(self, cmd: str) -> str:
        """执行 shell 命令并返回输出"""
        try:
            result = subprocess.run(cmd.split(), check=True, capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout
            else:
                return result.stderr
        except subprocess.CalledProcessError as e:
            return f"Command \"{cmd}\" failed with error: {e.stderr}"
        except Exception as e:
            return f"Unexpected error: {e}"

if __name__ == "__main__":
    try:
        shell = ShellCmdClient()
        output = shell.run_cmd("ls -l")
        print(f"Command output:\n{output}")
    except Exception as e:
        print(f"Unexpected error: {e}")
```

```python

# Type aliases(类型别名) are useful for simplifying complex type signatures. For example:
from collections.abc import Sequence

type ConnectionOptions = dict[str, str]
type Address = tuple[str, int]
type Server = tuple[Address, ConnectionOptions]

def broadcast_message(message: str, servers: Sequence[Server]) -> None:
	...

# The static type checker will treat the previous type signature as
# being exactly equivalent to this one.
def broadcast_message(
		message: str,
		servers: Sequence[tuple[tuple[str, int], dict[str, str]]]) -> None:
```
- [Python Tips](https://book.pythontips.com/en/latest/index.html#) #online
- [Python: Context Manager to Simplify Resource Handling](https://pravash-techie.medium.com/python-context-manager-to-simplify-resource-handling-5959a36a0f58)
- [contextlib   — Utilities for with -statement contexts](https://docs.python.org/3/library/contextlib.html)
- 常用环境变量
	- [PYTHONPATH](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH)
	- [Using PYTHONPATH](https://bic-berkeley.github.io/psych-214-fall-2016/using_pythonpath.html)
	- [Python import, sys.path, and PYTHONPATH Tutorial](https://www.devdungeon.com/content/python-import-syspath-and-pythonpath-tutorial)

- 自定义模块
		- 新建模块目录例如`modules`，在目录下新建多个python文件(例如 geometry.py, math.py)分别实现对应的模块功能
		- 使用时需要将模块目录路径加入到系统的path环境变量
			- ```python
			  import sys
			  sys.path.append("modules")
			  
			  import geometry
			  distance = geometry.distance(1, 1, 5, 5)
			  ```
	- [[pexpect]]
		- [man pexpect](https://pexpect.sourceforge.net/pexpect.html)
		- [man pxssh](https://pexpect.sourceforge.net/pxssh.html)
		- pexpect实现ssh自动登陆
			- ```python
			  #!/usr/bin/python
			  
			  import pexpect
			  
			  class SSHClient:
			          def __init__(self, user, host, pwd):
			                  self.user = user
			                  self.host = host
			                  self.pwd = pwd
			                  self.ssh = None
			          def send_command(self, cmd):
			                  self.ssh.sendline(cmd)
			                  #self.ssh.buffer="" // otherwise it will cause "TypeError: can't concat str to bytes"
			                  self.ssh.expect('support@', timeout=10)
			                  return self.ssh.after + self.ssh.before
			          def close(self):
			                  self.ssh.close()
			          def connect(self):
			                  ssh_newkey = "Are you sure you want to continue connecting"
			                  constr = "ssh " + "-p5617 " + self.user + "@" + self.host
			                  self.ssh = pexpect.spawn(constr, encoding='utf-8')
			                  ret = self.ssh.expect([pexpect.TIMEOUT, ssh_newkey, '[P|p]assword:'])
			                  if ret == 0:
			                          return False, '[%s@%s] Error Connecting' % (self.user, self.host)
			                  if ret == 1:
			                          self.ssh.sendline("yes")
			                          ret = self.ssh.expect([pexpect.TIMEOUT, ssh_newkey, '[P|p]assword:'])
			                          if ret == 0:
			                                  return False, '[%s@%s] Error Connecting' % (self.user, self.host)
			                  self.ssh.sendline(self.pwd)
			                  self.ssh.expect('gs_cli')
			                  self.ssh.sendline('diag-shell\r')
			                  self.ssh.expect('support')
			                  return True, '[%s@%s] Success Connecting' % (self.user, self.host)
			  
			  if __name__ == "__main__":
			          ssh = SSHClient(user="support", host="169.254.32.200", pwd="Gainsp33")
			          ret, msg = ssh.connect()
			          if not ret:
			                  print(msg)
			                  exit(0)
			  
			          cmd = 'ls /tmp'
			          result = ssh.send_command(cmd)
			          print(result)
			  
			          cmd = 'df -h'
			          result = ssh.send_command(cmd)
			          print(result)
			          ssh.close()
			  
			  ```
	- [[str]]
	- [[list]]
	- [[python file]]
	- [[dictionary]]
	- os
		- [Miscellaneous operating system interfaces](https://docs.python.org/3/library/os.html)
		- `os.path`
			- [Common pathname manipulations](https://docs.python.org/3/library/os.path.html#module-os.path)
	- [[re]]
		- [Regular expression operations](https://docs.python.org/3/library/re.html?highlight=re#module-re)
	- glob
		- [Unix style pathname pattern expansion](https://docs.python.org/3/library/glob.html?highlight=glob#module-glob)
	- subprocess
		- [Subprocess management](https://docs.python.org/3/library/subprocess.html)
	- sys
		- [System-specific parameters and functions](https://docs.python.org/3/library/sys.html)
	- datetime
		- [Basic date and time types](https://docs.python.org/3/library/datetime.html)
	- time
		- [Time access and conversions](https://docs.python.org/3/library/time.html)
	- logging
		- [Logging facility for Python](https://docs.python.org/3/library/logging.html?highlight=logging#module-logging)
	- logging.handlers
		- [logging.handlers](https://docs.python.org/3/library/logging.handlers.html?highlight=logging%20handlers#module-logging.handlers)
	- platform
		- [Access to underlying platform ’s identifying data](https://docs.python.org/3/library/platform.html?highlight=platform#module-platform)
	- telnetlib
		- [Telnet client](https://docs.python.org/3/library/telnetlib.html?highlight=telnetlib#module-telnetlib)
	- getpass
		- [Portable password input](https://docs.python.org/3/library/getpass.html)
	- shutil
		- [High-level file operations](https://docs.python.org/3.8/library/shutil.html)
- package
	- 用来整理和分类模块
	- 文件夹结构
		- ```
		  - 项目文件夹
		  	- 主程序.py
		      - 封包文件夹
		      	- __init__.py
		          - 模块1.py
		          - 模块2.py
		  
		  # 例如
		  - python_learn
		  	- main.py
		      - geometry
		      	- __init__.py
		          - point.py
		          - line.py
		  
		  import geometry.point
		  distance = geometry.point.distance(3, 4)
		  
		  import geomegry.point as point
		  distance = point.distance(3, 4)
		  ```
	- 使用封包
		- `import 封包名称.模组名称`
		- `import 封包名称.模组名称 as 模组别名`

- contextlib
	```python
	# context manager: 在一个类里，实现了__enter__和__exit__的方法，这个类的实例就是一个上下文管理器
	class Resource():
		def __enter__(self):
			print('===connect to resource===')
			return self
		def __exit__(self, exc_type, exc_val, exc_tb):
			print('===close resource connection===')

		def operate(self):
			print('===in operation===')

	with Resource() as res:
		res.operate()

	# 使用 contextlib 简化上下文管理器的实现
	import contextlib

	@contextlib.contextmanager
	def operate():
		print("__enter__")
		yield "yielded value"
		print("__exit__")

	with operate() as o:
		print(o)

	# 为什么需要context manager
		# 1.可以以一种更加优雅的方式，操作（创建/获取/释放）资源，如文件操作、数据库连接；
		# 2.可以以一种更加优雅的方式，处理异常
	class Resource():
		def __enter__(self):
			print('===connect to resource===')
			return self

		def __exit__(self, exc_type, exc_val, exc_tb):
			print('===close resource connection===')
			return True	# 在__exit__ 里返回 True 相当于告诉 Python解释器，这个异常我们已经捕获了，不需要再往外抛了

		def operate(self):
			1/0

	with Resource() as res:
		res.operate()


	写__exit__ 函数时，需要注意的事，它必须要有这三个参数：
	exc_type：异常类型
	exc_val：异常值
	exc_tb：异常的错误栈信息
	当主逻辑代码没有报异常时，这三个参数将都为None

	# contextlib是一个装饰器，你只要按照它的代码协议来实现函数内容，就可以将这个函数对象变成一个上下文管理器
	import contextlib

	@contextlib.contextmanager
	def open_func(file_name):
		# __enter__方法
		print('open file:', file_name, 'in __enter__')
		file_handler = open(file_name, 'r')

		# 【重点】：yield
		yield file_handler

		# __exit__方法
		print('close file:', file_name, 'in __exit__')
		file_handler.close()
		return

	with open_func('/Users/MING/mytest.txt') as file_in:
		for line in file_in:
			print(line)
	# 被装饰函数里，必须是一个生成器（带有yield）
		#1 yield之前的代码，就相当于__enter__里的内容
		#2 yield 之后的代码，就相当于__exit__ 里的内容

	# 处理异常
	import contextlib

	@contextlib.contextmanager
	def open_func(file_name):
		# __enter__方法
		print('open file:', file_name, 'in __enter__')
		file_handler = open(file_name, 'r')

		try:
			yield file_handler
		except Exception as exc:
			# deal with exception
			print('the exception was thrown')
		finally:
			print('close file:', file_name, 'in __exit__')
			file_handler.close()

			return

	with open_func('/Users/MING/mytest.txt') as file_in:
		for line in file_in:
			1/0
			print(line)

	// 示例
	@contextlib.contextmanager
	def tempdir(**kwargs):
		argdict = kwargs.copy()
		if 'dir' not in argdict:
			argdict['dir'] = CONF.tempdir
		tmpdir = tempfile.mkdtemp(**argdict)
		try:
			yield tmpdir
		finally:
			try:
				shutil.rmtree(tmpdir)
			except OSError as e:
				LOG.error(LE('Cound not remove tmpdir: %s'), e)


	使用上下文管理器有三个好处：
	1.提高代码的复用率；
	2.提高代码的优雅度；
	3.提高代码的可读性；
	```

[www.python.org](https://www.python.org/)  
[Python 标准库](https://docs.python.org/zh-cn/3/library/)  
[**The Python Standard Library**](https://docs.python.org/3/library/)  
[**Python黑魔法手册**](https://magic.iswbm.com/index.html)  
[**Python 3 Trinkets(python3 online)**](https://trinket.io/features/python3)  
[The Big Book of Small Python Projects](https://inventwithpython.com/bigbookpython/) #online  
[How to Use the Unpacking Operators (*, **) in Python?](https://geekflare.com/python-unpacking-operators/)  
[Python Code Examples](https://www.programcreek.com/python/)  
[**20-python-libraries-you-arent-using-but-should.pdf**](https://github.com/ffisk/books/blob/master/20-python-libraries-you-arent-using-but-should.pdf)  
[Python 3 Cheat Sheet](https://perso.limsi.fr/pointal/_media/python:cours:mementopython3-english.pdf)  
[pythoncheatsheet](https://www.pythoncheatsheet.org/) #online  
[The Hitchhiker’s Guide to Python!](https://docs.python-guide.org/)  
[Python 101](https://www.python101.pythonlibrary.org/index.html#) #online  
[python101code](https://github.com/driscollis/python101code) #github  
[python201bookcode](https://github.com/driscollis/python201bookcode) #github  
[wxpythoncookbookcode](https://github.com/driscollis/wxpythoncookbookcode) #github  
[Automate the Boring Stuff with Python](https://automatetheboringstuff.com/)  
[阿尔法的Python笔记](https://segmentfault.com/blog/alpha94511)  
[python3 cookbook](https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html)  
[Python Documentation contents](https://docs.python.org/3/contents.html)  
[Python for network engineers](https://pyneng.readthedocs.io/en/latest/index.html)  
[Python Tricks: The Book](http://www.kalfaoglu.com/ceng113/Python-Programming/pythontricks.pdf)  
[Programming in Python 3](https://cs.smu.ca/~porter/csc/227/ProgrammingInPython3.pdf)  
[Elements of Programming Interviews in Python](https://elementsofprogramminginterviews.com/sample/epilight_python_new.pdf)  
[Elements of Programming Interviews in Python](https://github.com/qqqil/ebooks/blob/master/algorithms/Elements%20of%20Programming%20Interviews.pdf)  
[PYTHON CRASH COURSE](https://bedford-computing.co.uk/learning/wp-content/uploads/2015/10/No.Starch.Python.Oct_.2015.ISBN_.1593276036.pdf)  
[The Big Book of Small Python Projects](https://inventwithpython.com/bigbookpython/) #online  
[Logging HOWTO](https://docs.python.org/3/howto/logging.html)  
[Awesome_Python_Scripts](https://prathimacode-hub.github.io/Awesome_Python_Scripts/) #github  
[Simple Way of Python's subprocess.Popen with a Timeout Option](https://www.gungorbudak.com/blog/2015/08/30/simple-way-of-pythons-subprocesspopen/)  
[Python 101: How to timeout a subprocess](https://www.blog.pythonlibrary.org/2016/05/17/python-101-how-to-timeout-a-subprocess/)  
[Python 101: How to Timeout a Subprocess](https://dzone.com/articles/python-101-how-to-timeout-a-subprocess)  
[Understanding Python re(gex)?](https://learnbyexample.github.io/py_regular_expressions/cover.html)  
[python projects](https://bedford-computing.co.uk/learning/wp-content/uploads/2015/10/Python-Projects.pdf)  
[The big book of small python projects](https://edu.anarcho-copy.org/Programming%20Languages/Python/BigBookSmallPythonProjects.pdf)  
[learning Python](https://cfm.ehu.es/ricardo/docs/python/Learning_Python.pdf)  
[practice_python_projects](https://github.com/learnbyexample/practice_python_projects)  
[Implementing Threads for Measurements](https://pythonforthelab.com/blog/implementing-threads-for-measurements/)  
[Storing Binary Data and Serializing](https://pythonforthelab.com/blog/storing-binary-data-and-serializing/)  
[What are Hashable Objects](https://pythonforthelab.com/blog/what-are-hashable-objects/)  
[PEP](https://peps.python.org/)  
[Python's filter(): Extract Values From Iterables](https://realpython.com/python-filter-function/)  
[Iterators and Iterables in Python: Run Efficient Iterations](https://realpython.com/python-iterators-iterables/)  
[argparse](https://docs.python.org/3/library/argparse.html)  
[Build Command-Line Interfaces With Python's argparse](https://realpython.com/command-line-interfaces-python-argparse/)  
```python
# argparse
# 1 最简单的 argparse 的例子
$ cat t1.py
import argparse

parser = argparse.ArgumentParser()

$ python t1.py
$ python t1.py --help
usage: t1.py [-h]

optional arguments:
-h, --help  show this help message and exit
$ python t1.py --verbose
usage: t1.py [-h]
t1.py: error: unrecognized arguments: --verbose
$ python t1.py xxx
usage: t1.py [-h]
t1.py: error: unrecognized arguments: xxx
# 没有任何选项的情况下运行脚本不会在标准输出显示任何内容
# --help 选项，也可缩写为 -h，是唯一一个可以直接使用的选项（即不需要指定该选项的内容）。指定任何内容都会导致错误

# 2 位置参数
cat t1.py
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("echo", help="echo the string you use here")
args = parser.parse_args()
print(args.echo)

$ python3 t1.py
usage: t1.py [-h] echo
t1.py: error: the following arguments are required: echo
$ python3 t1.py echo
echo
$ python3 t1.py echo1
echo1

# 3 argparse 会把我们传递给它的选项视作为字符串，除非我们告诉它别这样
cat t1.py
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("square", help="display a square of a given number", type=int)
args = parser.parse_args()
print(args.square ** 2)

$ python3 t1.py 4
16

# 可选参数
cat t1.py
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--verbose", help="increase output verbosity",
					action="store_true")	# action 赋值为 "store_true"，意味着，如果指定了该选项，则将值 True 赋给 args.verbose
args = parser.parse_args()
if args.verbose:
	print("verbosity turned on")

$ python3 t1.py
$ python3 t1.py  --verbose
verbosity turned on

# 短选项
parser.add_argument("-v", "--verbose", help="increase output verbosity",
					action="store_true")	# 添加 "-v"，用来支持短选项

# 结合位置参数和可选参数
cat t1.py
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("square", type=int, help="display a square of a given number")
parser.add_argument("-v", "--verbose", help="increase output verbosity", action="store_true")
args = parser.parse_args()
answer = args.square ** 2
if args.verbose:
	print(f"the square of {args.square} equals {answer}")
else:
	print(answer)

$ python3 t1.py  4
16
$ python3 t1.py  4 --verbose
the square of 4 equals 16
$ python3 t1.py  --verbose 4
the square of 4 equals 16

# 改进 1, 给程序加上接受多个冗长度的值
parser.add_argument("-v", "--verbose", type=int, help="increase output verbosity")

if args.verbose == 2:
	print(f"the square of {args.square} equals {answer}")
elif args.verbose == 1:
	print(f"{args.square}^2 == {answer}")
else:
	print(answer)

$ python3 t1.py  4
16
$ python3 t1.py  4 -v
usage: t1.py [-h] [-v VERBOSE] square
t1.py: error: argument -v/--verbose: expected one argument
$ python3 t1.py  4 -v 1
4^2 == 16
$ python3 t1.py  4 -v 2
the square of 4 equals 16
$ python3 t1.py  4 -v 3		# not as expected
16

# 改进 2， 限制 --verbosity 选项可以接受的值
parser.add_argument("-v", "--verbose", type=int, choices=[0, 1, 2],
					help="increase output verbosity")

$ python3 t1.py  4 -v 3
usage: t1.py [-h] [-v {0,1,2}] square
t1.py: error: argument -v/--verbose: invalid choice: 3 (choose from 0, 1, 2)

# 改进 3，改变冗长度
parser.add_argument("-v", "--verbose", action="count",		# "count" action 用来统计特定选项出现的次数
					help="increase output verbosity")

$ python3 t1.py  4 -v
4^2 == 16
$ python3 t1.py  4 -vv
the square of 4 equals 16
$ python3 t1.py  4 -vvv		# not as expected
16

# 改进 4
if args.verbose >= 2:		# == 改为 >=
	print(f"the square of {args.square} equals {answer}")
elif args.verbose == 1:
	print(f"{args.square}^2 == {answer}")
else:
	print(answer)

$ python3 t1.py  4 -vvv
the square of 4 equals 16
$ python3 t1.py  4
Traceback (most recent call last):
File "t1.py", line 10, in <module>
	if args.verbose >= 2:
TypeError: '>=' not supported between instances of 'NoneType' and 'int' # 默认情况下如果一个可选参数没有被指定，它的值会是 None，不能和整数值相比较

# 改进 5
parser.add_argument("-v", "--verbose", action="count", default=0,		# 关键字 default 设置为 0 来让它可以与其他整数值进行比较
					help="increase output verbosity")

# 扩展执行其他幂次的运算
cat t1.py
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("x", type=int, help="the base")
parser.add_argument("y", type=int, help="the exponent")
parser.add_argument("-v", "--verbosity", action="count", default=0)
args = parser.parse_args()
answer = args.x**args.y
if args.verbosity >= 2:
	print(f"{args.x} to the power {args.y} equals {answer}")
elif args.verbosity >= 1:
	print(f"{args.x}^{args.y} == {answer}")
else:
	print(answer)

$ python3 t1.py  4 2
16
$ python3 t1.py  4 2 -v
4^2 == 16
$ python3 t1.py  4 2 -vv
4 to the power 2 equals 16

# 使用详细级别来显示 更多的 文本
if args.verbosity >= 2:
	print(f"Running '{__file__}'")
if args.verbosity >= 1:
	print(f"{args.x}^{args.y} == ", end="")
print(answer)

$ python3 t1.py  4 2
16
$ python3 t1.py  4 2 -v
4^2 == 16
$ python3 t1.py  4 2 -vv
Running 't1.py'
4^2 == 16

# 处理 矛盾的选项 (--quiet 选项 与 --verbose 的作用相反)
import argparse

parser = argparse.ArgumentParser()
group = parser.add_mutually_exclusive_group()
group.add_argument("-v", "--verbose", action="store_true")
group.add_argument("-q", "--quiet", action="store_true")
parser.add_argument("x", type=int, help="the base")
parser.add_argument("y", type=int, help="the exponent")
args = parser.parse_args()
answer = args.x**args.y

if args.quiet:
	print(answer)
elif args.verbose:
	print(f"{args.x} to the power {args.y} equals {answer}")
else:
	print(f"{args.x}^{args.y} == {answer}")

$ python3 t1.py  4 2
4^2 == 16
$ python3 t1.py  4 2 -q
16
$ python3 t1.py  4 2 -v
4 to the power 2 equals 16
$ python3 t1.py  4 2 -vq
usage: t1.py [-h] [-v | -q] x y
t1.py: error: argument -q/--quiet: not allowed with argument -v/--verbose
$ python3 t1.py  4 2 -v --quiet
usage: t1.py [-h] [-v | -q] x y
t1.py: error: argument -q/--quiet: not allowed with argument -v/--verbose

# 描述程序的主要目标
parser = argparse.ArgumentParser(description="calculate X to the power of Y")

# 示例 2
Four straightforward steps to use Python’s argparse:
1. Import the argparse module.
2. Create an argument parser by instantiating ArgumentParser.
3. Add arguments and options to the parser using the .add_argument() method.
4. Call .parse_args() on the parser to get the Namespace of arguments.


Two types of command-line arguments:
1. Positional arguments, which you know as arguments
2. Optional arguments, which you know as options, flags, or switches.(Optional arguments aren’t mandatory. They allow you to modify the behavior of the command)

The first argument to the .add_argument() method sets the difference between arguments and options. This argument is identified as either name or flag. 
if you provide a name, then you’ll be defining an argument.
if you use a flag, then you’ll add an option.

import argparse
import datetime
from pathlib import Path

parser = argparse.ArgumentParser()

parser.add_argument("path")

parser.add_argument("-l", "--long", action="store_true")

args = parser.parse_args()

target_dir = Path(args.path)

if not target_dir.exists():
    print("The target directory doesn't exist")
    raise SystemExit(1)

def build_output(entry, long=False):
    if long:
        size = entry.stat().st_size
        date = datetime.datetime.fromtimestamp(
            entry.stat().st_mtime).strftime(
            "%b %d %H:%M:%S"
        )
        return f"{size:>6d} {date} {entry.name}"
    return entry.name

for entry in target_dir.iterdir():
    print(build_output(entry, long=args.long))
```