[Built-in Types](https://docs.python.org/3/library/stdtypes.html)  
[**The Python Standard Library**](https://docs.python.org/3/library/)  

[PyMOTW-3](https://pymotw.com/3/index.html)  
[The Python 3 Standard Library by Example](https://github.com/bindrat/PYTHON/tree/main)  

[Python Cheat Sheet](https://www.dataquest.io/cheat-sheet/python-cheat-sheet/)  
[Python Development Tutorials](https://earthly.dev/blog/categories/python/)  
[Working With Files in Python](https://realpython.com/working-with-files-in-python/)  
[Reading and Writing Files in Python (Guide)](https://realpython.com/read-write-files-python/)  
[Python's pathlib Module: Taming the File System](https://realpython.com/python-pathlib/)  
[How to Work with YAML in Python](https://earthly.dev/blog/yaml-in-python/)  
[Python argparse: Definition, How to Use, and Best Practices](https://stackify.com/python-argparse-definition-how-to-use-and-best-practices/)  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[All Python Tutorial Topics](https://realpython.com/tutorials/all/)  
[Python Best Practices for More Pythonic Code](https://realpython.com/tutorials/best-practices/page/1/)  
[Inheritance and Composition: A Python OOP Guide](https://realpython.com/inheritance-composition-python/)  
[How to Replace a String in Python](https://realpython.com/replace-string-python/)  
[Logging in Python](https://realpython.com/python-logging/)  
[Python String Formatting: Available Tools and Their Features](https://realpython.com/python-string-formatting/)  
[Python Code Quality: Best Practices and Tools](https://realpython.com/python-code-quality/)  
[Python's "in" and "not in" Operators: Check for Membership](https://realpython.com/python-in-operator/)  
[How to Write Beautiful Python Code With PEP 8](https://realpython.com/python-pep8/)  
[Python's assert: Debug and Test Your Code Like a Pro](https://realpython.com/python-assert-statement/)  
[Python's property(): Add Managed Attributes to Your Classes](https://realpython.com/python-property/)  
[Dependency Management With Python Poetry](https://realpython.com/dependency-management-python-poetry/)  
[Python String Formatting: Available Tools and Their Features](https://realpython.com/python-string-formatting/)  
[How to Check if a Python String Contains a Substring](https://realpython.com/python-string-contains-substring/)  
[How to Round Numbers in Python](https://realpython.com/python-rounding/)  
[Using and Creating Global Variables in Your Python Functions](https://realpython.com/python-use-global-variable-in-function/)  
[Efficient String Concatenation in Python](https://realpython.com/python-string-concatenation/)  
[Speed Up Your Python Program With Concurrency](https://realpython.com/python-concurrency/)  
[Syntactic Sugar: Why Python Is Sweet and Pythonic](https://realpython.com/syntactic-sugar-python/)  
[String Interpolation in Python: Exploring Available Tools](https://realpython.com/python-string-interpolation/)  
[How to Read User Input From the Keyboard in Python](https://realpython.com/python-keyboard-input/)  
[Documenting Python Code: A Complete Guide](https://realpython.com/documenting-python-code/)  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[How to Catch Multiple Exceptions in Python](https://realpython.com/python-catch-multiple-exceptions/)  
[Python's Self Type: How to Annotate Methods That Return self](https://realpython.com/python-type-self/)  
[Use ChatGPT to Learn Python Programming](https://realpython.com/chatgpt-coding-mentor-python/)  
[SOLID Principles: Improve Object-Oriented Design in Python](https://realpython.com/solid-principles-python/)  
[Python's del: Remove References From Scopes and Containers](https://realpython.com/python-del-statement/)  
[Python's Assignment Operator: Write Robust Assignments](https://realpython.com/python-assignment-operator/)  
[When Do You Use an Ellipsis in Python?](https://realpython.com/python-ellipsis/)  
[Custom Python Dictionaries: Inheriting From dict vs UserDict](https://realpython.com/inherit-python-dict/)  
[Why Is It Important to Close Files in Python?](https://realpython.com/why-close-file-python/)  
[Python's all(): Check Your Iterables for Truthiness](https://realpython.com/python-all/)  
[Reverse Strings in Python: reversed(), Slicing, and More](https://realpython.com/reverse-string-python/)  
[Using the "and" Boolean Operator in Python](https://realpython.com/python-and-operator/)  
[Python's filter(): Extract Values From Iterables](https://realpython.com/python-filter-function/)  
[Python's map(): Processing Iterables Without a Loop](https://realpython.com/python-map-function/)  
[The Python return Statement: Usage and Best Practices](https://realpython.com/python-return-statement/)  
[Pass by Reference in Python: Background and Best Practices](https://realpython.com/python-pass-by-reference/)  
[Python's reduce(): From Functional to Pythonic Style](https://realpython.com/python-reduce-function/)  
[Python Command-Line Arguments](https://realpython.com/python-command-line-arguments/)  
[Python != Is Not is not: Comparing Objects in Python](https://realpython.com/python-is-identity-vs-equality/)  
[How to Use Python Lambda Functions](https://realpython.com/python-lambda/)  
[Python Logging: A Stroll Through the Source Code](https://realpython.com/python-logging-source-code/)  
[Defining Main Functions in Python](https://realpython.com/python-main-function/)  
[An Intro to Threading in Python](https://realpython.com/intro-to-python-threading/)  
[How to Stand Out in a Python Coding Interview](https://realpython.com/python-coding-interview-tips/)  
[Refactoring Python Applications for Simplicity](https://realpython.com/python-refactoring/)  
[Supercharge Your Classes With Python super()](https://realpython.com/python-super/)  
[The Factory Method Pattern and Its Implementation in Python](https://realpython.com/factory-method-python/)  
[Python Type Checking (Guide)](https://realpython.com/python-type-checking/)  
[Continuous Integration With Python: An Introduction](https://realpython.com/python-continuous-integration/)  
[Getting Started With Testing in Python](https://realpython.com/python-testing/)  
[Absolute vs Relative Imports in Python](https://realpython.com/absolute-vs-relative-python-imports/)  
[4 Techniques for Testing Python Command-Line (CLI) Apps](https://realpython.com/python-cli-testing/)  
[]()  
[]()  
[]()  
[]()  


## Real Python Tutorials
[All Python Tutorial Topics](https://realpython.com/tutorials/all/)  
[Common Python Data Structures](https://realpython.com/python-data-structures/)  
[Build a Hash Table in Python With TDD](https://realpython.com/python-hash-table/)  

## python 在线环境
[Python Playground](https://programiz.pro/ide/python)  


## 设计模式
[The Factory Method Pattern and Its Implementation in Python](https://realpython.com/factory-method-python/)  
[Implementing an Interface in Python](https://realpython.com/python-interface/)  
[Inheritance and Composition: A Python OOP Guide](https://realpython.com/inheritance-composition-python/)  
[]()  
[]()  
[]()  
[]()  
[]()  

## 最佳实践
[100 Days of Python](https://martinxpn.medium.com/100-days-of-python-9dd04d0995f1)  
[Your Guide to the Python print() Function](https://realpython.com/python-print/)  
[The Python return Statement: Usage and Best Practices](https://realpython.com/python-return-statement/)  
[Python args and kwargs: Demystified](https://realpython.com/python-kwargs-and-args/)  
[Structural Pattern Matching in Python](https://realpython.com/structural-pattern-matching/)  
[Operators and Expressions in Python](https://realpython.com/python-operators-expressions/)  
[Variables in Python: Usage and Best Practices](https://realpython.com/python-variables/)  
[Python's Built-in Functions: A Complete Exploration](https://realpython.com/python-built-in-functions/)  
[How to Flatten a List of Lists in Python](https://realpython.com/python-flatten-list/)  
[Getters and Setters: Manage Attributes in Python](https://realpython.com/python-getter-setter/)  
[Defining Main Functions in Python](https://realpython.com/python-main-function/)  
[Python Modules and Packages – An Introduction](https://realpython.com/python-modules-packages/)  
[Python import: Advanced Techniques and Tips](https://realpython.com/python-import/)  
[Absolute vs Relative Imports in Python](https://realpython.com/absolute-vs-relative-python-imports/)  
[What's a Python Namespace Package, and What's It For?](https://realpython.com/python-namespace-package/)  
[Using PyInstaller to Easily Distribute Python Applications](https://realpython.com/pyinstaller-python/)  
[Python Keywords: An Introduction](https://realpython.com/python-keywords/)  
[Python Protocols: Leveraging Structural Subtyping](https://realpython.com/python-protocol/)  
[Pydantic: Simplifying Data Validation in Python](https://realpython.com/python-pydantic/)  
[Python Type Checking (Guide)](https://realpython.com/python-type-checking/)  
[Build a Hash Table in Python With TDD](https://realpython.com/python-hash-table/)  
[How to Use Python Lambda Functions](https://realpython.com/python-lambda/)  
[Python's map(): Processing Iterables Without a Loop](https://realpython.com/python-map-function/)  
[Python's reduce(): From Functional to Pythonic Style](https://realpython.com/python-reduce-function/)  
[Sorting Algorithms in Python](https://realpython.com/sorting-algorithms-python/)  
[Python Stacks, Queues, and Priority Queues in Practice](https://realpython.com/queue-in-python/)  
[Linked Lists in Python: An Introduction](https://realpython.com/linked-lists-python/)  
[Duck Typing in Python: Writing Flexible and Decoupled Code](https://realpython.com/duck-typing-python/)  
[When Should You Use .__repr__() vs .__str__() in Python?](https://realpython.com/python-repr-vs-str/)  
[Python Class Constructors: Control Your Object Instantiation](https://realpython.com/python-class-constructor/)  
[Build Enumerations of Constants With Python's Enum](https://realpython.com/python-enum/)  
[Python mmap: Improved File I/O With Memory Mapping](https://realpython.com/python-mmap/)  
[Python eval(): Evaluate Expressions Dynamically](https://realpython.com/python-eval-function/)  
[Python's exec(): Execute Dynamically Generated Code](https://realpython.com/python-exec/)  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  

## 格式化字符串
```python
name = "Alice"
age = 30

# f-string
formatted_string = f"My name is {name} and I am {age} years old."

# str.format() method
formatted_string = "My name is {} and I am {} years old.".format(name, age)

# % operator
formatted_string = "My name is %s and I am %d years old." % (name, age)

# string.Template
template = Template("My name is $name and I am $age years old.")
formatted_string = template.substitute(name=name, age=age)
```

## unittest
[Python's unittest: Writing Unit Tests for Your Code](https://realpython.com/python-unittest/)  
[Getting Started With Testing in Python](https://realpython.com/python-testing/)  
[Effective Python Testing With pytest](https://realpython.com/pytest-python-testing/)  
[Write Unit Tests for Your Python Code With ChatGPT](https://realpython.com/chatgpt-unit-tests-python/)  

## 数据库
[Handling SQL Databases With PyQt: The Basics](https://realpython.com/python-pyqt-database/)  
[Data Management With Python, SQLite, and SQLAlchemy](https://realpython.com/python-sqlite-sqlalchemy/)  
[Introduction to Python SQL Libraries](https://realpython.com/python-sql-libraries/)  

## 图像处理
Image Processing With the Python Pillow Library](https://realpython.com/image-processing-with-the-python-pillow-library/)  

## GUI
[Build a Contact Book With Python, PyQt, and SQLite](https://realpython.com/python-contact-book/)  
[PythonGUIs](https://www.pythonguis.com/pyqt6-tutorial/)  
[Python and PyQt: Building a GUI Desktop Calculator](https://realpython.com/python-pyqt-gui-calculator/)  
[Python GUI Programming With Tkinter](https://realpython.com/python-gui-tkinter/)  
[Handling SQL Databases With PyQt: The Basics](https://realpython.com/python-pyqt-database/)  
[Python and PyQt: Creating Menus, Toolbars, and Status Bars](https://realpython.com/python-menus-toolbars/)  
[PyQt Layouts: Create Professional-Looking GUI Applications](https://realpython.com/python-pyqt-layout/)  
[Qt Designer and Python: Build Your GUI Applications Faster](https://realpython.com/qt-designer-python/)  
[]()  
[]()  
[]()  

## DSA
[Learn Python Programming](https://www.programiz.com/python-programming)  
[Getting Started with DSA](https://www.programiz.com/dsa/getting-started)  

## 面向对象
[Python’s ABC: Understanding the Basics of Abstract Base Classes](https://geekpython.in/abc-in-python)  
[How to Write Cleaner Python Code Using Abstract Classes](https://blog.teclado.com/python-abc-abstract-base-classes/)  
[Python's property(): Add Managed Attributes to Your Classes](https://realpython.com/python-property/)  
[self in Python, Demystified](https://www.programiz.com/article/python-self-why)  
[Namespaces and Scope in Python](https://realpython.com/python-namespaces-scope/)  
[Object-Oriented Programming (OOP) in Python 3](https://realpython.com/python3-object-oriented-programming/)  
[Python Classes: The Power of Object-Oriented Programming](https://realpython.com/python-classes/)  
[Python's Magic Methods: Leverage Their Power in Your Classes](https://realpython.com/python-magic-methods/)  
[Supercharge Your Classes With Python super()](https://realpython.com/python-super/)  

## 正则匹配
[Regular Expressions: Regexes in Python (Part 1)](https://realpython.com/regex-python/)  
[Regular Expressions: Regexes in Python (Part 2)](https://realpython.com/regex-python-part-2/)  

## Python Projects
[python beginner projects](https://github.com/Mrinank-Bhowmick/python-beginner-projects/tree/main)  
[Python Projects You Can Build](https://realpython.com/tutorials/projects/)  
[python mini projects](https://github.com/Python-World/python-mini-projects/tree/master)  

## 文件操作
[Working With Files in Python](https://realpython.com/working-with-files-in-python/)  
[Reading and Writing Files in Python (Guide)](https://realpython.com/read-write-files-python/)  
[Reading and Writing CSV Files in Python](https://realpython.com/python-csv/)  
[Working With JSON Data in Python](https://realpython.com/python-json/)  


## 远程登录
```python
# paramiko
import paramiko
import time
import re
from datetime import datetime
from typing import List, Tuple, Dict, Optional

EVC_NAME = "evc-cooker-zhisheng"
VMC_NAME = "vmc-1-cooker"
CM_MAC = "74:9b:e8:5c:bb:50"

class SSHSession:
    """
    SSH 会话管理类，用于封装 SSH 连接和命令执行
    """
    
    def __init__(self, hostname: str, username: str, password: str = None, 
                 port: int = 22, key_file: str = None, timeout: float = 10):
        """
        初始化 SSH 会话
        
        Args:
            hostname: 目标主机名或 IP
            username: 用户名
            password: 密码（可选，如果使用密钥则不需要）
            port: SSH 端口，默认 22
            key_file: 私钥文件路径（可选）
            timeout: 连接超时时间
        """
        self.hostname = hostname
        self.username = username
        self.password = password
        self.port = port
        self.key_file = key_file
        self.timeout = timeout
        
        self.client = paramiko.SSHClient()
        self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        self.channel = None
        self.is_connected = False

    def connect(self) -> None:
        """建立 SSH 连接并创建交互式 shell"""
        try:
            if self.key_file:
                private_key = paramiko.RSAKey.from_private_key_file(self.key_file)
                self.client.connect(
                    hostname=self.hostname,
                    port=self.port,
                    username=self.username,
                    pkey=private_key,
                    timeout=self.timeout
                )
            else:
                self.client.connect(
                    hostname=self.hostname,
                    port=self.port,
                    username=self.username,
                    password=self.password,
                    timeout=self.timeout
                )
            
            self.channel = self.client.invoke_shell()
            self.is_connected = True
            time.sleep(1)  # 等待 shell 初始化
            print(f"Connected to {self.hostname}")
            
        except paramiko.AuthenticationException as e:
            raise Exception(f"Authentication failed: {e}")
        except paramiko.SSHException as e:
            raise Exception(f"SSH connection failed: {e}")

    def disconnect(self) -> None:
        """关闭 SSH 连接"""
        if self.is_connected:
            self.client.close()
            self.is_connected = False
            self.channel = None
            print("SSH connection closed")

    def execute_command(self, command: str, wait_time: float = 2) -> str:
        """
        在当前会话中执行单条命令并返回输出
        
        Args:
            command: 要执行的命令
            wait_time: 等待输出时间
        Returns:
            命令执行的输出
        """
        if not self.is_connected or not self.channel:
            raise RuntimeError("No active SSH session. Please connect first.")
        
        self.channel.send(f"{command}\n")
        time.sleep(wait_time)
        output = self._get_output()
        print(f"Command '{command}' executed")
        return output

    def execute_commands(self, commands: List[Tuple[str, float]]) -> Dict[str, str]:
        """
        在当前会话中执行多条命令并返回所有输出
        
        Args:
            commands: 包含 (命令, 等待时间) 的列表
        Returns:
            命令及其输出的字典
        """
        if not self.is_connected or not self.channel:
            raise RuntimeError("No active SSH session. Please connect first.")
        
        results = {}
        for command, wait_time in commands:
            results[command] = self.execute_command(command, wait_time)
        return results

    def _get_output(self) -> str:
        """从通道读取输出"""
        output = ""
        while self.channel.recv_ready():
            output += self.channel.recv(1024).decode("utf-8")
            time.sleep(0.5)
        return output.strip()

    def __enter__(self):
        """支持上下文管理器"""
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出时自动关闭连接"""
        self.disconnect()


class CommandProcessor:
    """命令处理类"""
    def __init__(self, session: SSHSession):
        self.session = session

    def setup_session(self) -> None:
        """执行初始设置命令"""
        setup_commands = [
            (f"nomad alloc exec -task evc -job {EVC_NAME} sh", 1),
            ("ncs_cli -u admin", 1)
        ]
        self.session.execute_commands(setup_commands)

    def get_modem_info(self) -> str:
        """获取modem信息"""
        cmd = "show cable modem brief | tab | nomore"
        return self.session.execute_command(cmd, 2)

    def get_field_after_operational(self, text: str) -> str:
        # 匹配 operational 后跟一个或多个空格，然后捕获下一个非空字段
        pattern = r'operational[^\s]*\s+(\S+)'
        match = re.search(pattern, text)
        if match:
            return match.group(1)
        return "nomatch"

    def set_channel_state(self, channel: str, state: str) -> None:
        """设置通道状态"""
        cmd = f"vmc {VMC_NAME} mac-domain 0 ds ds-channels {channel} admin-state {state}"
        commands = [
            ("config", 1),
            (cmd, 1),
            ("commit", 2),
            ("top", 1),
            ("exit", 1)
        ]
        self.session.execute_commands(commands)

if __name__ == "__main__":
    # Configuration
    HOST = "10.254.25.106"
    USERNAME = "root"
    PASSWORD = "Gainsp33"
    
    with SSHSession(HOST, USERNAME, PASSWORD) as session:
        cmd_processor = CommandProcessor(session)
        cmd_processor.setup_session()
        
        pre_primary = ""
        ds_primary = ""
        for i in range(5):
            output = cmd_processor.get_modem_info()
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            print(f"{current_time}: {output}")
            
            lines = output.split("\n")
            for line in lines:
                # match exact mac address and operational status
                if CM_MAC in line and "operational" in line:
                    ds_primary = cmd_processor.get_field_after_operational(line)
                    if ds_primary == "nomatch":
                        print("get ds primary channel failed")
                        break
                    
                    # modem is still online with the same ds_primary after ds primary channel dowm
                    if pre_primary and pre_primary == ds_primary:
                        print(f"pre_primary and ds_primary are the same: {ds_primary}, wait for 60 seconds")
                        time.sleep(60)
                        break
                    
                    # up the pre_primary
                    if pre_primary and pre_primary != ds_primary:
                        cmd_processor.set_channel_state(pre_primary, "up")
                    
                    # down the current ds_primary
                    print(f"ds_primary: {ds_primary}")
                    cmd_processor.set_channel_state(ds_primary, "down")
                    
                    # update pre_primary
                    print(f"update pre_primary to {ds_primary}")
                    pre_primary = ds_primary
                    break
            
            time.sleep(10)
        
        if pre_primary:
            cmd_processor.set_channel_state(pre_primary, "up")

# pexpect
import pexpect
import time

class TelnetClient:
    def __init__(self, host, username, password, port=23, login_timeout=10, command_timeout=10):
        """
        初始化 Telnet 客户端
        :param host: Telnet 服务器地址
        :param username: 登录用户名
        :param password: 登录密码
        :param port: Telnet 服务器端口号，默认为 23
        :param login_timeout: 登录超时时间，默认为 10 秒
        :param command_timeout: 命令执行超时时间，默认为 10 秒
        """
        self.host = host
        self.username = username
        self.password = password
        self.port = port
        self.login_timeout = login_timeout
        self.command_timeout = command_timeout
        self.child = None

    def connect(self):
        """
        建立 Telnet 连接
        """
        try:
            # 构造 Telnet 连接命令
            cmd = f'telnet {self.host} {self.port}'
            self.child = pexpect.spawn(cmd, timeout=self.login_timeout)
            # 等待登录提示符
            self.child.expect('User Name :', timeout=self.login_timeout)
            # 输入用户名
            self.child.sendline(self.username)
            # 等待密码提示符
            self.child.expect('Password  :', timeout=self.login_timeout)
            # 输入密码
            self.child.sendline(self.password)
            # 等待登录成功后的提示符
            self.child.expect(['apc>'], timeout=self.login_timeout)
            print(f"Successfully connected to {self.host}:{self.port}")
            return True
        except Exception as e:
            print(f"Failed to connect to {self.host}:{self.port}, error: {e}")
            return False

    def execute_command(self, command):
        """
        执行单条命令
        :param command: 要执行的命令
        :return: 命令输出
        """
        if not self.child:
            print("Not connected to a Telnet server.")
            return None

        try:
            # 发送命令
            self.child.sendline(command)
            # 等待命令输出结束
            self.child.expect(['apc>'], timeout=self.command_timeout)
            # 获取命令输出
            output = self.child.before.decode('utf-8').strip()
            return output
        except Exception as e:
            print(f"Failed to execute command '{command}', error: {e}")
            return None

    def execute_commands(self, commands):
        """
        执行多条命令
        :param commands: 要执行的命令列表
        :return: 每条命令的输出列表
        """
        outputs = []
        for cmd in commands:
            output = self.execute_command(cmd)
            outputs.append(output)
        return outputs

    def close(self):
        """
        关闭 Telnet 连接
        """
        if self.child:
            self.child.close()
            self.child = None
            print("Telnet connection closed")


class ApcCmdProcessor:
    def __init__(self, telnet_client):
        self.telnet_client = telnet_client

    def get_outlet_status(self, outlet, wait_time=1):
        command = f"olStatus {outlet}"
        output = self.telnet_client.execute_command(command)
        time.sleep(wait_time)
        return output

    def set_outlet_status(self, outlet, status, wait_time=1):
        if status not in ["on", "off"]:
            print("Invalid status. Please use 'on' or 'off'.")
            return
        if status == "on":
            command = f"olOn {outlet}"
        else:
            command = f"olOff {outlet}"
        output = self.telnet_client.execute_command(command)
        time.sleep(wait_time)
        return output

if __name__ == "__main__":
    # Telnet 服务器信息
    host = "10.254.25.46"
    port = 23
    username = "apc"
    password = "apc"

    # 创建 Telnet 客户端
    telnet_client = TelnetClient(host, username, password, port)

    # 连接到 Telnet 服务器
    if telnet_client.connect():
        # 创建 ApcCmdProcessor 实例
        apc_processor = ApcCmdProcessor(telnet_client)
        
        # 执行单条命令
        output = apc_processor.get_outlet_status(14)
        print("Command output:")
        print(output)
        
        # 执行单条命令
        output = apc_processor.set_outlet_status(14, "off")
        print("Command output:")
        print(output)
        
        # 执行单条命令
        output = apc_processor.get_outlet_status(14)
        print("Command output:")
        print(output)

        # 关闭连接
        telnet_client.close()
```

## logging
[Logging in Python](https://realpython.com/python-logging/)  
[Python Logging: A Stroll Through the Source Code](https://realpython.com/python-logging-source-code/)  

## 网络
[Python's Requests Library (Guide)](https://realpython.com/python-requests/)  
[Socket Programming in Python](https://realpython.com/python-sockets/)  
[Python and REST APIs: Interacting With Web Services](https://realpython.com/api-integration-in-python/)  


## 装饰器
[Python Descriptors: An Introduction](https://realpython.com/python-descriptors/)  
[Primer on Python Decorators](https://realpython.com/primer-on-python-decorators/)  
[Context Managers and Python's with Statement](https://realpython.com/python-with-statement/)  
```python
# 示例：timer 装饰器用来统计函数的执行时间
import time
# 装饰器内部的wrapper函数中的参数*args, **kwargs保证了其可以处理所有的参数类型，保证了参数传递的统一，使得装饰器的实现成为可能
# python程序解释器在运行时会解析函数所提供的参数，根据函数签名进行参数匹配，*args用于捕捉未匹配的位置参数（除了required parameters），**kwargs用于捕捉未匹配的关键字参数
# 当wrapper函数调用真正的函数被时，*args和**kwargs会被unpack，即*args展开为对应的位置参数，**kwargs展开为对应的关键字参数
def timer(func):
    def wrapper(*args, **kwargs):
        print("positional args:", args)
        print("keyword args:", kwargs)
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        print("-" * 20)
        return result
    return wrapper

@timer
def no_args():
    time.sleep(0.1)
    print("no args here")

@timer
def with_positional(num):
    time.sleep(0.2)
    print(f"with positional arg {num}")

@timer
def with_keyword(name, age=18):
    time.sleep(0.3)
    print(f"with keyword, name:{name}, age:{age}")


no_args()
with_positional(1)
with_keyword(name="Alice")


Output:
positional args: ()
keyword args: {}
no args here
no_args took 0.1002 seconds
--------------------
positional args: (1,)
keyword args: {}
with positional arg 1
with_positional took 0.2002 seconds
--------------------
positional args: ()
keyword args: {'name': 'Alice'}
with keyword, name:Alice, age:18
with_keyword took 0.3003 seconds
--------------------



# with ...
class SimpleClass:
    def __init__(self):
        print("__init__")

    def simple_method(self):
        print("simple_method")

    def _finalize(self):
        print("_finalize")
    
    def __enter__(self):
        print("__enter__")
        return self
    
    def __exit__(self, exc_type, exc_value, exc_tb):
        print("__exit__")
        self._finalize()


with SimpleClass() as sc:
    sc.simple_method()

Output:
__init__
__enter__
simple_method
__exit__
_finalize
```

## 迭代器
[Iterators and Iterables in Python: Run Efficient Iterations](https://realpython.com/python-iterators-iterables/)  
[How to Use Generators and yield in Python](https://realpython.com/introduction-to-python-generators/)  
[Python for Loops: The Pythonic Way](https://realpython.com/python-for-loop/)  
```python
# 使用 yield 的函数被称为生成器函数
# 当调用生成器函数时，它不会立即执行并返回结果，而是返回一个生成器对象（generator object）, 该生成器对象是一个迭代器，可以通过 next() 调用逐步执行，每次遇到 yield 时暂停并返回值，下次调用时从暂停处继续

# 底层机制：生成器对象和状态保存
1.生成器对象：一个封装了执行状态的结构体
2.字节码：控制执行流程的指令
3.调用帧（frame）：保存局部变量和执行位置

#a 生成器对象
当你调用 gen() 时，Python 不直接执行函数体，而是返回一个 PyGenObject（生成器对象）
这个对象包含：
1.代码对象（gi_code）：函数编译后的字节码（gen.__code__）
2.执行帧（gi_frame）：一个 PyFrameObject，保存当前执行状态
3.运行状态（gi_running）：标记生成器是否正在执行
def gen():
	yield 1
	yield 2

g = gen()
print(g.gi_code.co_code)   # 字节码
print(g.gi_frame)          # 当前帧

#b yield 如何暂停
当生成器执行到 yield 时：
1.字节码指令：YIELD_VALUE 指令被触发
2.暂停执行：解释器将当前值推送到调用者，并暂停生成器的执行
3.保存状态：当前帧（PyFrameObject）保留下来，而不是被销毁

#c 如何恢复
调用 next(g) 时：
1.恢复帧：解释器从 gi_frame 恢复上次的状态。
2.继续执行：从上次暂停的字节码位置开始运行，直到下个 yield 或函数结束。

# 查看帧状态
import inspect

def gen():
    x = 10
    yield x
    x += 5
    yield x

g = gen()
print(next(g))          # 10
frame = g.gi_frame
print(frame.f_locals)   # {'x': 10}
print(next(g))          # 15
print(frame.f_locals)   # {'x': 15}

# 内存和性能
内存：生成器高效是因为它只保存一个帧，而不是整个调用栈的副本。相比列表，内存占用低得多
性能：暂停和恢复的开销很小，主要是帧切换和栈操作，接近 O(1)
def infinite():
    x = 0
    while True:
        yield x
        x += 1

g = infinite()
print(next(g))  # 0
print(next(g))  # 1
```

## 异常处理
[Python Exceptions: An Introduction](https://realpython.com/python-exceptions/)  
[Python's Built-in Exceptions: A Walkthrough With Examples](https://realpython.com/python-built-in-exceptions/)  
[Python's raise: Effectively Raising Exceptions in Your Code](https://realpython.com/python-raise-exception/)  

## string 操作
[String Interpolation in Python: Exploring Available Tools](https://realpython.com/python-string-interpolation/)  
[Strings and Character Data in Python](https://realpython.com/python-strings/)  
[String Methods](https://docs.python.org/3/library/stdtypes.html#string-methods)  
[A Guide to Modern Python String Formatting Tools](https://realpython.com/python-formatted-output/)  
[Python String Formatting: Available Tools and Their Features](https://realpython.com/python-string-formatting/)  
[Python's F-String for String Interpolation and Formatting](https://realpython.com/python-f-strings/)  
[Python f-string: A Complete Guide](https://www.datacamp.com/tutorial/python-f-string)  
[How to Replace a String in Python](https://realpython.com/replace-string-python/)  
[How to Join Strings in Python](https://realpython.com/python-join-string/)  
[How to Split a String in Python](https://realpython.com/python-split-string/)  

## 列表，元组和字典
[Basic Data Types in Python: A Quick Exploration](https://realpython.com/python-data-types/)  
[Python's list Data Type: A Deep Dive With Examples](https://realpython.com/python-list/)  
[Python's tuple Data Type: A Deep Dive With Examples](https://realpython.com/python-tuple/)  
[Lists vs Tuples in Python](https://realpython.com/python-lists-tuples/)  
[Dictionaries in Python](https://realpython.com/python-dicts/)  
[Sets in Python](https://realpython.com/python-sets/)  
[Python Constants: Improve Your Code's Maintainability](https://realpython.com/python-constants/)  
[How to Remove Items From Lists in Python](https://realpython.com/remove-item-from-list-python/)  
[Python Dictionaries: A Comprehensive Tutorial (with 52 Code Examples)](https://www.dataquest.io/blog/python-dictionaries/)  
[Python Datetime Tutorial: Manipulate Times, Dates, and Time Spans](https://www.dataquest.io/blog/python-datetime-tutorial/)  
[Strings and Character Data in Python](https://realpython.com/python-strings/)  
[]()  
[]()  

## list
```python
# list 的特征
Ordered: They contain elements or items that are sequentially arranged according to their specific insertion order.
Zero-based: They allow you to access their elements by indices that start from zero.
Mutable: They support in-place mutations or changes to their contained elements.
Heterogeneous: They can store objects of different types.
Growable and dynamic: They can grow or shrink dynamically, which means that they support the addition, insertion, and removal of elements.
Nestable: They can contain other lists, so you can have lists of lists.
Iterable: They support iteration, so you can traverse them using a loop or comprehension while you perform operations on each of their elements.
Sliceable: They support slicing operations, meaning that you can extract a series of elements from them.
Combinable: They support concatenation operations, so you can combine two or more lists using the concatenation operators.
Copyable: They allow you to make copies of their content using various techniques.

## constuct list
# list literals
digits = [1, 2, 3]
# the list() constructor
digits = list((1, 2, 3))
# a list comprehension
digits = [num for num in range(1, 4)]

## access items in a list
# indexing
digits[0]    # 1
digits[-1]   # 3

employees = [
    ("John", 30, "Software Engineer"),
    ("Alice", 25, "Web Developer")
]
employees[1][0]     # "Alice"
employees[1][1]     # "25
employees[1][2]     # "Web Developer"

employees = [
    {"name": "John", "age": 30, "job": "Software Engineer"},
    {"name": "Alice", "age": 25, "job": "Web Developer"}
]
employees[1]["name"]    # "Alice"
employees[1]["age"]     # "25
employees[1]["job"]     # "Web Developer"

## retrieve multiple items from a list: slicing
list_object[start:stop:step]
default values:
    start: 0
    stop: len(list_object)
    step: 1

digits = list(range(0, 10))     # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
first_three = digits[:3]        # [0, 1, 2】
middle_four = digits[3:7]       # [3, 4, 5, 6]
last_three = digits[-3:]        # [7, 8, 9]
every_other = digits[::2]       # [0, 2, 4, 6, 8]
every_three = digits[::3]       # [0, 3, 6, 9]

# Every slicing operation uses a slice object internally. 
letters = ["A", "a", "B", "b", "C", "c", "D", "d"]
upper_letters = letters[slice(0, None, 2)]  # ['A', 'B', 'C', 'D']
lower_letters = letters[slice(1, None, 2)]  # ['a', 'b', 'c', 'd']

## create copies of a list
# aliases of a list
countries = ["United States", "Canada", "Poland", "Germany", "Austria"]
nations = countries
id(countries) == id(nations)    # True

# A shallow copy of an existing list is a new list containing references to the objects stored in the original list
# create shallow copies of an existing list
1. The slicing operator, [:]
2. The .copy() method
3. The copy() function from the copy module

countries = ["United States", "Canada", "Poland", "Germany", "Austria"]
nations = countries[:]
# nations = countries.copy()
# from copy import copy
# nations = copy(countries)
id(countries) == id(nations)    # False
id(nations[0]) == id(countries[0])  # True
id(nations[1]) == id(countries[1])  # True

countries[0] = "United States of America"
countries                           # ['United States of America', 'Canada', 'Poland', 'Germany', 'Austria']
nations                             # ['United States', 'Canada', 'Poland', 'Germany', 'Austria']
id(nations[0]) == id(countries[0])  # False
id(nations[1]) == id(countries[1])  # True

# deep copy of a list
build a complete copy of an existing list. In other words, you want a copy that creates a new list object and also creates new copies of the contained elements

from copy import deepcopy
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
id(matrix) == id(matrix_copy)           # False
id(matrix[0]) == id(matrix_copy[0])     # False
id(matrix[1]) == id(matrix_copy[1])     # False

# 如果使用浅拷贝，当改变list内部嵌套list时，会改变原来的list
from copy import copy

matrix_copy = copy(matrix)
matrix_copy[0][0] = 100
matrix_copy[0][1] = 200
matrix_copy[0][2] = 300
matrix_copy                # [[100, 200, 300], [4, 5, 6], [7, 8, 9]]
matrix                     # [[100, 200, 300], [4, 5, 6], [7, 8, 9]]

# update items in a list: index assignment, slice assignment
numbers = [1, 2, 3, 4]
numbers[0] = "one"
numbers                 # ['one', 2, 3, 4]

fruits = ["apple", "banana", "orange", "kiwi", "grape"]
fruits[fruits.index("kiwi")] = "mango"
fruits                                  # ['apple', 'banana', 'orange', 'mango', 'grape']

numbers = [1, 2, 3, 4, 5, 6, 7]
numbers[1:4] = [22, 33, 44]
numbers                                 # [1, 22, 33, 44, 5, 6, 7]

numbers = [1, 5, 6, 7]
numbers[1:1] = [2, 3, 4]
numbers                                 # [1, 2, 3, 4, 5, 6, 7]

numbers = [1, 2, 0, 0, 0, 0, 4, 5, 6, 7]
numbers[2:6] = [3]
numbers                                 # [1, 2, 3, 4, 5, 6, 7]

# grow and shrink list dynamically
pets = ["cat", "dog"]
pets.append("parrot")
pets                # ['cat', 'dog', 'parrot']
pets.append(["hamster", "turtle"])  # [..., 'parrot', ["hamster", "turtle"]]

fruits = ["apple", "pear", "peach"]
fruits.extend(["orange", "mango", "banana"])
fruits                                          # ['apple', 'pear', 'peach', 'orange', 'mango', 'banana']

letters = ["A", "B", "F", "G"]
letters.insert(2, "C")
letters                                         # ['A', 'B', 'C', 'F', 'G']

# delete items from a list
sample = [12, 11, 10, 42, 14, 12, 42]
sample.remove(42)
sample                                          # [12, 11, 10, 14, 12, 42]

nums = [1, 2, 3]
num = nums.pop()    # 3
nums                # [1, 2]
num = nums.pop(0)   # 1
nums                # [2]
num = nums.pop(-1)  # 2
nums                # []

cache = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
cache.clear()
cache           # []

colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
del colors[1]
colors                      # ['red', 'yellow', 'green', 'blue', 'indigo', 'violet']
del colors[-1]
colors                      # ['red', 'yellow', 'green', 'blue', 'indigo']
del colors[2:4]
colors                      # ['red', 'yellow', 'indigo']
del colors[:]
colors                      # []

# Considering Performance While Growing Lists
from sys import getsizeof

numbers = []
for value in range(100):
    print(getsizeof(numbers))
    numbers.append(value)
...
56
88
88
...

# concatenate and repeat lists
# Whenever you use the concatenation operator, you get a new list object as a result
digits = [0, 1, 2, 3, 4, 5]
id(digits)                          # 4558758720
digits = digits + [6, 7, 8, 9]
id(digits)                          # 4470412224

# the augmented variation mutates the target list in place rather than creating a new list
digits = [0, 1, 2, 3, 4, 5]
id(digits)                      # 4699578112
digits += [6, 7, 8, 9]
id(digits)                      # 4699578112


["A", "B", "C"] * 3         # ['A', 'B', 'C', 'A', 'B', 'C', 'A', 'B', 'C']
3 * ["A", "B", "C"]         # ['A', 'B', 'C', 'A', 'B', 'C', 'A', 'B', 'C']

letters = ["A", "B", "C"]
letters *= 3            #  mutates the target list in place
letters                 # ['A', 'B', 'C', 'A', 'B', 'C', 'A', 'B', 'C']

## reverse and sort lists
digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
reversed(digits)                     # <list_reverseiterator object at 0x10b261a50>
list(reversed(digits))               # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
digits                               # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
digits.reverse()                     # reverses a list in place
digits                               # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

>>> digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> digits[::-1]                    # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

>>> numbers = [2, 9, 5, 1, 6]
>>> sorted(numbers)                 # [1, 2, 5, 6, 9]
>>> numbers                         # [2, 9, 5, 1, 6]

>>> numbers = [2, 9, 5, 1, 6]
>>> sorted(numbers, reverse=True)   # [9, 6, 5, 2, 1]

>>> numbers = [2, 9, 5, 1, 6]
>>> numbers.sort()
>>> numbers                         # [1, 2, 5, 6, 9]

# traverse lists
>>> colors = [
    "red",
    "orange",
    "yellow",
    "green",
    "blue",
    "indigo",
    "violet"
... ]

>>> for color in colors:
    print(color)

>>> for i in range(len(colors)):
    print(colors[i])

>>> for i, color in enumerate(colors):
    print(f"{i} is the index of '{color}'")

>>> for color in reversed(colors):
    print(color)

>>> numbers = [2, 9, 5, 1, 6]
>>> for number in sorted(numbers):
    print(number)

>>> integers = [1, 2, 3]
>>> letters = ["a", "b", "c"]
>>> floats = [4.0, 5.0, 6.0]

>>> for i, l, f in zip(integers, letters, floats):
    print(i, l, f)

# list comprehension
>>> numbers = ["2", "9", "5", "1", "6"]
>>> numbers = [int(number) for number in numbers]
>>> numbers                                         # [2, 9, 5, 1, 6]

>>> integers = [20, 31, 52, 6, 17, 8, 42, 55]
>>> even_numbers = [number for number in integers if number % 2 == 0]
>>> even_numbers                                    # [20, 52, 6, 8, 42]

# process list with functional tools
>>> numbers = ["2", "9", "5", "1", "6"]
>>> numbers = list(map(int, numbers))
>>> numbers                                     # [2, 9, 5, 1, 6]

>>> integers = [20, 31, 52, 6, 17, 8, 42, 55]
>>> even_numbers = list(filter(lambda number: number % 2 == 0, integers))
>>> even_numbers                                # [20, 52, 6, 8, 42]

reduce()
min()
max()
sum()
all()
any()

# find item in a list
>>> usernames = ["john", "jane", "bob", "david", "eve"]
>>> "linda" in usernames                # False
>>> "linda" not in usernames            # True

>>> usernames = ["john", "jane", "bob", "david", "eve"]
>>> usernames.index("eve")              # 4

>>> sample = [12, 11, 10, 50, 14, 12, 50]
>>> sample.count(12)            # 2
>>> sample.count(11)            # 1
>>> sample.count(100)           # 0

# get the len, max and min of a list
>>> grades = [80, 97, 86, 100, 98, 82]
>>> n = len(grades)
>>> sum(grades) / n     # 90.5

>>> min([3, 5, 9, 1, -5])       # -5
>>> max([3, 5, 9, 1, -5])       # 9

# compare lists
>>> [2, 3] == [2, 3]            # True
>>> [5, 6] != [5, 6]            # False
>>> [5, 6, 7] < [7, 5, 6]       # True
>>> [5, 6, 7] > [7, 5, 6]       # False
>>> [4, 3, 2] <= [4, 3, 2]      # True
>>> [4, 3, 2] >= [4, 3, 2]      # True
>>> [5, 6, 7] < [8]             # True
>>> [5, 6, 7] == [5]            # False

# remove repeated items from a list
>>> list(set([2, 4, 5, 2, 3, 5]))   # [2, 3, 4, 5]

# create multidimensional lists
>>> matrix = []
>>> for row in range(5):
    matrix.append([])
    for _ in range(5):
        matrix[row].append(0)

>>> matrix
[
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0]
]

>>> [[0 for _ in range(5)] for _ in range(5)]
[
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0]
]

>>> [[0] * 5 for _ in range(5)]
[
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0]
]

>>> matrix = [[0] * 5] * 5
>>> matrix
[
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0]
]

>>> matrix[0][0] = 1
>>> matrix
[
    [1, 0, 0, 0, 0],
    [1, 0, 0, 0, 0],
    [1, 0, 0, 0, 0],
    [1, 0, 0, 0, 0],
    [1, 0, 0, 0, 0]
]

# flaten multidimensional lists
>>> matrix = [[0, 1, 2], [10, 11, 12], [20, 21, 22]]
>>> flattened_list = []
>>> for row in matrix:
    flattened_list.extend(row)
>>> flattened_list                  # [0, 1, 2, 10, 11, 12, 20, 21, 22]

# split lists into chunks
>>> def split_list(list_object, chunk_size):
    chunks = []
    for start in range(0, len(list_object), chunk_size):
        stop = start + chunk_size
        chunks.append(list_object[start:stop])
    return chunks

>>> split_list([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)      # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# decide whether to use lists
# when
Keep your data ordered: Lists maintain the order of insertion of their items.
Store a sequence of values: Lists are a great choice when you need to store a sequence of related values.
Mutate your data: Lists are mutable data types that support multiple mutations.
Access random values by index: Lists allow quick and easy access to elements based on their index.

# when not
Store immutable data: In this case, you should use a tuple. They’re immutable and more memory efficient.
Represent database records: In this case, consider using a tuple or a data class.
Store unique and unordered values: In this scenario, consider using a set or dictionary. Sets don’t allow duplicated values, and dictionaries can’t hold duplicated keys.
Run many membership tests where item doesn’t matter: In this case, consider using a set. Sets are optimized for this type of operation.
Run advanced array and matrix operations: In these situations, consider using NumPy’s specialized data structures.
Manipulate your data as a stack or queue: In those cases, consider using deque from the collections module or Queue, LifoQueue, or PriorityQueue. These data types are thread-safe and optimized for fast inserting and removing on both ends.
```

## pathlib
[Python's pathlib Module: Taming the File System](https://realpython.com/python-pathlib/)  

## 多线程
[An Intro to Threading in Python](https://realpython.com/intro-to-python-threading/)  
[Python Thread Safety: Using a Lock and Other Techniques](https://realpython.com/python-thread-lock/)  

## 异步 IO
[Speed Up Your Python Program With Concurrency](https://realpython.com/python-concurrency/)  
[Getting Started With Async Features in Python](https://realpython.com/python-async-features/)  
[Async IO in Python: A Complete Walkthrough](https://realpython.com/async-io-python/)  
```python
# 异步编程
异步编程是一种并发模型，允许程序在等待某些操作（如 I/O）完成时继续执行其他任务，而不是阻塞线程。它基于事件循环（event loop）和非阻塞调用，特别适合高并发场景
"""
[Event Loop] <-----------------------------+
  |                                        |
  |  调度和运行                             |
  v                                        |
[Task Queue]                               |
  |  +----------------+                    |
  |  | Task 1         | <---+              |
  |  |  - Coroutine A |     |              |
  |  |  - State: Run  |     |              |
  |  +----------------+     |              |
  |  +----------------+     |              |
  |  | Task 2         | <---+              |
  |  |  - Coroutine B |     |   await      |
  |  |  - State: Wait |     +------------> [I/O Operation]
  |  +----------------+     |                (e.g., asyncio.sleep)
  |                         |
  |  asyncio.gather --------+ 并发运行多个任务
  v
[Finished Tasks] ----------> 输出结果
"""

asyncio的核心组件：
1.事件循环（Event Loop）：调度和运行异步任务
事件循环是异步编程的核心，负责：
	a) 调度协程的执行
	b) 处理 I/O 事件（如网络数据到达）
	c) 管理任务的暂停和恢复
2.协程（Coroutines）：用 async def 定义的函数, 调用时返回一个协程对象（coroutine 类型）。它不会立即执行，必须通过事件循环调度
3.await：暂停协程，将控制权交回事件循环，等待某个 awaitable 对象（协程、任务或 Future）完成
4.asyncio.sleep:异步的，返回一个 Future，事件循环可以在等待时处理其他任务

import asyncio

async def task(name, delay):
    await asyncio.sleep(delay)
    print(f"Task {name} done after {delay}s")

async def main():
    tasks = [
        task("A", 1),
        task("B", 2),
        task("C", 0.5)
    ]
    await asyncio.gather(*tasks)

asyncio.run(main())

# async def：定义一个协程函数，返回协程对象
# await：暂停协程，等待 asyncio.sleep(1) 完成
# asyncio.gather：并发运行多个协程
# asyncio.run：启动事件循环，运行 main()

## 示例2
import asyncio
import time

# 定义一个异步函数，用于模拟 I/O 操作（如网络请求）
async def fetch_data(task_name, delay):
    print(f"{task_name} 开始执行")
    await asyncio.sleep(delay)  # 模拟 I/O 操作的延迟
    print(f"{task_name} 完成执行，耗时 {delay} 秒")
    return f"{task_name} 的结果"

# 定义主函数，用于调度和运行异步任务
async def main():
    start_time = time.time()

    # 并发执行三个任务
    task1 = asyncio.create_task(fetch_data("任务1", 2))
    task2 = asyncio.create_task(fetch_data("任务2", 3))
    task3 = asyncio.create_task(fetch_data("任务3", 1))

    # 等待所有任务完成并获取结果
    results = await asyncio.gather(task1, task2, task3)

    for result in results:
        print(result)

    print(f"总耗时：{time.time() - start_time:.2f} 秒")

# 运行 asyncio 事件循环
asyncio.run(main())

Output:
任务1 开始执行
任务2 开始执行
任务3 开始执行
任务3 完成执行，耗时 1 秒
任务1 完成执行，耗时 2 秒
任务2 完成执行，耗时 3 秒
任务1 的结果
任务2 的结果
任务3 的结果
总耗时：3.01 秒
```

## function
[Defining Your Own Python Function](https://realpython.com/defining-your-own-python-function/)  

## 配置文件解析
```python
"""
需求场景	            推荐模块
简单键值对配置	        configparser
复杂嵌套结构	        json 或 yaml
现代、简洁、可读性强	 toml
环境变量或敏感信息	     dotenv
命令行与配置结合	    argparse + 其他
"""
# configparser(内置模块)
用途:
     处理类似 .ini 或 .cfg 的配置文件，格式简单，键值对形式
特点:
    支持分节(section)和键值对(key-value)
    适用于简单的配置需求
	简单易用，适合小型项目
	不支持复杂数据结构(如嵌套对象)
# config.ini
[database]
host = localhost
port = 3306

[server]
debug = True

# json(内置模块)
用途:
    处理 JSON 格式的配置文件，广泛用于现代应用
特点:
    支持复杂数据结构(如嵌套字典、列表)
    跨语言兼容性强
	支持复杂结构，易读，广泛支持
	不支持注释(标准 JSON 不支持，但某些库如 commentjson 可解决)
# config.json
{
  "database": {
    "host": "localhost",
    "port": 3306
  },
  "server": {
    "debug": true
  }
}

# yaml(第三方模块)
用途:
    处理 YAML 格式的配置文件，常用于复杂配置(如 Kubernetes)
特点:
    支持复杂数据结构(嵌套、列表等)
    人类可读性强，支持注释
	语法简洁，支持注释，适合复杂配置
	需要额外安装依赖，解析速度稍慢
# config.yaml
database:
  host: localhost
  port: 3306
server:
  debug: true

# toml(第三方模块)(tomllib(Python 3.11+))
用途:
    处理 TOML(Tom's Obvious, Minimal Language)格式，设计为简洁且易读
特点:
    支持嵌套结构和多种数据类型
    比 INI 更现代，比 JSON/YAML 更简单
	简洁直观，支持注释，Python 3.11+ 无需额外依赖
	生态较新，普及度不如 JSON/YAML
# config.toml
[database]
host = "localhost"
port = 3306

[server]
debug = true

# Python 3.11+ 使用内置 tomllib
import tomllib  # 仅支持读取
with open('config.toml', 'rb') as f:  # 注意：需要二进制模式
    config = tomllib.load(f)

# Python 3.10 及以下使用 toml 库
# import toml
# with open('config.toml', 'r') as f:
#     config = toml.load(f)

host = config['database']['host']  # 'localhost'
port = config['database']['port']  # 3306
debug = config['server']['debug']  # True
print(f"Host: {host}, Port: {port}, Debug: {debug}")

# dotenv(第三方模块)
用途:
    处理 .env 文件，常用于环境变量配置
特点:
    专注于键值对，类似 shell 环境变量
    常用于存储敏感信息(如 API 密钥)
    简单，适合环境变量管理
    不支持复杂结构，仅键值对

from dotenv import load_dotenv
import os

load_dotenv()  # 加载 .env 文件到环境变量
host = os.getenv("DB_HOST")  # 'localhost'
port = int(os.getenv("DB_PORT"))  # 3306
debug = os.getenv("DEBUG") == "true"  # True
print(f"Host: {host}, Port: {port}, Debug: {debug}")

# 支持多种格式的配置解析类
import configparser
import json
import yaml
import toml

class ConfigLoader:
    def __init__(self, filepath: str):
        self.filepath = filepath
        self.config = self._load_config()

    def _load_config(self):
        if self.filepath.endswith('.ini'):
            config = configparser.ConfigParser()
            config.read(self.filepath)
            return config
        elif self.filepath.endswith('.json'):
            with open(self.filepath, 'r') as f:
                return json.load(f)
        elif self.filepath.endswith('.yaml'):
            with open(self.filepath, 'r') as f:
                return yaml.safe_load(f)
        elif self.filepath.endswith('.toml'):
            with open(self.filepath, 'r') as f:
                return toml.load(f)
        else:
            raise ValueError("不支持的文件格式")

    def get(self, section: str, key: str = None):
        if isinstance(self.config, configparser.ConfigParser):
            return self.config[section][key] if key else dict(self.config[section])
        else:
            return self.config[section][key] if key else self.config[section]

# 使用
config = ConfigLoader('config.yaml')
host = config.get('database', 'host')  # 'localhost'
print(host)
```
### argparse 模块
[configparser module](https://docs.python.org/3/library/configparser.html)  
[Build Command-Line Interfaces With Python's argparse](https://realpython.com/command-line-interfaces-python-argparse/)  
[argparse](https://docs.python.org/3/library/argparse.html#module-argparse)  
```python
#!/usr/bin/env python3

#cppyocto: a script that tells CMAKE/bitbake to generate a compilation database for a C/C++ project, for use by any language server protocol (LSP) client in your code editor

import os
import os.path as path
import subprocess
import sys
import shutil
import argparse

LAYER_CONF = r"""# vim: filetype=conf
BBPATH =. "${LAYERDIR}:"
BBFILES += "${LAYERDIR}/recipes/*/*.bb \
    ${LAYERDIR}/classes/*/*.bbclass \
    ${LAYERDIR}/appends/*.bbappend"
BBFILE_COLLECTIONS += "compilationdblayer"
BBFILE_PATTERN_compilationdblayer = "^${LAYERDIR}/"
BBFILE_PATTERN_IGNORE_EMPTY_compilationdblayer = "1"
BBFILE_PRIORITY_compilationdblayer = "100"
LAYERSERIES_COMPAT_compilationdblayer = "${LAYERSERIES_COMPAT_core}"
"""

LAYER_COMPDB_CLASS = r"""# vim: filetype=python
# This file is a heavily modified version of this original source:
# "https://github.com/Securepoint/yocto-meta-securepoint/blob/master/
#  meta-securepoint/classes/compilation_db.bbclass"

# use CMAKE to generate a CompilationDB for use any LSP client
#
# Solves the problem of ugly-to-configure local builds by replacing local
# include paths with their actual source location (instead of
# somewhere-in-the-yocto-build folder), while keeping the absolute paths into
# the yocto build to external includes
#
# ## Per recipe configuration (in meta-local/<PN>_%.bbappend):
#
# - add 'inherit compilation_db'
# - add these varibles:
# GEN_COMPILATION_DB_PATH: individual target path for recipe
#   --> (overwrite usage of ${GEN_COMPILATION_DB_PATH_BASE}/${PN})
# GEN_COMPILATION_ADD: a whitespace-separated list of paths; for each entry
#   "cp ${B}/${PN}/${entry} ${GEN_COMPILATION_DB_PATH}/${PN}/${entry}"
#   is executed; used to fix errors of YCM clang completer about missing
#   includes that are generated by cmake during the build process -- those
#   are copied form the 'build' (${B})
#   path of the bitbake build
EXTRA_OECMAKE:append ="  -DCMAKE_EXPORT_COMPILE_COMMANDS=1"

# Get the g++ system include paths
def cpp_build_flags(lxc_root):
    import subprocess

    GCC_START_STR = "#include <...> search starts here:"
    GCC_END_STR = "End of search list."

    # Get the paths to the sys c++ headers that yocto is using
    returned_text = subprocess.getoutput("echo | gcc -xc++ -E -v -")
    start = returned_text.find(GCC_START_STR) + len(GCC_START_STR)
    end = returned_text.find(GCC_END_STR)
    if start == -1 or end == -1:
        return ""

    flags = returned_text[start:end].strip().split('\n')
    ret = ""
    # Combine the paths and prepend with -isystem so they are treated
    # as system headers instead of user defined ones
    for flag in flags:
        ret = ret + " -isystem" + lxc_root + flag.strip()

    return ret

# Correct/Modify the build flags so that:
# - All paths are normalized (change A/B/../C to A/C)
# - Replace yocto source paths with local source path so it points to your files
#   instead of somewhere inside the yocto build directory
# - Make all paths absolute
def build_flags(flags, directory, src, target):
    import os.path
    import re

    new_flags = ""
    make_next_absolute = False
    path_flags = [ '-isystem', '-I', '-iquote', '--sysroot=' ]

    def fix_path(p):
        # Make path absolute
        if not p.startswith('/'):
            p = os.path.join(directory, p)
        # Replace yocto src path with local src path (ignore sysroot pkgs)
        if "recipe-sysroot" not in p:
            p = p.replace(src, target)
        # Normalize path (change A/B/../C to A/C)
        p = os.path.normpath(p)
        return p

    for flag in flags:
        new_flag = flag
        # Handle spaced path flags (ex. "-isystem /home/../")
        if make_next_absolute:
            make_next_absolute = False
            new_flag = fix_path(flag)
        # Handle normal file paths that aren't path flags
        elif os.path.exists(os.path.dirname(new_flag)):
            new_flag = fix_path(new_flag)

        for path_flag in path_flags:
            # Check if the current flag is a path flag
            if flag == path_flag:
                make_next_absolute = True
                break
            # If it starts with a path flag, then extract the path from the string
            if flag.startswith(path_flag):
                new_flag = path_flag + fix_path(flag[ len(path_flag): ])
                break
        # Append the edited flag to the flags string
        if new_flag:
            new_flags = new_flags + " " + new_flag

    return new_flags

# Bitbake task for preparing the compilation database
python do_compilation_db() {
    import os.path
    import json
    import shutil
    import sys

    # Get the expected variables from the bbappend file
    additional_files = d.getVar("GEN_COMPILATION_ADD")
    target = d.getVar('GEN_COMPILATION_DB_PATH')
    if target is None:
        bb.plain("No target directory via GEN_COPMILATION_DB_PATH; aborting...")
        return
    # The path where the lxc appliance is mounted when
    # the container was created (ex: "/ssd/lxc/vcmos-warrior")
    lxc_root = "[{YOCTO_APPLIANCE_ROOT}]"

    cmake_compile_db_file="compile_commands.json"
    # Get the build dir and src dir variables from the recipe ('B' and 'S' variables)
    y_builddir = d.getVar('B', expand=True)
    y_srcdir = d.getVar('S', expand=True)
    y_buildflags = d.getVar('BUILD_CXXFLAGS')
    # Set the path of the generated compile_commands file and the target file name
    y_cc_file = "{0}/{1}".format(y_builddir, cmake_compile_db_file)
    t_cc_file = "{0}/{1}".format(target, cmake_compile_db_file)

    # Open the generated compile_commands file and parse the JSON data
    if os.path.exists(y_cc_file):
        with open(y_cc_file) as json_file:
            data = json.load(json_file)
            # Expected data is of the form:
            # { directory: "...", command: "...", file: "..." } ... {...}
            for p in data:
                data_cc_dir = p['directory']
                data_cc_file = p['file'].replace(y_srcdir, target)
                data_cc_cmd = build_flags(p['command'].split(),
                                          data_cc_dir,
                                          y_srcdir,
                                          target)
                # Replace fields with their corrected values
                p['file'] = data_cc_file
                p['command'] = "{0} {1} {2}".format(data_cc_cmd,
                                                    y_buildflags,
                                                    cpp_build_flags(lxc_root))
        # Output json string to file
        with open(t_cc_file, 'w') as outfile:
            outfile.write(json.dumps(data, indent=2))

    # check if additional (generated headers, e.g.)  for copying are defined
    bb.plain("Additional files to copy: {0}".format(additional_files))
    if additional_files is not None:
        for file in additional_files.split():
            try:
                bb.plain("copy: {0}/{1} to {2}/{1}".format(y_builddir, file, target))
                shutil.copy2("{0}/{1}".format(y_builddir, file), "{0}/{1}".format(target, file))
            except:
                bb.plain("copy failed: {0}".format(sys.exc_info()[0]))

    # Output completion message
    bb.plain("COMPILATION DB GENERATED at: {0}".format(t_cc_file))
}

# Finally add the compilation_db task to run after compilation and before building
addtask compilation_db after do_compile before do_build
"""

def eprint(err):
    print('\x1b[1;31m' + err + '\x1b[0m', file=sys.stderr)

def is_init():
    """ Checks if env has been initialized
    """
    layer_path = path.join(BUILDDIR, "compilation_db")
    if not path.exists(layer_path):
        eprint("Environment has not been initialized!")
        print("Run '<cmd> init --help' to see how")
        return False
    return True

def init_env(lxc_root):
    """ Initialize yocto environment for compilation_db layer
    """
    # Validate lxc root directory
    if not path.exists(lxc_root) or not path.exists(path.join(lxc_root, "usr")):
        eprint("Bad provided build appliance root path '{0}'!".format(lxc_root))
        return False

    # Generate directory structure if it's not setup
    layer_path = path.join(BUILDDIR, "compilation_db")
    layer_appends = path.join(layer_path, "appends")
    layer_conf = path.join(layer_path, "conf")
    layer_classes = path.join(layer_path, "classes")
    bblayers = path.join(BUILDDIR, "conf/bblayers.conf")
    if not path.exists(layer_path):
        os.mkdir(layer_path)
    if not path.exists(layer_appends):
        os.mkdir(layer_appends)
    if not path.exists(layer_classes):
        os.mkdir(path.join(layer_classes))
        with open(path.join(layer_classes, "compilation_db.bbclass"), 'w') as conf:
            conf.write(LAYER_COMPDB_CLASS.replace("[{YOCTO_APPLIANCE_ROOT}]",
                                                  path.normpath(lxc_root)))
    if not path.exists(layer_conf):
        os.mkdir(path.join(layer_conf))
        with open(path.join(layer_conf, "layer.conf"), 'w') as conf:
            conf.write(LAYER_CONF)
    if 0 != subprocess.call(["grep", "-q", "compilation_db", bblayers]):
        with open(bblayers, 'a') as conf:
            conf.write("BBLAYERS += \" {}\"".format(layer_path))

    return True

def clean_env():
    """ Clean the compilation_db layer
    """
    layer_path = path.join(BUILDDIR, "compilation_db")
    bblayers = path.join(BUILDDIR, "conf/bblayers.conf")
    # Remove layer config from bblayers file
    with open(bblayers, 'r') as f:
        lines = f.readlines()
    with open(bblayers, 'w') as f:
        for line in lines:
            if layer_path not in line.strip("\n"):
                f.write(line)
    # Remove layer directory
    if path.exists(layer_path):
        shutil.rmtree(layer_path)
    return True

def main(args):
    """ Main Application
    """
    ret=False
    # Process function options
    if args.function == "init":
        if init_env(args.lxc_root):
            print("Environment initialized!")
            ret=True
    elif args.function == "clean":
        if clean_env():
            print("Environment Cleaned!")
            ret=True
    elif args.function == "add" and is_init():
        print("Adding recipe: {} => {}...".format(args.recipe, args.src))
        if path.exists(args.src):
            append_file = path.join(BUILDDIR,
                                    "compilation_db/appends/{}%.bbappend".format(args.recipe))
            with open(append_file, 'w') as conf:
                conf.write("GEN_COMPILATION_DB_PATH = \"{}\"\n".format(path.abspath(args.src)))
                conf.write("inherit compilation_db")
            print("Successfully added recipe '" + append_file + "'")
            ret=True
        else:
            eprint("Provided source path doesn not exist => ", args.src)
    elif args.function == "delete" and is_init():
        print("Deleting recipe: {}...".format(args.recipe))
        append_file = path.join(BUILDDIR,
                                "compilation_db/appends/{}%.bbappend".format(args.recipe))
        if path.exists(append_file):
            os.remove(append_file)
            print("Successfully removed recipe '" + append_file + "'")
            ret=True
        else:
            eprint("Recipe is not on compdb list (try the --list option to see list of recipes)")
    elif args.function == "list" and is_init():
        print("CompDB Recipes:")
        append_files = os.listdir(path.join(BUILDDIR, "compilation_db/appends"))
        for f in append_files:
            print("- ", f)
        ret=True

    return ret

if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog='cppyocto')
    subparsers = parser.add_subparsers(help='functions', dest='function')

    # Init
    parser_init = subparsers.add_parser('init', help='Init the compdb environment')
    parser_init.add_argument('lxc_root', help='The path to the lxc appliance mounting point')

    # Clean
    parser_clean = subparsers.add_parser('clean', help='Clean the compdb environment')

    # Add
    parser_add = subparsers.add_parser('add', help='Add recipe to compdb list')
    parser_add.add_argument('-s', '--src', help='Path to recipe source [default=current_dir]',
                            default=os.getcwd())
    parser_add.add_argument('recipe', help='Recipe name')

    # delete
    parser_del = subparsers.add_parser('delete', help='Delete recipe from compdb list')
    parser_del.add_argument('recipe', help='Recipe name')

    # List
    parser_del = subparsers.add_parser('list', help='List recipes in compdb list')

    # MAIN
    BUILDDIR = os.getenv("BUILDDIR")
    if BUILDDIR is not None:
        args = parser.parse_args(sys.argv[1:])
        if not main(args):
            exit(1)
    else:
        eprint("Please run this script in a valid/initialized build appliance!")
        eprint("Environment variable 'BUILDDIR' not set")
        exit(1)
```

### configparser 模块
[INI文件格式简介](https://programming-note-sylarliu.readthedocs.io/zh-cn/latest/data_format/INI/ini_brief.html)  
[Python ConfigParser: A Comprehensive Guide](https://medium.com/nerd-for-tech/python-configparser-a-comprehensive-guide-%EF%B8%8F-36331be5244f)  
[Configuring Like a Pro! A Comprehensive Guide to Python’s configparser](https://towardsdev.com/configuring-like-a-pro-a-comprehensive-guide-to-pythons-configparser-26c49b898629)  
```python
# hostConfig.ini:
; section 1
[SFTP_SERVER1]
; name = value
host = 10.120.98.12
port = 22
username = tester
password = password

; section 2
[SFTP_SERVER2]
host = 10.120.98.12
port = 23
username = tester
password = password

# hostParser.py
import configparser

class HostConfig:
    def __init__(self, configFile):
        self.configFile= configFile
        self.config= configparser.ConfigParser()
        
    def readConfig(self):
        # Reading the config file
        self.config.read(self.configFile)
    
    def getServers(self):
        # Returning all the sections defined in the config file
        return self.config.sections()
    
    def getData(self, host, key):
        # Getting the values from the particular section (host) 
        # by using the key       
        return self.config[host][key]
    
    def getHostDetails(self, host):
        # Getting all the values defined under the given section (host).
        # Assuming the keys are known and fixed.
        hostdata= self.config[host]
        return hostdata['host'],hostdata['port'],hostdata['username'],hostdata['password']

hostConfig= HostConfig('tempConfig.ini')  # creating object of HostConfig
hostConfig.readConfig()                   # Reading config file 

Servers= hostConfig.getServers()       # Getting the list of sections (servers)
print("Servers: ",Servers)

print("Server 0 data: \n",hostConfig.getHostDetails(Servers[0]))  # Getting items for Section No 0

print("Server1: Host ",hostConfig.getData(Servers[1], 'host'))  # Getting item for Section No 1
print("Server1: Port ",hostConfig.getData(Servers[1], 'port'))  # Getting item for Section No 1
```

## python 2 c converter
[Online Python to C Converter](https://www.codeconvert.ai/python-to-c-converter)  



## 类型提示
[typing — Support for type hints](https://docs.python.org/3/library/typing.html)  
[How to Use Type Hints for Multiple Return Types in Python](https://realpython.com/python-type-hints-multiple-types/)  

## Python for Network Automation
[Python for Network Automation](https://python-automation-book.readthedocs.io/en/stable/index.html)  

## modules
[Python Module of the Week](https://pymotw.com/2/contents.html)  
[Python Module Index](https://docs.python.org/3/py-modindex.html)  
[NCS Python API](https://developer.cisco.com/docs/nso/api/ncs/#package-ncs)  

## subprocess 模块
[The subprocess Module: Wrapping Programs With Python](https://realpython.com/python-subprocess/)  


## 执行 shell 命令
```python
import subprocess

class ShellCmdClient:
    def run_cmd(self, cmd: str) -> str:
        """执行 shell 命令并返回输出"""
        try:
            result = subprocess.run(cmd.split(), check=True, capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout
            else:
                return result.stderr
        except subprocess.CalledProcessError as e:
            return f"Command \"{cmd}\" failed with error: {e.stderr}"
        except Exception as e:
            return f"Unexpected error: {e}"

if __name__ == "__main__":
    try:
        shell = ShellCmdClient()
        output = shell.run_cmd("ls -l")
        print(f"Command output:\n{output}")
    except Exception as e:
        print(f"Unexpected error: {e}")
```

```python

# Type aliases(类型别名) are useful for simplifying complex type signatures. For example:
from collections.abc import Sequence

type ConnectionOptions = dict[str, str]
type Address = tuple[str, int]
type Server = tuple[Address, ConnectionOptions]

def broadcast_message(message: str, servers: Sequence[Server]) -> None:
	...

# The static type checker will treat the previous type signature as
# being exactly equivalent to this one.
def broadcast_message(
		message: str,
		servers: Sequence[tuple[tuple[str, int], dict[str, str]]]) -> None:
```
- [Python Tips](https://book.pythontips.com/en/latest/index.html#) #online
- [Python: Context Manager to Simplify Resource Handling](https://pravash-techie.medium.com/python-context-manager-to-simplify-resource-handling-5959a36a0f58)
- [contextlib   — Utilities for with -statement contexts](https://docs.python.org/3/library/contextlib.html)
- 常用环境变量
	- [PYTHONPATH](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH)
	- [Using PYTHONPATH](https://bic-berkeley.github.io/psych-214-fall-2016/using_pythonpath.html)
	- [Python import, sys.path, and PYTHONPATH Tutorial](https://www.devdungeon.com/content/python-import-syspath-and-pythonpath-tutorial)

- 自定义模块
		- 新建模块目录例如`modules`，在目录下新建多个python文件(例如 geometry.py, math.py)分别实现对应的模块功能
		- 使用时需要将模块目录路径加入到系统的path环境变量
			- ```python
			  import sys
			  sys.path.append("modules")
			  
			  import geometry
			  distance = geometry.distance(1, 1, 5, 5)
			  ```
	- [[pexpect]]
		- [man pexpect](https://pexpect.sourceforge.net/pexpect.html)
		- [man pxssh](https://pexpect.sourceforge.net/pxssh.html)
		- pexpect实现ssh自动登陆
			- ```python
			  #!/usr/bin/python
			  
			  import pexpect
			  
			  class SSHClient:
			          def __init__(self, user, host, pwd):
			                  self.user = user
			                  self.host = host
			                  self.pwd = pwd
			                  self.ssh = None
			          def send_command(self, cmd):
			                  self.ssh.sendline(cmd)
			                  #self.ssh.buffer="" // otherwise it will cause "TypeError: can't concat str to bytes"
			                  self.ssh.expect('support@', timeout=10)
			                  return self.ssh.after + self.ssh.before
			          def close(self):
			                  self.ssh.close()
			          def connect(self):
			                  ssh_newkey = "Are you sure you want to continue connecting"
			                  constr = "ssh " + "-p5617 " + self.user + "@" + self.host
			                  self.ssh = pexpect.spawn(constr, encoding='utf-8')
			                  ret = self.ssh.expect([pexpect.TIMEOUT, ssh_newkey, '[P|p]assword:'])
			                  if ret == 0:
			                          return False, '[%s@%s] Error Connecting' % (self.user, self.host)
			                  if ret == 1:
			                          self.ssh.sendline("yes")
			                          ret = self.ssh.expect([pexpect.TIMEOUT, ssh_newkey, '[P|p]assword:'])
			                          if ret == 0:
			                                  return False, '[%s@%s] Error Connecting' % (self.user, self.host)
			                  self.ssh.sendline(self.pwd)
			                  self.ssh.expect('gs_cli')
			                  self.ssh.sendline('diag-shell\r')
			                  self.ssh.expect('support')
			                  return True, '[%s@%s] Success Connecting' % (self.user, self.host)
			  
			  if __name__ == "__main__":
			          ssh = SSHClient(user="support", host="169.254.32.200", pwd="Gainsp33")
			          ret, msg = ssh.connect()
			          if not ret:
			                  print(msg)
			                  exit(0)
			  
			          cmd = 'ls /tmp'
			          result = ssh.send_command(cmd)
			          print(result)
			  
			          cmd = 'df -h'
			          result = ssh.send_command(cmd)
			          print(result)
			          ssh.close()
			  
			  ```
	- [[str]]
	- [[list]]
	- [[python file]]
	- [[dictionary]]
	- os
		- [Miscellaneous operating system interfaces](https://docs.python.org/3/library/os.html)
		- `os.path`
			- [Common pathname manipulations](https://docs.python.org/3/library/os.path.html#module-os.path)
	- [[re]]
		- [Regular expression operations](https://docs.python.org/3/library/re.html?highlight=re#module-re)
	- glob
		- [Unix style pathname pattern expansion](https://docs.python.org/3/library/glob.html?highlight=glob#module-glob)
	- subprocess
		- [Subprocess management](https://docs.python.org/3/library/subprocess.html)
	- sys
		- [System-specific parameters and functions](https://docs.python.org/3/library/sys.html)
	- datetime
		- [Basic date and time types](https://docs.python.org/3/library/datetime.html)
	- time
		- [Time access and conversions](https://docs.python.org/3/library/time.html)
	- logging
		- [Logging facility for Python](https://docs.python.org/3/library/logging.html?highlight=logging#module-logging)
	- logging.handlers
		- [logging.handlers](https://docs.python.org/3/library/logging.handlers.html?highlight=logging%20handlers#module-logging.handlers)
	- platform
		- [Access to underlying platform ’s identifying data](https://docs.python.org/3/library/platform.html?highlight=platform#module-platform)
	- telnetlib
		- [Telnet client](https://docs.python.org/3/library/telnetlib.html?highlight=telnetlib#module-telnetlib)
	- getpass
		- [Portable password input](https://docs.python.org/3/library/getpass.html)
	- shutil
		- [High-level file operations](https://docs.python.org/3.8/library/shutil.html)
- package
	- 用来整理和分类模块
	- 文件夹结构
		- ```
		  - 项目文件夹
		  	- 主程序.py
		      - 封包文件夹
		      	- __init__.py
		          - 模块1.py
		          - 模块2.py
		  
		  # 例如
		  - python_learn
		  	- main.py
		      - geometry
		      	- __init__.py
		          - point.py
		          - line.py
		  
		  import geometry.point
		  distance = geometry.point.distance(3, 4)
		  
		  import geomegry.point as point
		  distance = point.distance(3, 4)
		  ```
	- 使用封包
		- `import 封包名称.模组名称`
		- `import 封包名称.模组名称 as 模组别名`

- contextlib
	```python
	# context manager: 在一个类里，实现了__enter__和__exit__的方法，这个类的实例就是一个上下文管理器
	class Resource():
		def __enter__(self):
			print('===connect to resource===')
			return self
		def __exit__(self, exc_type, exc_val, exc_tb):
			print('===close resource connection===')

		def operate(self):
			print('===in operation===')

	with Resource() as res:
		res.operate()

	# 使用 contextlib 简化上下文管理器的实现
	import contextlib

	@contextlib.contextmanager
	def operate():
		print("__enter__")
		yield "yielded value"
		print("__exit__")

	with operate() as o:
		print(o)

	# 为什么需要context manager
		# 1.可以以一种更加优雅的方式，操作（创建/获取/释放）资源，如文件操作、数据库连接；
		# 2.可以以一种更加优雅的方式，处理异常
	class Resource():
		def __enter__(self):
			print('===connect to resource===')
			return self

		def __exit__(self, exc_type, exc_val, exc_tb):
			print('===close resource connection===')
			return True	# 在__exit__ 里返回 True 相当于告诉 Python解释器，这个异常我们已经捕获了，不需要再往外抛了

		def operate(self):
			1/0

	with Resource() as res:
		res.operate()


	写__exit__ 函数时，需要注意的事，它必须要有这三个参数：
	exc_type：异常类型
	exc_val：异常值
	exc_tb：异常的错误栈信息
	当主逻辑代码没有报异常时，这三个参数将都为None

	# contextlib是一个装饰器，你只要按照它的代码协议来实现函数内容，就可以将这个函数对象变成一个上下文管理器
	import contextlib

	@contextlib.contextmanager
	def open_func(file_name):
		# __enter__方法
		print('open file:', file_name, 'in __enter__')
		file_handler = open(file_name, 'r')

		# 【重点】：yield
		yield file_handler

		# __exit__方法
		print('close file:', file_name, 'in __exit__')
		file_handler.close()
		return

	with open_func('/Users/MING/mytest.txt') as file_in:
		for line in file_in:
			print(line)
	# 被装饰函数里，必须是一个生成器（带有yield）
		#1 yield之前的代码，就相当于__enter__里的内容
		#2 yield 之后的代码，就相当于__exit__ 里的内容

	# 处理异常
	import contextlib

	@contextlib.contextmanager
	def open_func(file_name):
		# __enter__方法
		print('open file:', file_name, 'in __enter__')
		file_handler = open(file_name, 'r')

		try:
			yield file_handler
		except Exception as exc:
			# deal with exception
			print('the exception was thrown')
		finally:
			print('close file:', file_name, 'in __exit__')
			file_handler.close()

			return

	with open_func('/Users/MING/mytest.txt') as file_in:
		for line in file_in:
			1/0
			print(line)

	// 示例
	@contextlib.contextmanager
	def tempdir(**kwargs):
		argdict = kwargs.copy()
		if 'dir' not in argdict:
			argdict['dir'] = CONF.tempdir
		tmpdir = tempfile.mkdtemp(**argdict)
		try:
			yield tmpdir
		finally:
			try:
				shutil.rmtree(tmpdir)
			except OSError as e:
				LOG.error(LE('Cound not remove tmpdir: %s'), e)


	使用上下文管理器有三个好处：
	1.提高代码的复用率；
	2.提高代码的优雅度；
	3.提高代码的可读性；
	```

[www.python.org](https://www.python.org/)  
[Python 标准库](https://docs.python.org/zh-cn/3/library/)  
[**The Python Standard Library**](https://docs.python.org/3/library/)  
[**Python黑魔法手册**](https://magic.iswbm.com/index.html)  
[**Python 3 Trinkets(python3 online)**](https://trinket.io/features/python3)  
[The Big Book of Small Python Projects](https://inventwithpython.com/bigbookpython/) #online  
[How to Use the Unpacking Operators (*, **) in Python?](https://geekflare.com/python-unpacking-operators/)  
[Python Code Examples](https://www.programcreek.com/python/)  
[**20-python-libraries-you-arent-using-but-should.pdf**](https://github.com/ffisk/books/blob/master/20-python-libraries-you-arent-using-but-should.pdf)  
[Python 3 Cheat Sheet](https://perso.limsi.fr/pointal/_media/python:cours:mementopython3-english.pdf)  
[pythoncheatsheet](https://www.pythoncheatsheet.org/) #online  
[The Hitchhiker’s Guide to Python!](https://docs.python-guide.org/)  
[Python 101](https://www.python101.pythonlibrary.org/index.html#) #online  
[python101code](https://github.com/driscollis/python101code) #github  
[python201bookcode](https://github.com/driscollis/python201bookcode) #github  
[wxpythoncookbookcode](https://github.com/driscollis/wxpythoncookbookcode) #github  
[Automate the Boring Stuff with Python](https://automatetheboringstuff.com/)  
[阿尔法的Python笔记](https://segmentfault.com/blog/alpha94511)  
[python3 cookbook](https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html)  
[Python Documentation contents](https://docs.python.org/3/contents.html)  
[Python for network engineers](https://pyneng.readthedocs.io/en/latest/index.html)  
[Python Tricks: The Book](http://www.kalfaoglu.com/ceng113/Python-Programming/pythontricks.pdf)  
[Programming in Python 3](https://cs.smu.ca/~porter/csc/227/ProgrammingInPython3.pdf)  
[Elements of Programming Interviews in Python](https://elementsofprogramminginterviews.com/sample/epilight_python_new.pdf)  
[Elements of Programming Interviews in Python](https://github.com/qqqil/ebooks/blob/master/algorithms/Elements%20of%20Programming%20Interviews.pdf)  
[PYTHON CRASH COURSE](https://bedford-computing.co.uk/learning/wp-content/uploads/2015/10/No.Starch.Python.Oct_.2015.ISBN_.1593276036.pdf)  
[The Big Book of Small Python Projects](https://inventwithpython.com/bigbookpython/) #online  
[Logging HOWTO](https://docs.python.org/3/howto/logging.html)  
[Awesome_Python_Scripts](https://prathimacode-hub.github.io/Awesome_Python_Scripts/) #github  
[Simple Way of Python's subprocess.Popen with a Timeout Option](https://www.gungorbudak.com/blog/2015/08/30/simple-way-of-pythons-subprocesspopen/)  
[Python 101: How to timeout a subprocess](https://www.blog.pythonlibrary.org/2016/05/17/python-101-how-to-timeout-a-subprocess/)  
[Python 101: How to Timeout a Subprocess](https://dzone.com/articles/python-101-how-to-timeout-a-subprocess)  
[Understanding Python re(gex)?](https://learnbyexample.github.io/py_regular_expressions/cover.html)  
[python projects](https://bedford-computing.co.uk/learning/wp-content/uploads/2015/10/Python-Projects.pdf)  
[The big book of small python projects](https://edu.anarcho-copy.org/Programming%20Languages/Python/BigBookSmallPythonProjects.pdf)  
[learning Python](https://cfm.ehu.es/ricardo/docs/python/Learning_Python.pdf)  
[practice_python_projects](https://github.com/learnbyexample/practice_python_projects)  
[Implementing Threads for Measurements](https://pythonforthelab.com/blog/implementing-threads-for-measurements/)  
[Storing Binary Data and Serializing](https://pythonforthelab.com/blog/storing-binary-data-and-serializing/)  
[What are Hashable Objects](https://pythonforthelab.com/blog/what-are-hashable-objects/)  
[PEP](https://peps.python.org/)  
[Python's filter(): Extract Values From Iterables](https://realpython.com/python-filter-function/)  
[Iterators and Iterables in Python: Run Efficient Iterations](https://realpython.com/python-iterators-iterables/)  
[argparse](https://docs.python.org/3/library/argparse.html)  
[Build Command-Line Interfaces With Python's argparse](https://realpython.com/command-line-interfaces-python-argparse/)  
```python
# argparse
# 1 最简单的 argparse 的例子
$ cat t1.py
import argparse

parser = argparse.ArgumentParser()

$ python t1.py
$ python t1.py --help
usage: t1.py [-h]

optional arguments:
-h, --help  show this help message and exit
$ python t1.py --verbose
usage: t1.py [-h]
t1.py: error: unrecognized arguments: --verbose
$ python t1.py xxx
usage: t1.py [-h]
t1.py: error: unrecognized arguments: xxx
# 没有任何选项的情况下运行脚本不会在标准输出显示任何内容
# --help 选项，也可缩写为 -h，是唯一一个可以直接使用的选项（即不需要指定该选项的内容）。指定任何内容都会导致错误

# 2 位置参数
cat t1.py
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("echo", help="echo the string you use here")
args = parser.parse_args()
print(args.echo)

$ python3 t1.py
usage: t1.py [-h] echo
t1.py: error: the following arguments are required: echo
$ python3 t1.py echo
echo
$ python3 t1.py echo1
echo1

# 3 argparse 会把我们传递给它的选项视作为字符串，除非我们告诉它别这样
cat t1.py
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("square", help="display a square of a given number", type=int)
args = parser.parse_args()
print(args.square ** 2)

$ python3 t1.py 4
16

# 可选参数
cat t1.py
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--verbose", help="increase output verbosity",
					action="store_true")	# action 赋值为 "store_true"，意味着，如果指定了该选项，则将值 True 赋给 args.verbose
args = parser.parse_args()
if args.verbose:
	print("verbosity turned on")

$ python3 t1.py
$ python3 t1.py  --verbose
verbosity turned on

# 短选项
parser.add_argument("-v", "--verbose", help="increase output verbosity",
					action="store_true")	# 添加 "-v"，用来支持短选项

# 结合位置参数和可选参数
cat t1.py
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("square", type=int, help="display a square of a given number")
parser.add_argument("-v", "--verbose", help="increase output verbosity", action="store_true")
args = parser.parse_args()
answer = args.square ** 2
if args.verbose:
	print(f"the square of {args.square} equals {answer}")
else:
	print(answer)

$ python3 t1.py  4
16
$ python3 t1.py  4 --verbose
the square of 4 equals 16
$ python3 t1.py  --verbose 4
the square of 4 equals 16

# 改进 1, 给程序加上接受多个冗长度的值
parser.add_argument("-v", "--verbose", type=int, help="increase output verbosity")

if args.verbose == 2:
	print(f"the square of {args.square} equals {answer}")
elif args.verbose == 1:
	print(f"{args.square}^2 == {answer}")
else:
	print(answer)

$ python3 t1.py  4
16
$ python3 t1.py  4 -v
usage: t1.py [-h] [-v VERBOSE] square
t1.py: error: argument -v/--verbose: expected one argument
$ python3 t1.py  4 -v 1
4^2 == 16
$ python3 t1.py  4 -v 2
the square of 4 equals 16
$ python3 t1.py  4 -v 3		# not as expected
16

# 改进 2， 限制 --verbosity 选项可以接受的值
parser.add_argument("-v", "--verbose", type=int, choices=[0, 1, 2],
					help="increase output verbosity")

$ python3 t1.py  4 -v 3
usage: t1.py [-h] [-v {0,1,2}] square
t1.py: error: argument -v/--verbose: invalid choice: 3 (choose from 0, 1, 2)

# 改进 3，改变冗长度
parser.add_argument("-v", "--verbose", action="count",		# "count" action 用来统计特定选项出现的次数
					help="increase output verbosity")

$ python3 t1.py  4 -v
4^2 == 16
$ python3 t1.py  4 -vv
the square of 4 equals 16
$ python3 t1.py  4 -vvv		# not as expected
16

# 改进 4
if args.verbose >= 2:		# == 改为 >=
	print(f"the square of {args.square} equals {answer}")
elif args.verbose == 1:
	print(f"{args.square}^2 == {answer}")
else:
	print(answer)

$ python3 t1.py  4 -vvv
the square of 4 equals 16
$ python3 t1.py  4
Traceback (most recent call last):
File "t1.py", line 10, in <module>
	if args.verbose >= 2:
TypeError: '>=' not supported between instances of 'NoneType' and 'int' # 默认情况下如果一个可选参数没有被指定，它的值会是 None，不能和整数值相比较

# 改进 5
parser.add_argument("-v", "--verbose", action="count", default=0,		# 关键字 default 设置为 0 来让它可以与其他整数值进行比较
					help="increase output verbosity")

# 扩展执行其他幂次的运算
cat t1.py
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("x", type=int, help="the base")
parser.add_argument("y", type=int, help="the exponent")
parser.add_argument("-v", "--verbosity", action="count", default=0)
args = parser.parse_args()
answer = args.x**args.y
if args.verbosity >= 2:
	print(f"{args.x} to the power {args.y} equals {answer}")
elif args.verbosity >= 1:
	print(f"{args.x}^{args.y} == {answer}")
else:
	print(answer)

$ python3 t1.py  4 2
16
$ python3 t1.py  4 2 -v
4^2 == 16
$ python3 t1.py  4 2 -vv
4 to the power 2 equals 16

# 使用详细级别来显示 更多的 文本
if args.verbosity >= 2:
	print(f"Running '{__file__}'")
if args.verbosity >= 1:
	print(f"{args.x}^{args.y} == ", end="")
print(answer)

$ python3 t1.py  4 2
16
$ python3 t1.py  4 2 -v
4^2 == 16
$ python3 t1.py  4 2 -vv
Running 't1.py'
4^2 == 16

# 处理 矛盾的选项 (--quiet 选项 与 --verbose 的作用相反)
import argparse

parser = argparse.ArgumentParser()
group = parser.add_mutually_exclusive_group()
group.add_argument("-v", "--verbose", action="store_true")
group.add_argument("-q", "--quiet", action="store_true")
parser.add_argument("x", type=int, help="the base")
parser.add_argument("y", type=int, help="the exponent")
args = parser.parse_args()
answer = args.x**args.y

if args.quiet:
	print(answer)
elif args.verbose:
	print(f"{args.x} to the power {args.y} equals {answer}")
else:
	print(f"{args.x}^{args.y} == {answer}")

$ python3 t1.py  4 2
4^2 == 16
$ python3 t1.py  4 2 -q
16
$ python3 t1.py  4 2 -v
4 to the power 2 equals 16
$ python3 t1.py  4 2 -vq
usage: t1.py [-h] [-v | -q] x y
t1.py: error: argument -q/--quiet: not allowed with argument -v/--verbose
$ python3 t1.py  4 2 -v --quiet
usage: t1.py [-h] [-v | -q] x y
t1.py: error: argument -q/--quiet: not allowed with argument -v/--verbose

# 描述程序的主要目标
parser = argparse.ArgumentParser(description="calculate X to the power of Y")

# 示例 2
Four straightforward steps to use Python’s argparse:
1. Import the argparse module.
2. Create an argument parser by instantiating ArgumentParser.
3. Add arguments and options to the parser using the .add_argument() method.
4. Call .parse_args() on the parser to get the Namespace of arguments.


Two types of command-line arguments:
1. Positional arguments, which you know as arguments
2. Optional arguments, which you know as options, flags, or switches.(Optional arguments aren’t mandatory. They allow you to modify the behavior of the command)

The first argument to the .add_argument() method sets the difference between arguments and options. This argument is identified as either name or flag. 
if you provide a name, then you’ll be defining an argument.
if you use a flag, then you’ll add an option.

import argparse
import datetime
from pathlib import Path

parser = argparse.ArgumentParser()

parser.add_argument("path")

parser.add_argument("-l", "--long", action="store_true")

args = parser.parse_args()

target_dir = Path(args.path)

if not target_dir.exists():
    print("The target directory doesn't exist")
    raise SystemExit(1)

def build_output(entry, long=False):
    if long:
        size = entry.stat().st_size
        date = datetime.datetime.fromtimestamp(
            entry.stat().st_mtime).strftime(
            "%b %d %H:%M:%S"
        )
        return f"{size:>6d} {date} {entry.name}"
    return entry.name

for entry in target_dir.iterdir():
    print(build_output(entry, long=args.long))
```

## re module
```python
  # Searching Functions
  re.search()    	Scans a string for a regex match
  re.match()	    Looks for a regex match at the beginning of a string
  re.fullmatch()	Looks for a regex match on an entire string
  re.findall()	Returns a list of all regex matches in a string
  re.finditer()	Returns an iterator that yields regex matches from a string
  
  >>> re.search(r'[a-z]+', '123FOO456', flags=re.IGNORECASE)
  <_sre.SRE_Match object; span=(3, 6), match='FOO'>
  
  >>> re.match(r'\d+', '123foobar')
  <_sre.SRE_Match object; span=(0, 3), match='123'>
  
  >>> re.fullmatch(r'\d+', '123')
  <_sre.SRE_Match object; span=(0, 3), match='123'>
  
  >>> re.findall(r'\w+', '...foo,,,,bar:%$baz//|')
  ['foo', 'bar', 'baz']
  >>> re.findall(r'(\w+),(\w+)', 'foo,bar,baz,qux,quux,corge')
  [('foo', 'bar'), ('baz', 'qux'), ('quux', 'corge')]
  >>> re.findall(r'(\w+),(\w+),(\w+)', 'foo,bar,baz,qux,quux,corge')
  [('foo', 'bar', 'baz'), ('qux', 'quux', 'corge')]
  
  >>> for i in re.finditer(r'\w+', '...foo,,,,bar:%$baz//|'):
  ...     print(i)
  ...
  <_sre.SRE_Match object; span=(3, 6), match='foo'>
  <_sre.SRE_Match object; span=(10, 13), match='bar'>
  <_sre.SRE_Match object; span=(16, 19), match='baz'>
  
  
  # Substitution Functions
  (If re.sub() doesn’t find any matches, then it always returns <string> unchanged.)
  re.sub()	Scans a string for regex matches, replaces the matching portions of the string with 
  			the specified replacement string, and returns the result
  re.subn()	Behaves just like re.sub() but also returns information regarding the number of 
  			substitutions made
  
  >>> s = 'foo.123.bar.789.baz'
  >>> re.sub(r'\d+', '#', s)
  'foo.#.bar.#.baz'
  >>> re.sub('[a-z]+', '(*)', s)
  '(*).123.(*).789.(*)'
  
  >>> re.sub(r'(\w+),bar,baz,(\w+)',
  ...        r'\2,bar,baz,\1',
  ...        'foo,bar,baz,qux')
  'qux,bar,baz,foo'
  
  >>> re.sub(r'(\d+)', r'\g<1>0', 'foo 123 bar')
  'foo 1230 bar'
  (\g<1> to refer to the group)
  
  >>> re.sub(r'\d+', '/\g<0>/', 'foo 123 bar')
  'foo /123/ bar'
  (The backreference \g<0> refers to the text of the entire match)
  
  >>> re.sub('x*', '-', 'foo')
  '-f-o-o-'
  (If <regex> specifies a zero-length match, then re.sub() will substitute <repl> into every 
   character position in the string)
  
  
  # Substitution by Function
  >>> def f(match_obj):
  ...     s = match_obj.group(0)  # The matching string
  ...
  ...     # s.isdigit() returns True if all characters in s are digits
  ...     if s.isdigit():
  ...         return str(int(s) * 10)
  ...     else:
  ...         return s.upper()
  ...
  >>> re.sub(r'\w+', f, 'foo.10.bar.20.baz.30')
  'FOO.100.BAR.200.BAZ.300'
  
  
  # Utility Functions
  re.split()	Splits a string into substrings using a regex as a delimiter
  re.escape()	Escapes characters in a regex
  
  >>> re.split('\s*[,;/]\s*', 'foo,bar  ;  baz / qux')
  ['foo', 'bar', 'baz', 'qux']
  >>> re.split('(\s*[,;/]\s*)', 'foo,bar  ;  baz / qux')
  ['foo', ',', 'bar', '  ;  ', 'baz', ' / ', 'qux']
  
  This can be useful if you want to split <string> apart into delimited tokens, process the tokens 
  in some way, then piece the string back together using the same delimiters that originally 
  separated them:
  >>> string = 'foo,bar  ;  baz / qux'
  >>> regex = r'(\s*[,;/]\s*)'
  >>> a = re.split(regex, string)
  
  >>> # List of tokens and delimiters
  >>> a
  ['foo', ',', 'bar', '  ;  ', 'baz', ' / ', 'qux']
  
  >>> # Enclose each token in <>'s
  >>> for i, s in enumerate(a):
  ...
  ...     # This will be True for the tokens but not the delimiters
  ...     if not re.fullmatch(regex, s):
  ...         a[i] = f'<{s}>'
  ...
  
  >>> # Put the tokens back together using the same delimiters
  >>> ''.join(a)
  '<foo>,<bar>  ;  <baz> / <qux>'
  
  If you need to use groups but don’t want the delimiters included in the return list, then you 
  can use noncapturing groups:
  >>> string = 'foo,bar  ;  baz / qux'
  >>> regex = r'(?:\s*[,;/]\s*)'
  >>> re.split(regex, string)
  ['foo', 'bar', 'baz', 'qux']
  
  If the optional maxsplit argument is present and greater than zero, then re.split() performs at 
  most that many splits.
  >>> s = 'foo, bar, baz, qux, quux, corge'
  
  >>> re.split(r',\s*', s)
  ['foo', 'bar', 'baz', 'qux', 'quux', 'corge']
  >>> re.split(r',\s*', s, maxsplit=3)
  ['foo', 'bar', 'baz', 'qux, quux, corge']
  
  
  This is useful if you’re calling one of the re module functions, and the <regex> you’re passing 
  in has a lot of special characters that you want the parser to take literally instead of as 
  metacharacters.
  >>> print(re.match('foo^bar(baz)|qux', 'foo^bar(baz)|qux'))
  None
  >>> re.match('foo\^bar\(baz\)\|qux', 'foo^bar(baz)|qux')
  <_sre.SRE_Match object; span=(0, 16), match='foo^bar(baz)|qux'>
  
  >>> re.escape('foo^bar(baz)|qux') == 'foo\^bar\(baz\)\|qux'
  True
  >>> re.match(re.escape('foo^bar(baz)|qux'), 'foo^bar(baz)|qux')
  <_sre.SRE_Match object; span=(0, 16), match='foo^bar(baz)|qux'>
  
  
  # Compiled Regex Objects in Python
  >>> re.search(r'(\d+)', 'foo123bar')
  <_sre.SRE_Match object; span=(3, 6), match='123'>
  
  >>> re_obj = re.compile(r'(\d+)')
  >>> re.search(re_obj, 'foo123bar')
  <_sre.SRE_Match object; span=(3, 6), match='123'>
  >>> re_obj.search('foo123bar')
  <_sre.SRE_Match object; span=(3, 6), match='123'>
  
  If you use a particular regex in your Python code frequently, then precompiling allows you to 
  separate out the regex definition from its uses. This enhances modularity.
  >>> s1, s2, s3, s4 = 'foo.bar', 'foo123bar', 'baz99', 'qux & grault'
  >>> re_obj = re.compile('\d+')
  
  >>> re_obj.search(s1)
  >>> re_obj.search(s2)
  <_sre.SRE_Match object; span=(3, 6), match='123'>
  >>> re_obj.search(s3)
  <_sre.SRE_Match object; span=(3, 5), match='99'>
  >>> re_obj.search(s4)
  
  
  # Match Object Methods
  match.group()		The specified captured group or groups from match
  match.__getitem__()	A captured group from match
  match.groups()		All the captured groups from match
  match.groupdict()	A dictionary of named captured groups from match
  match.expand()		The result of performing backreference substitutions from match
  match.start()		The starting index of match
  match.end()		The ending index of match
  match.span()		Both the starting and ending indices of match as a tuple
  # Match Object Attributes
  match.pos
  match.endpos	The effective values of the <pos> and <endpos> arguments for the match
  match.lastindex	The index of the last captured group
  match.lastgroup	The name of the last captured group
  match.re	The compiled regular expression object for the match
  match.string	The search string for the match
```
[Regular Expressions: Regexes in Python (Part 1)](https://realpython.com/regex-python/)  
[Regular Expressions: Regexes in Python (Part 2)](https://realpython.com/regex-python-part-2/)  