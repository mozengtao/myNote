[RefactoringGuru](https://github.com/RefactoringGuru)  
[Refactoring: Improving the Design of Existing Code]()  


[Design Patterns for Dummies](https://github.com/hraverkar/books)  
[Dive-Into-Design-Patterns---Code-Samples](https://github.com/arvi9/Dive-Into-Design-Patterns---Code-Samples/tree/master)  
[Design Patterns Explained simply](https://github.com/hraverkar/books/tree/master)  
[]()  

![Java Design Patterns: A tutorial](./design_patterns/Java_Design_Patterns-A_tutorial.pdf)  
![Java Design Patterns](./design_patterns/Java-Design-Patterns.pdf)  
![Holub on Patterns](./design_patterns/Holub_on_Patterns.pdf)  



[**Game Programming Patterns**](https://gameprogrammingpatterns.com/contents.html)  
[**The Catalog of Design Patterns**](https://refactoring.guru/design-patterns/catalog)  
[**Java Design Patterns**](https://java-design-patterns.com/patterns/)  
[14 Patterns to Ace Any Coding Interview Question](https://hackernoon.com/14-patterns-to-ace-any-coding-interview-question-c5bb3357f6ed)  
[Design Patterns](https://sourcemaking.com/design_patterns)  
[**Design Pattern Online Training using .NET**](https://dotnettutorials.net/lesson/design-patterns-online-training/)  
[Books](https://github.com/gmoral/Books)  
[]()  
[]()  
[]()  
[]()  
[]()  
[Dive into Systems](https://diveintosystems.org/)  
[]()  
[]()  
[]()  

## chain-of-responsibility-guide
├── [00-index.md](./design_patterns/chain-of-responsibility-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/chain-of-responsibility-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/chain-of-responsibility-guide/02-identification-rules.md)
├── [03-netfilter-case.md](./design_patterns/chain-of-responsibility-guide/03-netfilter-case.md)
├── [04-irq-case.md](./design_patterns/chain-of-responsibility-guide/04-irq-case.md)
├── [05-unified-skeleton.md](./design_patterns/chain-of-responsibility-guide/05-unified-skeleton.md)
├── [06-vs-observer.md](./design_patterns/chain-of-responsibility-guide/06-vs-observer.md)
├── [07-antipatterns.md](./design_patterns/chain-of-responsibility-guide/07-antipatterns.md)
├── [08-reading-guide.md](./design_patterns/chain-of-responsibility-guide/08-reading-guide.md)
    └── [09-mental-model.md](./design_patterns/chain-of-responsibility-guide/09-mental-model.md)

## command-deferred-guide
├── [00-index.md](./design_patterns/command-deferred-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/command-deferred-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/command-deferred-guide/02-identification-rules.md)
├── [03-workqueue-case.md](./design_patterns/command-deferred-guide/03-workqueue-case.md)
├── [04-tasklet-case.md](./design_patterns/command-deferred-guide/04-tasklet-case.md)
├── [05-softirq-case.md](./design_patterns/command-deferred-guide/05-softirq-case.md)
├── [06-unified-skeleton.md](./design_patterns/command-deferred-guide/06-unified-skeleton.md)
├── [07-vs-direct.md](./design_patterns/command-deferred-guide/07-vs-direct.md)
├── [08-antipatterns.md](./design_patterns/command-deferred-guide/08-antipatterns.md)
├── [09-reading-guide.md](./design_patterns/command-deferred-guide/09-reading-guide.md)
    └── [10-mental-model.md](./design_patterns/command-deferred-guide/10-mental-model.md)

## composite-hierarchy-guide
├── [00-index.md](./design_patterns/composite-hierarchy-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/composite-hierarchy-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/composite-hierarchy-guide/02-identification-rules.md)
├── [03-kobject-case.md](./design_patterns/composite-hierarchy-guide/03-kobject-case.md)
├── [04-device-case.md](./design_patterns/composite-hierarchy-guide/04-device-case.md)
├── [05-unified-skeleton.md](./design_patterns/composite-hierarchy-guide/05-unified-skeleton.md)
├── [06-antipatterns.md](./design_patterns/composite-hierarchy-guide/06-antipatterns.md)
├── [07-reading-guide.md](./design_patterns/composite-hierarchy-guide/07-reading-guide.md)
    └── [08-mental-model.md](./design_patterns/composite-hierarchy-guide/08-mental-model.md)

## container-of-guide
├── [00-index.md](./design_patterns/container-of-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/container-of-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/container-of-guide/02-identification-rules.md)
├── [03-list-head-case.md](./design_patterns/container-of-guide/03-list-head-case.md)
├── [04-hlist-case.md](./design_patterns/container-of-guide/04-hlist-case.md)
├── [05-kobject-case.md](./design_patterns/container-of-guide/05-kobject-case.md)
├── [06-work-struct-case.md](./design_patterns/container-of-guide/06-work-struct-case.md)
├── [07-unified-skeleton.md](./design_patterns/container-of-guide/07-unified-skeleton.md)
├── [08-vs-inheritance.md](./design_patterns/container-of-guide/08-vs-inheritance.md)
├── [09-antipatterns.md](./design_patterns/container-of-guide/09-antipatterns.md)
├── [10-reading-guide.md](./design_patterns/container-of-guide/10-reading-guide.md)
    └── [11-mental-model.md](./design_patterns/container-of-guide/11-mental-model.md)

## error-handling-guide
├── [00-index.md](./design_patterns/error-handling-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/error-handling-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/error-handling-guide/02-identification-rules.md)
├── [03-goto-cleanup-case.md](./design_patterns/error-handling-guide/03-goto-cleanup-case.md)
├── [04-err-ptr-case.md](./design_patterns/error-handling-guide/04-err-ptr-case.md)
├── [05-return-conventions-case.md](./design_patterns/error-handling-guide/05-return-conventions-case.md)
├── [06-unified-skeleton.md](./design_patterns/error-handling-guide/06-unified-skeleton.md)
├── [07-vs-exceptions.md](./design_patterns/error-handling-guide/07-vs-exceptions.md)
├── [08-antipatterns.md](./design_patterns/error-handling-guide/08-antipatterns.md)
├── [09-reading-guide.md](./design_patterns/error-handling-guide/09-reading-guide.md)
    └── [10-mental-model.md](./design_patterns/error-handling-guide/10-mental-model.md)

## factory-guide
├── [00-index.md](./design_patterns/factory-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/factory-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/factory-guide/02-identification-rules.md)
├── [03-netdev-case.md](./design_patterns/factory-guide/03-netdev-case.md)
├── [04-skb-case.md](./design_patterns/factory-guide/04-skb-case.md)
├── [05-unified-skeleton.md](./design_patterns/factory-guide/05-unified-skeleton.md)
├── [06-antipatterns.md](./design_patterns/factory-guide/06-antipatterns.md)
├── [07-reading-guide.md](./design_patterns/factory-guide/07-reading-guide.md)
    └── [08-mental-model.md](./design_patterns/factory-guide/08-mental-model.md)

## hashtable-guide
├── [00-index.md](./design_patterns/hashtable-guide/00-index.md)
├── [01-separate-chaining.md](./design_patterns/hashtable-guide/01-separate-chaining.md)
├── [02-open-addressing-basic.md](./design_patterns/hashtable-guide/02-open-addressing-basic.md)
├── [03-open-addressing-advanced.md](./design_patterns/hashtable-guide/03-open-addressing-advanced.md)
├── [04-specialized-methods.md](./design_patterns/hashtable-guide/04-specialized-methods.md)
    └── [05-comparison-and-advice.md](./design_patterns/hashtable-guide/05-comparison-and-advice.md)

## object-pool-guide
├── [00-index.md](./design_patterns/object-pool-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/object-pool-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/object-pool-guide/02-identification-rules.md)
├── [03-slab-case.md](./design_patterns/object-pool-guide/03-slab-case.md)
├── [04-mempool-case.md](./design_patterns/object-pool-guide/04-mempool-case.md)
├── [05-unified-skeleton.md](./design_patterns/object-pool-guide/05-unified-skeleton.md)
├── [06-antipatterns.md](./design_patterns/object-pool-guide/06-antipatterns.md)
├── [07-reading-guide.md](./design_patterns/object-pool-guide/07-reading-guide.md)
    └── [08-mental-model.md](./design_patterns/object-pool-guide/08-mental-model.md)

## observer-notifier-guide
├── [00-index.md](./design_patterns/observer-notifier-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/observer-notifier-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/observer-notifier-guide/02-identification-rules.md)
├── [03-blocking-notifier-case.md](./design_patterns/observer-notifier-guide/03-blocking-notifier-case.md)
├── [04-netdev-notifier-case.md](./design_patterns/observer-notifier-guide/04-netdev-notifier-case.md)
├── [05-reboot-notifier-case.md](./design_patterns/observer-notifier-guide/05-reboot-notifier-case.md)
├── [06-unified-skeleton.md](./design_patterns/observer-notifier-guide/06-unified-skeleton.md)
├── [07-vs-callback.md](./design_patterns/observer-notifier-guide/07-vs-callback.md)
├── [08-antipatterns.md](./design_patterns/observer-notifier-guide/08-antipatterns.md)
├── [09-reading-guide.md](./design_patterns/observer-notifier-guide/09-reading-guide.md)
    └── [10-mental-model.md](./design_patterns/observer-notifier-guide/10-mental-model.md)

## rcu-guide
├── [00-index.md](./design_patterns/rcu-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/rcu-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/rcu-guide/02-identification-rules.md)
├── [03-dcache-case.md](./design_patterns/rcu-guide/03-dcache-case.md)
├── [04-routing-case.md](./design_patterns/rcu-guide/04-routing-case.md)
├── [05-unified-skeleton.md](./design_patterns/rcu-guide/05-unified-skeleton.md)
├── [06-antipatterns.md](./design_patterns/rcu-guide/06-antipatterns.md)
├── [07-reading-guide.md](./design_patterns/rcu-guide/07-reading-guide.md)
    └── [08-mental-model.md](./design_patterns/rcu-guide/08-mental-model.md)

## refcount-guide
├── [00-index.md](./design_patterns/refcount-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/refcount-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/refcount-guide/02-identification-rules.md)
├── [03-kref-case.md](./design_patterns/refcount-guide/03-kref-case.md)
├── [04-kobject-case.md](./design_patterns/refcount-guide/04-kobject-case.md)
├── [05-file-case.md](./design_patterns/refcount-guide/05-file-case.md)
├── [06-module-case.md](./design_patterns/refcount-guide/06-module-case.md)
├── [07-unified-skeleton.md](./design_patterns/refcount-guide/07-unified-skeleton.md)
├── [08-vs-garbage-collection.md](./design_patterns/refcount-guide/08-vs-garbage-collection.md)
├── [09-antipatterns.md](./design_patterns/refcount-guide/09-antipatterns.md)
├── [10-reading-guide.md](./design_patterns/refcount-guide/10-reading-guide.md)
    └── [11-mental-model.md](./design_patterns/refcount-guide/11-mental-model.md)

## registration-guide
├── [00-index.md](./design_patterns/registration-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/registration-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/registration-guide/02-identification-rules.md)
├── [03-driver-case.md](./design_patterns/registration-guide/03-driver-case.md)
├── [04-filesystem-case.md](./design_patterns/registration-guide/04-filesystem-case.md)
├── [05-unified-skeleton.md](./design_patterns/registration-guide/05-unified-skeleton.md)
├── [06-antipatterns.md](./design_patterns/registration-guide/06-antipatterns.md)
├── [07-reading-guide.md](./design_patterns/registration-guide/07-reading-guide.md)
    └── [08-mental-model.md](./design_patterns/registration-guide/08-mental-model.md)

## state-machine-guide
├── [00-index.md](./design_patterns/state-machine-guide/00-index.md)
├── [01-core-concept.md](./design_patterns/state-machine-guide/01-core-concept.md)
├── [02-identification-rules.md](./design_patterns/state-machine-guide/02-identification-rules.md)
├── [03-netdev-states-case.md](./design_patterns/state-machine-guide/03-netdev-states-case.md)
├── [04-tcp-states-case.md](./design_patterns/state-machine-guide/04-tcp-states-case.md)
├── [05-usb-states-case.md](./design_patterns/state-machine-guide/05-usb-states-case.md)
├── [06-unified-skeleton.md](./design_patterns/state-machine-guide/06-unified-skeleton.md)
├── [07-vs-flags.md](./design_patterns/state-machine-guide/07-vs-flags.md)
├── [08-antipatterns.md](./design_patterns/state-machine-guide/08-antipatterns.md)
├── [09-reading-guide.md](./design_patterns/state-machine-guide/09-reading-guide.md)
└── [10-mental-model.md](./design_patterns/state-machine-guide/10-mental-model.md)


## Template Method (模板方法) 设计模式
- 核心思想
    在一个方法中定义一个算法的骨架（固定步骤），而将一些步骤的延迟执行（即具体实现）交给子类或具体的实现模块

    不变部分（Template）： 算法的整体步骤、执行逻辑、状态跳转。这部分代码被封装起来，不允许轻易修改
    可变部分（Hooks/Slots）： 算法中依赖具体环境或特定需求的细节

- 解决的问题
    有一个稳定的执行流程
    其中某些步骤因对象 / 场景不同而变化
    但你不允许调用方随意改变顺序

- 核心约束
    流程顺序由框架掌控
    变化点被明确标记
    变化点不能反向控制流程

- 应用场景

- template-method-guide/
├── ![00-index.md](./design_patterns/template_method/template-method-guide/00-index.md)  
├── ![01-core-concept.md](./design_patterns/template_method/template-method-guide/01-core-concept.md)  
├── ![02-identification-rules.md](./design_patterns/template_method/template-method-guide/02-identification-rules.md)  
├── ![03-vfs-case.md](./design_patterns/template_method/template-method-guide/03-vfs-case.md)  
├── ![04-netdev-case.md](./design_patterns/template_method/template-method-guide/04-netdev-case.md)  
├── ![05-napi-case.md](./design_patterns/template_method/template-method-guide/05-napi-case.md)  
├── ![06-block-case.md](./design_patterns/template_method/template-method-guide/06-block-case.md)  
├── ![07-device-model-case.md](./design_patterns/template_method/template-method-guide/07-device-model-case.md)  
├── ![08-unified-skeleton.md](./design_patterns/template_method/template-method-guide/08-unified-skeleton.md)  
├── ![09-vs-strategy.md](./design_patterns/template_method/template-method-guide/09-vs-strategy.md)  
├── ![10-antipatterns.md](./design_patterns/template_method/template-method-guide/10-antipatterns.md)  
├── ![11-reading-guide.md](./design_patterns/template_method/template-method-guide/11-reading-guide.md)  12-mental-model.md
└── ![12-mental-model.md](./design_patterns/template_method/template-method-guide/12-mental-model.md)  

template_method
├── ![appl1_file_parser.c](./design_patterns/template_method/appl1_file_parser.c)  
├── ![appl2_proto_handle.c](./design_patterns/template_method/appl2_proto_handle.c)  
├── ![appl3_data_exporter.c](./design_patterns/template_method/appl3_data_exporter.c)  
├── ![impl1_func_ptr.c](./design_patterns/template_method/impl1_func_ptr.c)  
├── ![impl2_struct_callback.c](./design_patterns/template_method/impl2_struct_callback.c)  
├── ![linux_blk_dev_ops.c](./design_patterns/template_method/linux_blk_dev_ops.c)  
├── ![linux_blk_dev_ops2.c](./design_patterns/template_method/linux_blk_dev_ops2.c)  
├── ![linux_cdev_ops.c](./design_patterns/template_method/linux_cdev_ops.c)  
├── ![linux_i2c_bus_driver.c](./design_patterns/template_method/linux_i2c_bus_driver.c)  
├── ![linux_int_process.c](./design_patterns/template_method/linux_int_process.c)  
├── ![linux_net_ops.c](./design_patterns/template_method/linux_net_ops.c)  
├── ![linux_pci_driver.c](./design_patterns/template_method/linux_pci_driver.c)  
├── ![linux_platform_drv.c](./design_patterns/template_method/linux_platform_drv.c)  
├── ![linux_spi_bus_driver.c](./design_patterns/template_method/linux_spi_bus_driver.c)  
├── ![linux_summary.md](./design_patterns/template_method/linux_summary.md)  
├── ![linux_timer_framework.c](./design_patterns/template_method/linux_timer_framework.c)  
├── ![linux_vfs.c](./design_patterns/template_method/linux_vfs.c)  
├── ![linux_vfs2.c](./design_patterns/template_method/linux_vfs2.c)  
├── ![linux_workqueue.c](./design_patterns/template_method/linux_workqueue.c)  
├── ![peripheral_op_procedure.c](./design_patterns/template_method/peripheral_op_procedure.c)  
├── ![simplify1_marcro.c](./design_patterns/template_method/simplify1_marcro.c)  
├── ![simplify2_register_table.c](./design_patterns/template_method/simplify2_register_table.c)  
├── ![template-method-guide](./design_patterns/template_method/template-method-guide)  
└── ![template.c](./design_patterns/template_method/template.c)  

## Strategy Pattern (策略模式)
- ✅ 核心思想
    将一组功能等价、可互相替换的算法 / 策略，分别封装为独立的 “策略单元”；使用策略的「上下文（客户端）」不直接实现算法，而是通过 “策略接口” 调用算法，使得算法的实现与使用逻辑完全解耦，客户端可在运行时动态切换不同策略，无需修改核心逻辑。

    3 个关键要点
        1. 算法封装独立：每个策略（算法）都是独立的实现，互不干扰，符合 “单一职责”；
        2. 接口统一规范：所有策略遵循相同的调用接口（参数、返回值一致），保证客户端可无缝切换；
        3. 动态切换无侵入：新增 / 替换策略时，只需新增 / 修改策略实现，完全不改动客户端的核心逻辑（开闭原则）


- ✅ C 语言落地核心步骤（通用范式）
    1. 定义策略接口：用typedef声明函数指针类型，统一所有策略的调用格式；
    2. 实现具体策略：编写多个符合函数指针类型的函数，对应不同算法；
    3. 定义上下文结构体：包含策略函数指针（用于存储当前选中的策略）；
    4. 上下文封装调用逻辑：提供 “设置策略”“执行策略” 的函数，客户端通过这些函数切换 / 调用策略；
    5. 客户端使用：创建上下文实例，动态赋值策略指针，调用执行函数。

- ✅ 策略模式核心思想
    封装可替换的算法，统一接口，动态切换，算法与使用方解耦。
- ✅ C 语言实现关键
    用函数指针类型定义统一的策略接口；
    用结构体封装策略指针作为上下文；
    上下文提供「设置策略」「执行策略」函数，客户端无需直接操作函数指针；
    新增策略只需新增函数，完全不修改核心逻辑。
- ✅ 与模板方法的核心区别
    模板方法：流程固定，步骤细节可变（“骨架不变，肉可变”）；
    策略模式：无固定流程，算法本身可变（“肉不变，做法可变”）；
    核心判断：如果是 “换算法”，用策略模式；如果是 “换步骤实现”，用模板方法。
- ✅ 策略模式的核心价值
    消除大量 if-else/switch 判断，代码更简洁；
    算法独立扩展，符合开闭原则；
    运行时动态切换策略，适配不同业务场景；
    是 C 语言实现 “算法解耦、动态扩展” 的最佳实践之一。

- strategy-pattern-guide
├── ![00-index](./design_patterns/strategy_pattern/strategy-pattern-guide/00-index.md)  
├── ![01-core-concept](./design_patterns/strategy_pattern/strategy-pattern-guide/01-core-concept.md)
├── ![02-identification-rules](./design_patterns/strategy_pattern/strategy-pattern-guide/02-identification-rules.md)
├── ![03-scheduler-case](./design_patterns/strategy_pattern/strategy-pattern-guide/03-scheduler-case.md)
├── ![04-tcp-congestion-case](./design_patterns/strategy_pattern/strategy-pattern-guide/04-tcp-congestion-case.md)
├── ![05-io-scheduler-case](./design_patterns/strategy_pattern/strategy-pattern-guide/05-io-scheduler-case.md)
├── ![06-memory-policy-case](./design_patterns/strategy_pattern/strategy-pattern-guide/06-memory-policy-case.md)
├── ![07-lsm-case](./design_patterns/strategy_pattern/strategy-pattern-guide/07-lsm-case.md)
├── ![08-unified-skeleton](./design_patterns/strategy_pattern/strategy-pattern-guide/08-unified-skeleton.md)
├── ![09-vs-template-method](./design_patterns/strategy_pattern/strategy-pattern-guide/09-vs-template-method.md)
├── ![10-antipatterns](./design_patterns/strategy_pattern/strategy-pattern-guide/10-antipatterns.md)
├── ![11-reading-guide](./design_patterns/strategy_pattern/strategy-pattern-guide/11-reading-guide.md)
└── ![12-mental-model](./design_patterns/strategy_pattern/strategy-pattern-guide/12-mental-model.md)

strategy_pattern/
├── ![linux_crypto_subsys.c](./design_patterns/strategy_pattern/linux_crypto_subsys.c)  
├── ![linux_io_sched.c](./design_patterns/strategy_pattern/linux_io_sched.c)  
├── ![linux_mem_alloc.c](./design_patterns/strategy_pattern/linux_mem_alloc.c)  
├── ![linux_proc_sched.c](./design_patterns/strategy_pattern/linux_proc_sched.c)  
├── ![linux_summary.md](./design_patterns/strategy_pattern/linux_summary.md)  
├── ![strategy-pattern-guide](./design_patterns/strategy_pattern/strategy-pattern-guide)  
└── ![template.c](./design_patterns/strategy_pattern/template.c)  


## Singleton (单例模式)
- 核心要点（C 语言视角）
    唯一性：实例在进程 / 内核空间中仅存在一份（通过static全局变量实现）；
    懒加载 / 饿汉式：懒加载（首次访问时初始化）、饿汉式（程序启动 / 内核初始化时创建）；
    线程 / 多核安全：多线程 / 多核环境下需加锁保护初始化逻辑，避免竞态导致多次初始化；
    全局访问：封装初始化逻辑，对外仅暴露一个获取实例的函数，隐藏内部实现。

- C 语言实现单例模式的核心思路
    单例模式角色	C 语言实现方式
    唯一实例		static全局变量（进程 / 内核空间仅一份）
    初始化保护		互斥锁（pthread_mutex_t/ 内核spinlock）+ 初始化标记
    全局访问接口	封装初始化逻辑的static函数 如get_instance()

singleton_pattern/
├── ![linux_int_controller.c](./design_patterns/singleton_pattern/linux_int_controller.c)  
├── ![linux_pid_manager.c](./design_patterns/singleton_pattern/linux_pid_manager.c)  
├── ![linux_slab_cache.c](./design_patterns/singleton_pattern/linux_slab_cache.c)  
├── ![linux_summary.md](./design_patterns/singleton_pattern/linux_summary.md)  
├── ![linux_sys_call_table.c](./design_patterns/singleton_pattern/linux_sys_call_table.c)  
└── ![template.c](./design_patterns/singleton_pattern/template.c)  

## Factory (工厂模式)
- 核心定义
    工厂模式的核心是封装对象（产品）的创建逻辑，将对象的创建与使用分离：通过一个统一的「工厂接口」，根据输入参数（如设备 ID、类型名、配置）返回对应类型的产品实例，用户无需关心产品的具体创建细节（如内存分配、初始化、硬件适配），仅需调用工厂接口即可获取可用的实例。

- 核心分类（C 语言 / 内核视角）
	内核中以简单工厂模式为主（单一工厂函数创建所有产品），工厂方法模式（每个产品对应一个工厂函数）为辅，二者核心差异如下：
		类型		核心特征						  内核应用场景
		简单工厂	一个工厂函数创建所有类型的产品		PCI 设备匹配、字符设备创建
		工厂方法	每个产品对应一个专属工厂函数		Crypto 算法创建、文件系统挂载

- 核心要点（C 语言视角）
	产品抽象：所有产品遵循统一的接口（用函数指针结构体定义），保证用户可无缝替换产品；
	创建封装：工厂函数集中处理产品的创建逻辑（如参数校验、内存分配、初始化），用户无需感知；
	扩展友好：新增产品时，仅需新增产品实现和工厂函数的参数判断，无需修改用户逻辑；
	解耦：用户仅依赖工厂接口，不依赖具体产品的实现，降低模块耦合。

- C 语言实现工厂模式的核心思路
    工厂模式 OOP 角色	C 语言实现方式							作用说明
    抽象产品			函数指针结构体（定义统一的产品接口）	 所有具体产品遵循相同的函数指针规范
    具体产品			填充函数指针的结构体实例				不同产品的具体实现
    工厂				工厂函数（根据参数返回具体产品实例）	 封装创建逻辑，统一对外接口

factory_pattern/
├── ![linux_char_dev.c](./design_patterns/factory_pattern/linux_char_dev.c)  
├── ![linux_crypto.c](./design_patterns/factory_pattern/linux_crypto.c)  
├── ![linux_fs.c](./design_patterns/factory_pattern/linux_fs.c)  
├── ![linux_pci_device.c](./design_patterns/factory_pattern/linux_pci_device.c)  
├── ![linux_summary.md](./design_patterns/factory_pattern/linux_summary.md)  
└── ![template.c](./design_patterns/factory_pattern/template.c)  

## Observer (观察者模式)
- 核心定义
    观察者模式定义了主题（Subject）与观察者（Observer）的一对多依赖关系：当主题的状态 / 事件发生变化时，会自动遍历并通知所有已注册的观察者（调用观察者的回调函数），观察者无需主动轮询主题状态，而是被动接收通知。核心目标是解耦主题与观察者—— 主题无需知道观察者的具体实现，观察者也无需知道主题的内部逻辑，二者仅通过统一的回调接口交互。

- 核心角色（C 语言 / 内核视角映射）
    - OOP 中的观察者模式角色可完全映射到 C 语言的基础特性，这也是内核实现的核心思路：
    观察者模式 OOP 角色		C 语言实现方式							作用说明
    主题（Subject）			结构体（管理观察者链表 + 事件状态）		维护观察者注册池，触发事件时通知所有观察者
    观察者（Observer）		函数指针（统一的回调接口）				每个观察者对应一个回调函数，接收主题通知
    注册 / 注销				链表操作函数（添加 / 删除回调指针）		管理观察者的注册与注销，支持动态增减
    通知					遍历链表 + 调用回调函数				   主题状态变化时，批量触发观察者回调

- 核心要点（C 语言视角）
    解耦性：主题与观察者无直接依赖，仅通过回调接口交互，新增 / 删除观察者无需修改主题逻辑；
    被动通知：观察者无需轮询，由主题主动推送事件，降低 CPU 开销；
    动态性：运行时可动态注册 / 注销观察者，支持热插拔；
    一致性：所有观察者遵循统一的回调接口，主题无需适配不同观察者的实现。

observer_pattern/
├── ![linux_inotify.c](./design_patterns/observer_pattern/linux_inotify.c)  
├── ![linux_int_top_bot_half.c](./design_patterns/observer_pattern/linux_int_top_bot_half.c)  
├── ![linux_kobj_uevent.c](./design_patterns/observer_pattern/linux_kobj_uevent.c)  
├── ![linux_netlink.c](./design_patterns/observer_pattern/linux_netlink.c)  
├── ![linux_summary.md](./design_patterns/observer_pattern/linux_summary.md)  
└── ![template.c](./design_patterns/observer_pattern/template.c)  

## Adapter (适配器模式)
- 核心定义
    适配器模式的核心是将一个现有、不兼容的接口（被适配者 / Adaptee）转换为上层模块期望的统一目标接口（Target），使原本因接口格式、参数、命名不匹配而无法协作的模块能够无缝工作。核心目标是 “接口适配，逻辑复用”—— 不修改被适配者的原有实现（如硬件驱动、老旧模块），仅通过适配器层做接口格式的转换，复用其核心逻辑。

- 核心角色（C 语言 / 内核视角映射）
    OOP 中的适配器模式角色可完全映射到 C 语言的基础特性，这也是内核实现的核心思路：
    适配器模式 OOP 角色		C 语言实现方式												作用说明
    目标接口（Target）		函数指针结构体（上层 / 内核核心层期望的统一接口）				定义适配器需要实现的标准化接口，是上层模块交互的唯一入口
    被适配者（Adaptee）		现有不兼容的函数 / 结构体（如厂商硬件原生接口）					已有但接口不匹配的模块，核心逻辑无需修改
    适配器（Adapter）		封装被适配者的结构体 + 函数（实现目标接口，内部调用被适配者）	实现目标接口，在函数内部完成参数 / 格式转换，调用被适配者的接口

- 核心要点（C 语言视角）
    无侵入性：不修改被适配者的任何代码，仅通过适配器层做转换，保护原有逻辑；
    接口统一：上层模块仅依赖目标接口，无需感知底层被适配者的差异；
    复用性：原有不兼容的模块（如不同厂商硬件驱动）可通过适配器复用在统一框架中；
    双向适配：支持 “类适配器”（直接封装）和 “对象适配器”（通过指针引用），内核中以对象适配器为主（更灵活）。

adapter_pattern/
├── ![linux_32bit_64bit_syscall.c](./design_patterns/adapter_pattern/linux_32bit_64bit_syscall.c)  
├── ![linux_device_mapper.c](./design_patterns/adapter_pattern/linux_device_mapper.c)  
├── ![linux_spic.c](./design_patterns/adapter_pattern/linux_spic.c)  
├── ![linux_summary.md](./design_patterns/adapter_pattern/linux_summary.md)  
├── ![linux_vfs_adapter.c](./design_patterns/adapter_pattern/linux_vfs_adapter.c)  
└── ![template.c](./design_patterns/adapter_pattern/template.c)  

## Decorator (装饰器模式)

- 核心定义
装饰器模式的核心是在不修改原有核心功能代码的前提下，动态地给一个 “核心对象” 添加额外的职责（附加功能），且保持对象的统一接口 —— 装饰后的对象可完全替代原对象使用。核心目标是 “功能扩展解耦”：将核心功能（如文件读写、内存分配）与附加功能（如日志、校验、加密、统计）分离，通过嵌套装饰器实现多维度功能组合（如 “读写 + 日志 + 加密”），避免为每个功能组合创建冗余的实现（即 OOP 中的 “类爆炸”，C 语言中则是 “函数爆炸”）。

- 核心角色（C 语言 / 内核视角映射）
OOP 中的装饰器模式角色可完全映射到 C 语言的基础特性，这也是内核实现的核心思路：
装饰器模式 OOP 角色				C 语言实现方式							作用说明
组件（Component）				函数指针结构体（定义统一的核心接口）	核心功能的标准化接口，装饰器和基础组件都需实现
具体组件（ConcreteComponent）	实现核心接口的基础函数 / 结构体			提供无附加功能的 “纯核心逻辑”（如基础文件读写、原生内存分配）
装饰器（Decorator）				嵌套核心接口指针的结构体 + 封装函数		持有核心接口指针，实现统一接口，内部调用核心逻辑并添加附加功能
具体装饰器（ConcreteDecorator）	具体的装饰器函数 / 结构体				实现特定附加功能（如日志装饰、加密装饰、统计装饰）

- 核心要点（C 语言视角）
无侵入性：不修改核心功能的任何代码，仅通过封装扩展；
接口一致性：装饰器与核心组件实现相同的函数指针接口，上层无感知；
动态组合：支持多个装饰器嵌套（如 “日志装饰器包裹加密装饰器，再包裹核心组件”）；
按需扩展：运行时可动态添加 / 移除装饰器（如调试时加日志，生产时移除）。

decorator_pattern/
├── ![linux_file_ops.c](./design_patterns/decorator_pattern/linux_file_ops.c)  
├── ![linux_int_handler.c](./design_patterns/decorator_pattern/linux_int_handler.c)  
├── ![linux_kmalloc.c](./design_patterns/decorator_pattern/linux_kmalloc.c)  
├── ![linux_net_packet.c](./design_patterns/decorator_pattern/linux_net_packet.c)  
├── ![linux_summary.md](./design_patterns/decorator_pattern/linux_summary.md)  
└── ![template.c](./design_patterns/decorator_pattern/template.c)  

## Iterator (迭代器模式)

1. 核心定义
迭代器模式的核心是提供一种统一的方式来遍历聚合对象（如链表、数组、哈希表）中的所有元素，而无需暴露该聚合对象的内部存储结构（如数组下标、链表节点指针）。核心目标是 “遍历逻辑与聚合对象解耦”—— 上层代码仅通过迭代器的统一接口（如has_next()、next()）遍历元素，无需关心聚合对象是数组、链表还是哈希表；同时聚合对象的内部实现修改后，遍历逻辑无需任何调整。

2. 核心角色（C 语言 / 内核视角映射）
OOP 中的迭代器模式角色可完全映射到 C 语言的基础特性，这也是内核实现迭代器的核心思路：
迭代器模式 OOP 角色				C 语言实现方式													作用说明
迭代器接口（Iterator）			函数指针结构体（包含has_next/next/reset）						定义统一的遍历接口，所有具体迭代器需实现
具体迭代器（ConcreteIterator）	针对特定聚合对象的迭代函数 / 宏（如链表迭代宏、数组迭代函数）	实现迭代器接口，封装具体的遍历逻辑（如链表节点移动、数组下标递增）
聚合对象（Aggregate）			数组 / 链表 / 哈希表等数据结构（如内核list_head、hlist）	存储元素的容器，提供 “创建迭代器” 的方法（如内核list_iterator_init）
具体聚合对象（ConcreteAggregate）	内核task_struct链表、device链表等具体容器				实际存储业务数据的聚合对象，适配迭代器接口

3. 核心要点（C 语言视角）
接口统一性：不同聚合对象的迭代器实现相同的接口，上层遍历逻辑完全复用；
解耦性：遍历逻辑（如 “逐个访问元素”）与聚合对象内部结构（如链表节点、数组下标）分离；
安全性：迭代器封装了聚合对象的遍历边界（如数组越界、链表尾节点判断），避免上层出错；
灵活性：支持正向 / 反向遍历、条件遍历（如内核list_for_each_entry_if），且可同时存在多个迭代器遍历同一聚合对象。

iterator_pattern/
├── ![linux_device_traverse.c](./design_patterns/iterator_pattern/linux_device_traverse.c)  
├── ![linux_hlist.c](./design_patterns/iterator_pattern/linux_hlist.c)  
├── ![linux_list_head.c](./design_patterns/iterator_pattern/linux_list_head.c)  
├── ![linux_summary.md](./design_patterns/iterator_pattern/linux_summary.md)  
├── ![linux_task_traverse.c](./design_patterns/iterator_pattern/linux_task_traverse.c)  
└── ![template.c](./design_patterns/iterator_pattern/template.c)  

## Flyweight (享元模式)

1. 核心定义
享元模式的核心是复用内存中已存在的 “细粒度对象”（享元对象），而非每次创建新对象，以此减少内存占用和对象创建 / 销毁的开销。其关键是将对象的状态严格分为两类：
内部状态（Intrinsic State）：可共享、不变的状态（如对象的类型、基础配置、固定属性），存储在享元对象内部，是复用的核心依据；
外部状态（Extrinsic State）：不可共享、可变的状态（如对象的使用上下文、临时参数、动态数据），由外部传入，不存储在享元对象中。

2. 核心角色（C 语言 / 内核视角映射）
OOP 中的享元模式角色可完全适配 C 语言特性，这也是内核实现享元的核心思路：
享元模式 OOP 角色				C 语言实现方式									作用说明
享元接口（Flyweight）			函数指针结构体（定义享元对象的操作接口）		统一共享对象的使用方式，屏蔽内部状态差异
具体享元（ConcreteFlyweight）	存储内部状态的结构体							包含不可变的共享状态，实现享元接口
享元工厂（FlyweightFactory）	对象池管理函数（创建 / 获取 / 回收享元对象）	维护对象池，优先返回已存在的享元对象（命中），未命中则创建新对象
外部状态						函数参数 / 全局上下文							不存储在享元对象中，使用时动态传入

3. 核心要点（C 语言视角）
复用优先：工厂函数先检查对象池，仅在无匹配对象时创建新对象；
状态分离：内部状态必须是 “不变、可共享” 的属性，外部状态需动态传入且不持久化；
池化管理：通过数组 / 链表管理享元对象，设置池大小上限平衡内存占用和复用率；
轻量复用：回收对象时仅重置外部状态，保留内部状态，减少复用成本。

flyweight_pattern/
├── ![linux_inode.c](./design_patterns/flyweight_pattern/linux_inode.c)  
├── ![linux_skbuff_pool.c](./design_patterns/flyweight_pattern/linux_skbuff_pool.c)  
├── ![linux_slab.c](./design_patterns/flyweight_pattern/linux_slab.c)  
├── ![linux_summary.md](./design_patterns/flyweight_pattern/linux_summary.md)  
└── ![template.c](./design_patterns/flyweight_pattern/template.c)  

## PDD(Presentation–Domain–Data Layering)
![what pdd really means](./design_patterns/pdd/pdd_01_what_pdd_really_means.md)  
![linux kernel mapping](./design_patterns/pdd/pdd_02_linux_kernel_mapping.md)  
![userspace examples](./design_patterns/pdd/pdd_03_userspace_examples.md)  
![antipatterns](./design_patterns/pdd/pdd_04_antipatterns.md)  
![refactoring guide](./design_patterns/pdd/pdd_05_refactoring_guide.md)  
[]()  
[]()  

## Design Patterns
![INDEX](./python/patterns/00_INDEX.md)  
![singleton](./python/patterns/01_singleton.md)  
![factory_method](./python/patterns/02_factory_method.md)  
![abstract_factory](./python/patterns/03_abstract_factory.md)  
![builder](./python/patterns/04_builder.md)  
![prototype](./python/patterns/05_prototype.md)  
![adapter](./python/patterns/06_adapter.md)  
![decorator](./python/patterns/07_decorator.md)  
![strategy](./python/patterns/08_strategy.md)  
![observer](./python/patterns/09_observer.md)  
![command](./python/patterns/10_command.md)  
![proxy](./python/patterns/11_proxy.md)  
![facade](./python/patterns/12_facade.md)  
![iterator](./python/patterns/13_iterator.md)  
![state](./python/patterns/14_state.md)  
![template_method](./python/patterns/15_template_method.md)  
![composite](./python/patterns/16_composite.md)  
![chain_of_responsibility](./python/patterns/17_chain_of_responsibility.md)  
![dependency_injection](./python/patterns/18_dependency_injection.md)  

## Design Patterns (python examples)
![设计模式](./design_patterns/design_patterns_index.md)  
![创建型设计模式](./design_patterns/design_patterns_creational.md)  
![结构型设计模式](./design_patterns/design_patterns_structural.md)  
![行为型设计模式](./design_patterns/design_patterns_behavioral_1.md)  
![行为型设计模式](./design_patterns/design_patterns_behavioral_2.md)  

## SOLID原则
1. SRP(Single Responsibility Principle单一职责原则)
```python
# SRP
class Journal:
    def __init__(self):
        self.entries = []
        self.count = 0

    def add_entry(self, text):
        self.count += 1
        self.entries.append(f"{self.count}: {text}")

    def remove_entry(self, index):
        del self.entries[index]

    def __str__(self):
        return "\n".join(self.entries)

class PersistenceManager:
    @staticmethod
    def save_to_file(journal, filename):
        with open(filename, "w") as f:
            f.write(str(journal))

j = Journal()
j.add_entry("I cried today.")
j.add_entry("I ate a bug.")
print(f"Journal entries:\n{j}")

file = r'journal.txt'
PersistenceManager.save_to_file(j, file)

with open(file, "r") as f:
    print(f.read())
```

- OCP(Open-Closed Principle:开闭原则) (Open for extension, closed for modification)
```python
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

class Size(Enum):
    SMALL = 1
    MEDIUM = 2
    LARGE = 3

class Product:
    def __init__(self, name, color, size):
        self.name = name
        self.color = color
        self.size = size

class ProductFilter:
    def filter(self, products, spec):
        for product in products:
            if spec.is_satisfied(product):
                yield product

class Specification:
    def is_satisfied(self, item):
        pass

    def __and__(self, other):
        return AndSpecification(self, other)

class Filter:
    def filter(self, items, spec):
        pass

class ColorSpecification(Specification):
    def __init__(self, color):
        self.color = color

    def is_satisfied(self, item):
        return item.color == self.color

class SizeSpecification(Specification):
    def __init__(self, size):
        self.size = size

    def is_satisfied(self, item):
        return item.size == self.size

class AndSpecification(Specification):
    def __init__(self, *args):
        self.args = args

    def is_satisfied(self, item):
        return all(spec.is_satisfied(item) for spec in self.args)

class BetterFilter(Filter):
    def filter(self, items, spec):
        for item in items:
            if spec.is_satisfied(item):
                yield item

if __name__ == "__main__":
    apple = Product("Apple", Color.RED, Size.SMALL)
    tree = Product("Tree", Color.GREEN, Size.LARGE)
    house = Product("House", Color.BLUE, Size.MEDIUM)

    products = [apple, tree, house]

    pf = BetterFilter()
    print("Green products:")
    green_spec = ColorSpecification(Color.GREEN)
    for p in pf.filter(products, green_spec):
        print(f" - {p.name} is green")

    print("Large products:")
    large_spec = SizeSpecification(Size.LARGE)
    for p in pf.filter(products, large_spec):
        print(f" - {p.name} is large")

    print("Large green products:")
    large_green_spec = AndSpecification(SizeSpecification(Size.LARGE), ColorSpecification(Color.GREEN))
    for p in pf.filter(products, large_green_spec):
        print(f" - {p.name} is large and green")

    print("Large green products:")
    large_green_spec = SizeSpecification(Size.LARGE) and ColorSpecification(Color.GREEN)
    for p in pf.filter(products, large_green_spec):
        print(f" - {p.name} is large and green")
```

- LSP(里氏替换原则) (Liskov Substitution Principle)
```python

class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    @property
    def area(self):
        return self._width * self._height

    def __str__(self):
        return f"Rectangle(width={self._width}, height={self._height})"

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, value):
        self._width = value

    @property
    def height(self):
        return self._height

    @height.setter
    def height(self, value):
        self._height = value

class Square(Rectangle):
    def __init__(self, size):
        Rectangle.__init__(self, size, size)

    def __str__(self):
        return f"Square(size={self._width})"

    @Rectangle.width.setter
    def width(self, value):
        self._width = self._height = value

    @Rectangle.height.setter
    def height(self, value):
        self._width = self._height = value

def use_it(rc):
    w = rc.width
    rc.height = 10
    expected = int(w * 10)
    print(f"Expected an area of {expected}, got {rc.area}")

rc = Rectangle(2, 3)
use_it(rc)

sq = Square(5)
use_it(sq)
```

- ISP(Interface Segregation Principle:接口隔离原则) (Interface Segregation Principle)

```python
from abc import abstractmethod

class Printer:
    @abstractmethod
    def print(self, document):
        pass

class Scanner:
    @abstractmethod
    def scan(self, document):
        pass

class PrinterScanner(Printer, Scanner):
    @abstractmethod
    def print(self, document):
        pass

    @abstractmethod
    def scan(self, document):
        pass

class PrinterScannerMachine(PrinterScanner):
    def __init__(self, printer, scanner):
        self.printer = printer
        self.scanner = scanner

    def print(self, document):
        self.printer.print(document)

    def scan(self, document):
        self.scanner.scan(document)

class PrinterImpl(Printer):
    def print(self, document):
        print(f"Printing {document}")

class ScannerImpl(Scanner):
    def scan(self, document):
        print(f"Scanning {document}")

myPrinter = PrinterImpl()
myScanner = ScannerImpl()
myPrinterScanner = PrinterScannerMachine(myPrinter, myScanner)
myPrinterScanner.print("Hello, world!")
myPrinterScanner.scan("Hello, world!")
```

- DIP(Dependency Inversion Principle:依赖倒置原则)
	- 高层模块不应该依赖于低层模块，两者都应该依赖于抽象

```python
from enum import Enum
from abc import abstractmethod

class Relationship(Enum):
    PARENT = 0
    CHILD = 1
    SIBLING = 2

class Person:
    def __init__(self, name):
        self.name = name

# abstraction interface
class RelationshipBrowser:
    @abstractmethod
    def find_all_children_of(self, name):
        pass

# low-level module
class Relationships(RelationshipBrowser):
    def __init__(self):
        # low-level implementation
        self.relations = []

    def add_parent_and_child(self, parent, child):
        self.relations.append((parent, Relationship.PARENT, child))

    def find_all_children_of(self, name):
        for relation in self.relations:
            if relation[0].name == name and relation[1] == Relationship.PARENT:
                yield relation[2].name

# high-level module
class Research:
    def __init__(self, browser):
        for p in browser.find_all_children_of("John"):
            print(f"John has a child called {p}")

if __name__ == "__main__":
    parent = Person("John")
    child1 = Person("Chris")
    child2 = Person("Matt")
    relationships = Relationships()
    relationships.add_parent_and_child(parent, child1)
    relationships.add_parent_and_child(parent, child2)
    research = Research(relationships)
```

## Patterns
- 核心思想
    C语言实现设计模式的本质是「用结构体模拟对象、函数指针实现多态、封装函数控制访问」，最终目标是解耦、复用、可扩展

- 创建型模式 (Creational Patterns): 聚焦对象创建逻辑
![构建器模式](builder_pattern.md)  
![工厂方法模式](factory_method_pattern.md)  
![抽象工厂模式](abstract_factory_pattern.md)  
![原型模式](prototype_pattern.md)  
![单例模式](singleton_pattern.md)  

- 结构型模式 (Structural Patterns):聚焦对象/模块的组合关系
![适配器模式](adapter_pattern.md)  
![桥接模式](bridge_pattern.md)  
![装饰器模式](decorator_pattern.md)  
![外观模式](facade_pattern.md)  
![代理模式](proxy_pattern.md)  

- 行为型模式 (Behavioral Patterns):聚焦对象间的交互与行为
![命令模式](command_pattern.md)  
![迭代器模式](iterator_pattern.md)  
![备忘录模式](memento_pattern.md)  
![观察者模式](observer_pattern.md)  
![策略模式](strategy_pattern.md)  
![访问者模式](visitor_pattern.md)  
![](./c_tips/patterns/)  
![]()  
![]()  
![]()  
![]()  

- 创建型模式 (Creational Patterns)
![单例模式](./c_tips/patterns/01_singleton.md)  
![工厂模式](./c_tips/patterns/02_factory.md)  
![原型模式](./c_tips/patterns/03_prototype.md)  

- 结构型模式 (Structural Patterns)
![适配器模式](./c_tips/patterns/04_adapter.md)  
![装饰器模式](./c_tips/patterns/05_decorator.md)  
![组合模式](./c_tips/patterns/06_composite.md)  
![桥接模式](./c_tips/patterns/07_bridge.md)  

- 行为型模式 (Behavioral Patterns)
![策略模式](./c_tips/patterns/08_strategy.md)  
![观察者模式](./c_tips/patterns/09_observer.md)  
![命令模式](./c_tips/patterns/10_command.md)  
![迭代器模式](./c_tips/patterns/11_iterator.md)  
![状态模式](./c_tips/patterns/12_state.md)  

- Kernel patterns
![README.md](./c_tips/kernel_patterns/README.md)  
![单例模式](./c_tips/kernel_patterns/01_singleton_pattern.md)  
![工厂模式](./c_tips/kernel_patterns/02_factory_pattern.md)  
![原型模式](./c_tips/kernel_patterns/03_prototype_pattern.md)  
![适配器模式](./c_tips/kernel_patterns/04_adapter_pattern.md)  
![装饰器模式](./c_tips/kernel_patterns/05_decorator_pattern.md)  
![组合模式](./c_tips/kernel_patterns/06_composite_pattern.md)  
![桥接模式](./c_tips/kernel_patterns/07_bridge_pattern.md)  
![策略模式](./c_tips/kernel_patterns/08_strategy_pattern.md)  
![观察者模式](./c_tips/kernel_patterns/09_observer_pattern.md)  
![命令模式](./c_tips/kernel_patterns/10_command_pattern.md)  
![迭代器模式](./c_tips/kernel_patterns/11_iterator_pattern.md)  
![状态模式](./c_tips/kernel_patterns/12_state_pattern.md)  

- Design Patterns for Embedded Systems in C (pdf)
![硬件访问模式](./design_patterns/embedded/01_hardware_access_patterns.md)  
![并发和资源管理模式](./design_patterns/embedded/02_concurrency_patterns.md)  
![状态机设计模式](./design_patterns/embedded/03_state_machine_patterns.md)  
![安全和可靠性模式](./design_patterns/embedded/04_safety_reliability_patterns.md)  


![Linux Operations Structure Pattern](./linux/linux_kernel_ops_pattern.md)  
![Linux Kernel 经典设计模式](./linux/linux_kernel_classic_patterns.md)  
![Linux Kernel 经典设计模式 对应 用户空间代码示例](./linux/kernel_patterns_userspace_examples.md)  
![]()  
![]()  
![]()  

## Builder Pattern
- When piecewise object construction is complicated, provide an API for doing it succinctly.
    - A buildder is a separate component for building an object step by step
    - Can either give builder an initializer or return it via a static function
    - To make builder fluent, return self
    - Different facets of an object can be built with different builders working in tandem via composition
```python
# original code
words = ['hello', 'world']
parts = ['<ul>']
for w in words:
    parts.append(f'  <li>{w}</li>')
parts.append('</ul>')
html = '\n'.join(parts)
print(html)

# =============================================================================
# 构建器模式 (Builder Pattern) - HTML 元素构建示例
# =============================================================================
# 核心思想：
#   1. 将复杂对象的构建过程与其表示分离
#   2. 通过构建器逐步添加内容，而不是一次性传入所有参数
#   3. 流畅接口 (Fluent Interface)：方法返回 self，支持链式调用
#   4. 静态工厂方法：提供更语义化的对象创建方式
# =============================================================================

class HtmlElement:
    """
    HTML 元素类：表示一个 HTML 标签节点
    支持嵌套子元素，形成树形结构
    """
    indent_size = 2  # 类变量：缩进空格数

    def __init__(self, name, text):
        self.name = name          # 标签名，如 'ul', 'li'
        self.text = text          # 标签内的文本内容
        self.elements = []        # 子元素列表（支持嵌套）

    def __str(self, indent):
        """
        私有递归方法：生成带缩进的 HTML 字符串
        indent: 当前缩进层级
        """
        lines = []
        i = ' ' * indent * self.indent_size
        lines.append(f'{i}<{self.name}>')           # 开始标签

        if self.text:
            t = ' ' * (indent + 1) * self.indent_size
            lines.append(f'{t}{self.text}')         # 文本内容（缩进一级）

        for e in self.elements:
            lines.append(e.__str(indent + 1))       # 递归渲染子元素

        lines.append(f'{i}</{self.name}>')          # 结束标签
        return '\n'.join(lines)

    def __str__(self):
        """公开的 __str__ 方法，从缩进 0 开始渲染"""
        return self.__str(0)


class HtmlBuilder:
    """
    HTML 构建器：负责逐步构建 HTML 元素树
    将构建逻辑封装，使用者无需关心 HtmlElement 的内部细节
    """
    def __init__(self, root_name):
        self.root = HtmlElement(root_name, '')  # 创建根元素

    def add_child(self, child_name, child_text):
        """普通方法：添加子元素，无返回值"""
        self.root.elements.append(HtmlElement(child_name, child_text))

    def add_child_fluent(self, child_name, child_text):
        """
        流畅接口方法：添加子元素并返回 self
        关键点：return self 使得可以链式调用多个方法
        """
        self.root.elements.append(HtmlElement(child_name, child_text))
        return self  # ← 这是流畅接口的关键！

    def __str__(self):
        return str(self.root)

    @staticmethod
    def create(name):
        """
        静态工厂方法：提供更语义化的创建方式
        HtmlBuilder.create('ul') 比 HtmlBuilder('ul') 更具可读性
        """
        return HtmlBuilder(name)


# =============================================================================
# 使用示例对比
# =============================================================================

# 方式1：直接构造 + 普通方法（需要多条语句）
# builder = HtmlBuilder('ul')
# builder.add_child('li', 'hello')
# builder.add_child('li', 'world')

# 方式2：静态工厂 + 流畅接口（一条链式语句）
builder = HtmlBuilder.create('ul')
builder.add_child_fluent('li', 'hello')\
    .add_child_fluent('li', 'world')

print(builder)
# 输出：
# <ul>
#   <li>
#     hello
#   </li>
#   <li>
#     world
#   </li>
# </ul>

# =============================================================================
# 分面构建器模式 (Faceted Builder Pattern)
# =============================================================================
# 核心思想：
#   1. 当一个对象有多个不同的"方面"(facet)需要构建时，可以为每个方面创建专门的子构建器
#   2. 所有子构建器共享同一个被构建对象的引用，从而协同工作
#   3. 通过属性(property)在不同的子构建器之间切换，实现流畅的链式调用

# 调用流程图:
# PersonBuilder
#     │
#     ├─.lives──► PersonAddressBuilder ──.at()/.with_postcode()/.in_city()
#     │                   │
#     │                   └─.works──► PersonJobBuilder
#     │
#     └─.works──► PersonJobBuilder ──.at()/.as_a()/.earning()
#                         │
#                         └─.lives──► PersonAddressBuilder
# =============================================================================

class Person:
    """被构建的目标对象，包含两个方面(facet)：地址信息和工作信息"""
    def __init__(self):
        # 地址方面 (address facet)
        self.street_address = None
        self.postcode = None
        self.city = None
        # 工作方面 (employment facet)
        self.company_name = None
        self.position = None
        self.annual_income = None

    def __str__(self):
        return f"Address: {self.street_address}, {self.postcode}, {self.city}\nCompany: {self.company_name}, {self.position}, {self.annual_income}"


class PersonBuilder:
    """
    主构建器：作为所有子构建器的基类
    关键点：通过 works 和 lives 属性提供对子构建器的访问入口
    """
    def __init__(self, person=Person()):
        self.person = person  # 所有构建器共享同一个 Person 实例

    @property
    def works(self):
        """切换到工作信息构建器，传递同一个 person 实例"""
        return PersonJobBuilder(self.person)

    @property
    def lives(self):
        """切换到地址信息构建器，传递同一个 person 实例"""
        return PersonAddressBuilder(self.person)

    def build(self):
        """完成构建，返回最终的 Person 对象"""
        return self.person


class PersonAddressBuilder(PersonBuilder):
    """
    地址子构建器：专门负责构建 Person 的地址方面
    继承自 PersonBuilder，因此可以通过 .works 切换到工作构建器
    """
    def __init__(self, person=Person()):
        super().__init__(person)

    def at(self, street_address):
        self.person.street_address = street_address
        return self  # 返回 self 实现链式调用
    
    def with_postcode(self, postcode):
        self.person.postcode = postcode
        return self

    def in_city(self, city):
        self.person.city = city
        return self


class PersonJobBuilder(PersonBuilder):
    """
    工作子构建器：专门负责构建 Person 的工作方面
    继承自 PersonBuilder，因此可以通过 .lives 切换到地址构建器
    """
    def __init__(self, person=Person()):
        super().__init__(person)

    def at(self, company_name):
        self.person.company_name = company_name
        return self

    def as_a(self, position):
        self.person.position = position
        return self
    
    def earning(self, annual_income):
        self.person.annual_income = annual_income
        return self


def main():
    # 使用示例：通过 .lives 和 .works 在不同构建器之间无缝切换
    pb = PersonBuilder()
    person = pb\
        .lives\
            .at("123 Main St")\
            .with_postcode("12345")\
            .in_city("Anytown")\
        .works\
            .at("Google")\
            .as_a("Engineer")\
            .earning(123456)\
        .build()
    print(person)

if __name__ == "__main__":
    main()

# =============================================================================
# Builder 建造者模式 - 通过继承实现多层建造者
# =============================================================================
# 核心思想：
# 1. 将复杂对象的构建过程与其表示分离
# 2. 通过继承链，每层 Builder 负责对象的一个方面（facet）
# 3. 使用流式接口（Fluent Interface）让调用更优雅
# =============================================================================

class Person:
    """被构建的目标对象 - 包含多个需要设置的属性"""
    def __init__(self):
        self.name = None
        self.job = None
        self.date_of_birth = None

    def __str__(self):
        return f"{self.name} born on {self.date_of_birth} works as a {self.job}"

    @staticmethod
    def new():
        """工厂方法：提供统一的入口来获取建造者
        返回最底层的建造者，确保所有构建方法都可用"""
        return PersonBirthDateBuilder()


# -----------------------------------------------------------------------------
# 建造者继承链：每层负责对象的一个方面
# PersonBuilder -> PersonInfoBuilder -> PersonJobBuilder -> PersonBirthDateBuilder
# -----------------------------------------------------------------------------

class PersonBuilder:
    """基础建造者：负责创建和持有 Person 实例"""
    def __init__(self):
        self.person = Person()  # 创建待构建的对象

    def build(self):
        """终结方法：返回构建完成的对象"""
        return self.person


class PersonInfoBuilder(PersonBuilder):
    """第一层：负责个人基本信息"""
    def called(self, name):
        self.person.name = name
        return self  # 返回 self 实现链式调用


class PersonJobBuilder(PersonInfoBuilder):
    """第二层：负责工作相关信息（继承了上层的 called 方法）"""
    def works_as_a(self, job):
        self.person.job = job
        return self  # 返回 self 实现链式调用


class PersonBirthDateBuilder(PersonJobBuilder):
    """第三层：负责出生日期（继承了上层所有方法）"""
    def born(self, date_of_birth):
        self.person.date_of_birth = date_of_birth
        return self  # 返回 self 实现链式调用


def main():
    # 使用示例：通过链式调用优雅地构建对象
    # Person.new() -> 获取建造者
    # .called().works_as_a().born() -> 链式设置各属性
    # .build() -> 获取最终对象
    person = Person.new().called("John").works_as_a("Engineer").born("1990-01-01").build()
    print(person)

if __name__ == "__main__":
    main()
```

## Factory
- A componet responsibility solely for the wholesale (not piecewise) creation of objects.
    - A factory method is a static method that creates objects.
    - A factory is any entity that can take care of object creation.
    - A factory can be external or reside inside an object as an inner class.
    - Hierarchies of factories can be used to create related objects.
```python
# =============================================================================
# 工厂方法模式 (Factory Method Pattern)
# =============================================================================
# 核心思想：
#   1. 用多个语义明确的静态方法替代单一复杂的构造函数
#   2. 方法名即文档：new_cartesian_point / new_polar_point 一目了然
#   3. 参数名更准确：(x, y) vs (r, theta)，避免歧义
#   4. 遵循单一职责原则：每个工厂方法只处理一种创建逻辑
# =============================================================================

from enum import Enum
from math import *


class CoordinateSystem(Enum):
    """坐标系类型枚举（用于演示反面模式）"""
    CARTESIAN = 1  # 笛卡尔坐标系 (x, y)
    POLAR = 2      # 极坐标系 (r, θ)


class Point:
    """二维平面上的点"""

    # -------------------------------------------------------------------------
    # ❌ 反面模式：在构造函数中用枚举/标志判断逻辑
    # -------------------------------------------------------------------------
    # 问题：
    #   1. 参数语义混乱：x 有时是 x 坐标，有时是半径 r
    #   2. 需要查文档才能知道如何使用
    #   3. 违反开闭原则：新增坐标系需要修改构造函数
    # -------------------------------------------------------------------------
    # def __init__(self, x, y, system=CoordinateSystem.CARTESIAN):
    #     if system == CoordinateSystem.CARTESIAN:
    #         self.x = x
    #         self.y = y
    #     elif system == CoordinateSystem.POLAR:
    #         self.x = x * cos(y)  # x 其实是 r，y 其实是 theta
    #         self.y = x * sin(y)

    def __init__(self, x, y):
        """私有化或简化构造函数，只接受最终的笛卡尔坐标"""
        self.x = x
        self.y = y

    def __str__(self):
        return f"Point(x={self.x}, y={self.y})"

    # -------------------------------------------------------------------------
    # ✅ 工厂方法模式：用语义明确的静态方法创建对象
    # -------------------------------------------------------------------------

    @staticmethod
    def new_cartesian_point(x, y):
        """
        工厂方法：从笛卡尔坐标创建点
        参数语义明确：x 就是 x 坐标，y 就是 y 坐标
        """
        return Point(x, y)

    @staticmethod
    def new_polar_point(r, theta):
        """
        工厂方法：从极坐标创建点
        参数语义明确：r 是半径，theta 是角度（弧度）
        内部自动转换为笛卡尔坐标
        """
        return Point(r * cos(theta), r * sin(theta))


if __name__ == "__main__":
    # 使用工厂方法创建点 - 代码自解释，无需注释
    p1 = Point.new_cartesian_point(1, 2)      # 笛卡尔坐标 (1, 2)
    p2 = Point.new_polar_point(1, 2)          # 极坐标 (r=1, θ=2弧度)
    print(p1)  # Point(x=1, y=2)
    print(p2)  # Point(x=-0.416..., y=0.909...)

# =============================================================================
# 内部工厂类模式 (Inner Factory Class Pattern)
# =============================================================================
# 核心思想：
#   1. 将工厂方法封装到内部类中，保持代码组织清晰
#   2. 通过类变量暴露单例工厂实例，简化调用
#   3. 调用方式：Point.factory.new_xxx() 比静态方法更具命名空间感
#   4. 便于扩展：工厂类可以持有状态、配置或缓存
# =============================================================================

from enum import Enum
from math import *


class CoordinateSystem(Enum):
    CARTESIAN = 1
    POLAR = 2


class Point:
    """二维平面上的点"""

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return f"Point(x={self.x}, y={self.y})"

    # -------------------------------------------------------------------------
    # 内部工厂类：将所有创建逻辑集中管理
    # -------------------------------------------------------------------------
    # 优势：
    #   1. 逻辑分组：所有工厂方法在一个类中，结构清晰
    #   2. 可扩展性：工厂类可以添加状态（如缓存已创建的点）
    #   3. 命名空间：Point.factory.xxx 明确表示这是创建操作
    # -------------------------------------------------------------------------
    class PointFactory:
        """Point 的内部工厂类"""

        def new_cartesian_point(self, x, y):
            """从笛卡尔坐标 (x, y) 创建点"""
            return Point(x, y)

        def new_polar_point(self, r, theta):
            """从极坐标 (r, θ) 创建点，自动转换为笛卡尔坐标"""
            return Point(r * cos(theta), r * sin(theta))

    # -------------------------------------------------------------------------
    # 类变量：暴露一个共享的工厂实例
    # -------------------------------------------------------------------------
    # 这样用户可以直接使用 Point.factory，无需每次创建新的工厂对象
    # -------------------------------------------------------------------------
    factory = PointFactory()


# class PointFactory:
#     """Point 的外部工厂类"""

#     @staticmethod
#     def new_cartesian_point(x, y):
#         """从笛卡尔坐标 (x, y) 创建点"""
#         return Point(x, y)

#     @staticmethod
#     def new_polar_point(r, theta):
#         """从极坐标 (r, θ) 创建点，自动转换为笛卡尔坐标"""
#         return Point(r * cos(theta), r * sin(theta))

if __name__ == "__main__":
    # 三种调用方式对比：
    # p1 = Point(1, 2)                              # 直接构造（需知道是笛卡尔坐标）
    # p2 = Point.PointFactory().new_polar_point(1, 2)  # 每次创建新工厂（浪费）
    
    # ✅ 推荐方式：使用共享的工厂实例
    p1 = Point.factory.new_cartesian_point(1, 2)
    p2 = Point.factory.new_polar_point(1, 2)
    print(p1)  # Point(x=1, y=2)
    print(p2)  # Point(x=-0.416..., y=0.909...)

# =============================================================================
# 抽象工厂模式 (Abstract Factory Pattern)
# =============================================================================
# 核心思想：
#   1. 定义抽象产品接口和抽象工厂接口
#   2. 每种具体产品都有对应的具体工厂
#   3. 客户端只依赖抽象接口，不关心具体实现
#   4. 新增产品类型只需添加新的产品类和工厂类，无需修改现有代码

# 结构图
# ┌─────────────────────────────────────────────────────────┐
# │                    HotDrinkMachine                      │
# │                      (客户端)                            │
# └────────────────────────┬────────────────────────────────┘
#                          │ 使用
#                          ▼
# ┌─────────────────────────────────────────────────────────┐
# │              HotDrinkFactory (抽象工厂)                  │
# │                  + prepare(amount)                      │
# └────────────────────────┬────────────────────────────────┘
#                          │ 实现
#           ┌──────────────┴──────────────┐
#           ▼                             ▼
#    ┌─────────────┐               ┌─────────────┐
#    │ TeaFactory  │               │CoffeeFactory│
#    │ prepare()   │               │ prepare()   │
#    └──────┬──────┘               └──────┬──────┘
#           │ 创建                        │ 创建
#           ▼                             ▼
#    ┌─────────────┐               ┌─────────────┐
#    │    Tea      │               │   Coffee    │
#    └─────────────┘               └─────────────┘
# =============================================================================

from abc import ABC, abstractmethod
from enum import Enum


# =============================================================================
# 抽象产品 + 具体产品
# =============================================================================

class HotDrink(ABC):
    """抽象产品：定义所有热饮必须实现的接口"""
    @abstractmethod
    def consume(self):
        pass


class Tea(HotDrink):
    """具体产品：茶"""
    def consume(self):
        print("This tea is delicious")


class Coffee(HotDrink):
    """具体产品：咖啡"""
    def consume(self):
        print("This coffee is delicious")


# =============================================================================
# 抽象工厂 + 具体工厂
# =============================================================================

class HotDrinkFactory(ABC):
    """
    抽象工厂：定义创建产品的接口
    所有具体工厂必须实现 prepare() 方法
    """
    @abstractmethod
    def prepare(self, amount):
        pass


class TeaFactory(HotDrinkFactory):
    """具体工厂：负责创建 Tea 产品"""
    def prepare(self, amount):
        print(f"Preparing {amount}ml of tea")
        return Tea()  # 返回具体产品


class CoffeeFactory(HotDrinkFactory):
    """具体工厂：负责创建 Coffee 产品"""
    def prepare(self, amount):
        print(f"Preparing {amount}ml of coffee")
        return Coffee()  # 返回具体产品


# =============================================================================
# 客户端：热饮机（使用工厂创建产品）
# =============================================================================

class HotDrinkMachine:
    """
    热饮机：作为客户端，通过工厂创建饮品
    特点：不直接创建 Tea/Coffee，而是通过对应的工厂
    """

    class AvailableDrink(Enum):
        """可用饮品枚举：新增饮品只需在此添加"""
        TEA = "tea"
        COFFEE = "coffee"

    # -------------------------------------------------------------------------
    # 动态工厂发现机制
    # -------------------------------------------------------------------------
    # 根据枚举名自动查找对应的工厂类（如 TEA -> TeaFactory）
    # 优势：新增饮品时只需：1. 添加枚举值  2. 创建对应的工厂类
    # -------------------------------------------------------------------------
    factories = []
    for d in AvailableDrink:
        factory_name = d.name.capitalize()              # TEA -> Tea
        # 动态工厂发现：通过 globals() 获取工厂类（如 TeaFactory）
        factory_instance = globals()[factory_name + "Factory"]()  # TeaFactory()
        factories.append((d, factory_instance))

    def make_drink(self):
        """制作饮品：展示菜单 -> 用户选择 -> 工厂生产"""
        print("Available drinks:")
        for idx, (drink, factory) in enumerate(self.factories):
            print(f"{idx}: {drink.name}")

        choice = int(input("Enter drink number: "))
        amount = int(input("Enter amount: "))

        # 关键点：通过工厂的 prepare() 创建产品，而非直接 new
        return self.factories[choice][1].prepare(amount)


if __name__ == "__main__":
    machine = HotDrinkMachine()
    drink = machine.make_drink()  # 返回 HotDrink（不知道具体是 Tea 还是 Coffee）
    drink.consume()               # 多态调用

```

## Portotype
- A partially or fully initialized object that you copy (clone) and make use of.
    - To implement a prototype, partially construct an object and store it somewhere
    - Deep copy the prototype
    - Customize the resulting instance
    - A factory provides a convenient API for using prototypes
```python
# =============================================================================
# 原型模式 (Prototype Pattern)
# =============================================================================
# 核心思想：
#   1. 通过复制现有对象（原型）来创建新对象，而非从头构造
#   2. 使用 deepcopy 确保嵌套对象也被完整复制
#   3. 复制后只需修改差异部分，避免重复设置公共属性
#   4. 适用场景：对象初始化成本高，或大部分属性相同只有少量差异
# =============================================================================

import copy


class Address:
    """地址类：作为 Employee 的嵌套对象"""
    def __init__(self, street_address, suite, city):
        self.suite = suite
        self.city = city
        self.street_address = street_address

    def __str__(self):
        return f"{self.street_address}, Suite #{self.suite}, {self.city}"


class Employee:
    """员工类：包含嵌套的 Address 对象"""
    def __init__(self, name, address):
        self.name = name
        self.address = address  # 嵌套对象，浅拷贝会出问题！

    def __str__(self):
        return f"{self.name} works at {self.address}"


class EmployeeFactory:
    """
    员工工厂：使用原型模式创建员工
    预定义原型对象，通过深拷贝 + 定制来创建新实例
    """

    # -------------------------------------------------------------------------
    # 原型对象：预设公司不同办公室的员工模板
    # -------------------------------------------------------------------------
    # 这些对象作为"模板"，包含固定的公司地址信息
    # 创建新员工时只需复制模板，然后填入个人信息
    # -------------------------------------------------------------------------
    main_office_employee = Employee(
        name="",
        address=Address(street_address="123 East Dr", suite=0, city="London")
    )
    aux_office_employee = Employee(
        name="",
        address=Address(street_address="123B East Dr", suite=0, city="London")
    )

    @staticmethod
    def __new_employee(proto, name, suite):
        """
        核心方法：从原型创建新员工

        关键点：必须用 deepcopy！
        - 浅拷贝 (copy.copy)：只复制顶层对象，嵌套的 Address 仍是同一个引用
        - 深拷贝 (copy.deepcopy)：递归复制所有嵌套对象，完全独立
        """
        result = copy.deepcopy(proto)  # ← 深拷贝原型
        result.name = name             # 定制：设置员工姓名
        result.address.suite = suite   # 定制：设置房间号
        return result

    @staticmethod
    def new_main_office_employee(name, suite):
        """工厂方法：创建主办公室员工"""
        return EmployeeFactory.__new_employee(
            EmployeeFactory.main_office_employee, name, suite
        )

    @staticmethod
    def new_aux_office_employee(name, suite):
        """工厂方法：创建分办公室员工"""
        return EmployeeFactory.__new_employee(
            EmployeeFactory.aux_office_employee, name, suite
        )


if __name__ == "__main__":
    # 创建两个不同办公室的员工
    john = EmployeeFactory.new_main_office_employee("John", 101)
    jane = EmployeeFactory.new_aux_office_employee("Jane", 102)

    print(john)  # John works at 123 East Dr, Suite #101, London
    print(jane)  # Jane works at 123B East Dr, Suite #102, London

# 为什么必须用 deepcopy
浅拷贝 (copy.copy)                    深拷贝 (copy.deepcopy)
┌─────────────┐                      ┌─────────────┐
│  john       │                      │  john       │
│  name: John │                      │  name: John │
│  address: ──┼──┐                   │  address: ──┼──► Address(101)
└─────────────┘  │                   └─────────────┘
                 ▼
┌─────────────┐  ┌──────────┐        ┌─────────────┐
│  jane       │  │ Address  │        │  jane       │
│  name: Jane │  │ suite:102│        │  name: Jane │
│  address: ──┼──┘ (共享!)  │        │  address: ──┼──► Address(102)
└─────────────┘  └──────────┘        └─────────────┘
❌ 修改 jane 会影响 john!            ✅ 完全独立

# 原型模式 vs 普通构造
# ❌ 普通构造：每次都要写完整地址
john = Employee("John", Address("123 East Dr", 101, "London"))
jane = Employee("Jane", Address("123 East Dr", 102, "London"))  # 重复！

# ✅ 原型模式：复制模板 + 定制差异
john = EmployeeFactory.new_main_office_employee("John", 101)
jane = EmployeeFactory.new_main_office_employee("Jane", 102)
```

## Singleton
- A component which is instantiated only once.

- Motivation
    - For some components it only makes sense to have one in the system, such as Database repository
    - the initializer call is expensive
        - We only do it once
        - We provide everyone with the same instance
        - Want to prevent anyone creating additional copies
        - Need to take care of lazy instantiation

```python
```

## DDD
![领域驱动设计](./design_patterns/Domain_Driven_Design_in_C.md)  
![]()  
![]()  
1. 什么是 DDD
    DDD 核心理念：让代码"说业务语言"，业务驱动而非技术驱动
2. DDD 核心概念
    实体、值对象、聚合、聚合根、仓储、领域服务、领域事件
3. 传统方式 vs DDD 对比
    以数据为中心 vs 以领域为中心的代码对比

- DDD 核心概念
```
┌─────────────────────────────────────────────────────────┐
│                    Aggregate (聚合)                     │
│                                                         │
│   ┌───────────────────────────────────────────────┐     │
│   │        Aggregate Root (聚合根)                │     │
│   │        Order (订单)                           │     │
│   │                                               │     │
│   │   + confirm()   (业务方法)                    │     │
│   │   + cancel()                                  │     │
│   │   + add_item()                                │     │
│   └───────────────────────────────────────────────┘     │
│                         │                               │
│                         ▼                               │
│   ┌───────────────────────────────────────────────┐     │
│   │        Entity (实体) - OrderItem              │     │
│   │        Value Object (值对象) - Money          │     │
│   └───────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────┘
```

- 示例代码结构
```
order_system/
├── domain/              # 领域层 - 核心业务逻辑
│   ├── order.h/c        # 订单聚合根
│   ├── order_item.h/c   # 订单项实体
│   ├── money.h/c        # 金额值对象
│   └── order_events.h   # 领域事件
├── repository/          # 仓储层 - 持久化
│   └── order_repository.h/c
├── service/             # 应用服务层
│   └── order_service.h/c
└── main.c               # 演示程序
```

- DDD 的 5 大好处
好处	        说明
业务逻辑集中	 所有规则在领域对象中，修改只需改一处
代码即文档	     order_confirm() 比 UPDATE status=1 更易懂
易于测试	    不依赖数据库，毫秒级单元测试
技术解耦	    换数据库不改业务代码
统一语言	    业务人员和开发人员使用相同术语