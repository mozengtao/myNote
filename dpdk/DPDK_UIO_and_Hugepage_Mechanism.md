# DPDK 网卡直接访问 Huge Page 的核心机制

## 目录

1. [核心问题回答](#1-核心问题回答)
2. [传统内核网络栈 vs DPDK](#2-传统内核网络栈-vs-dpdk)
3. [UIO/VFIO 驱动机制](#3-uiovfio-驱动机制)
4. [DMA 和 IOMMU 机制](#4-dma-和-iommu-机制)
5. [Huge Page 内存映射](#5-huge-page-内存映射)
6. [完整数据流详解](#6-完整数据流详解)
7. [关键代码分析](#7-关键代码分析)

---

## 1. 核心问题回答

### 1.1 是什么决定了网卡不发送给内核协议栈？

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                    What Determines Packet Destination?                                  │
└─────────────────────────────────────────────────────────────────────────────────────────┘

                              ┌─────────────────────┐
                              │    NIC Hardware     │
                              │  (Network Card)     │
                              └──────────┬──────────┘
                                         │
                                         │  Packet Received
                                         │
                                         ▼
                    ┌────────────────────────────────────────┐
                    │         Which Driver is Bound?         │
                    │                                        │
                    │   Driver binding determines the path   │
                    └────────────────────┬───────────────────┘
                                         │
                    ┌────────────────────┴────────────────────┐
                    │                                         │
                    ▼                                         ▼
        ┌───────────────────────────┐           ┌───────────────────────────┐
        │   Kernel Driver Bound     │           │   UIO/VFIO Driver Bound   │
        │   (e.g., ixgbe, i40e)     │           │   (igb_uio, vfio-pci)     │
        └─────────────┬─────────────┘           └─────────────┬─────────────┘
                      │                                       │
                      ▼                                       ▼
        ┌───────────────────────────┐           ┌───────────────────────────┐
        │    KERNEL SPACE           │           │    USER SPACE             │
        │                           │           │                           │
        │   - Interrupt handler     │           │   - PMD polling           │
        │   - sk_buff allocation    │           │   - Direct DMA access     │
        │   - Protocol stack        │           │   - Huge page buffers     │
        │   - Socket API            │           │   - Zero copy             │
        └───────────────────────────┘           └───────────────────────────┘
```

**关键答案**：

1. **驱动绑定决定数据包去向**
   - 网卡本身不知道数据包应该去哪里
   - 是**绑定到网卡的驱动程序**决定了数据包的处理路径
   - 使用内核驱动 → 数据包进入内核协议栈
   - 使用 UIO/VFIO 驱动 → 数据包直接到用户空间

2. **DPDK 通过解绑内核驱动、绑定 UIO/VFIO 驱动来"劫持"网卡**

3. **DMA 地址配置决定数据写入位置**
   - 驱动程序配置网卡的 DMA 描述符
   - 描述符中包含目标内存的物理地址
   - 网卡 DMA 引擎按照描述符将数据写入指定位置

---

## 2. 传统内核网络栈 vs DPDK

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                    Traditional Kernel Network Stack                                     │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                              HARDWARE                                               │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                              NIC                                            │   │
    │   │   1. Packet arrives                                                         │   │
    │   │   2. DMA to kernel buffer (sk_buff)                                         │   │
    │   │   3. Raise hardware interrupt (IRQ)                                         │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    └─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         │ Hardware Interrupt
                                         ▼
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                              KERNEL SPACE                                           │
    │                                                                                     │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │  4. Interrupt Handler (Top Half)                                            │   │
    │   │     - Acknowledge interrupt                                                 │   │
    │   │     - Schedule softirq/NAPI                                                 │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                         │                                           │
    │                                         ▼                                           │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │  5. NAPI Poll (Bottom Half)                                                 │   │
    │   │     - Allocate sk_buff                                                      │   │
    │   │     - Copy data from DMA buffer                                             │   │
    │   │     - Pass to network stack                                                 │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                         │                                           │
    │                                         ▼                                           │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │  6. Protocol Stack Processing                                               │   │
    │   │     - L2: Ethernet header parsing                                           │   │
    │   │     - L3: IP routing, filtering                                             │   │
    │   │     - L4: TCP/UDP processing                                                │   │
    │   │     - Socket buffer queuing                                                 │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                         │                                           │
    └─────────────────────────────────────────┼───────────────────────────────────────────┘
                                              │ System Call (recv/read)
                                              │ Context Switch
                                              │ Memory Copy
                                              ▼
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                              USER SPACE                                             │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │  7. Application                                                             │   │
    │   │     - recv() / read() system call                                           │   │
    │   │     - Data copied to user buffer                                            │   │
    │   │     - Process packet                                                        │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    └─────────────────────────────────────────────────────────────────────────────────────┘

    OVERHEAD:
    - Hardware interrupt handling
    - Context switches (interrupt -> softirq -> user)
    - Multiple memory copies (DMA buffer -> sk_buff -> socket buffer -> user buffer)
    - Lock contention in protocol stack
    - Per-packet memory allocation
```

**说明**：
- 传统方式中，内核驱动注册中断处理程序
- 数据包到达触发硬件中断
- 经过多层协议栈处理
- 应用程序通过系统调用获取数据，涉及内存拷贝

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                           DPDK User Space Processing                                    │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                              HARDWARE                                               │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                              NIC                                            │   │
    │   │   1. Packet arrives                                                         │   │
    │   │   2. DMA directly to Huge Page (user space mapped)                          │   │
    │   │   3. NO interrupt (or interrupt disabled)                                   │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    └─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         │ Direct DMA
                                         │ (No interrupt, No kernel involvement)
                                         ▼
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                              USER SPACE                                             │
    │                                                                                     │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                         Huge Pages Memory                                   │   │
    │   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
    │   │   │                         MEMPOOL                                     │   │   │
    │   │   │   ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐               │   │   │
    │   │   │   │  mbuf   │  │  mbuf   │  │  mbuf   │  │  mbuf   │  ...          │   │   │
    │   │   │   │[pkt data]│ │[pkt data]│ │[pkt data]│ │[pkt data]│              │   │   │
    │   │   │   └─────────┘  └─────────┘  └─────────┘  └─────────┘               │   │   │
    │   │   │        ▲                                                            │   │   │
    │   │   │        │ DMA writes here                                            │   │   │
    │   │   └────────┼────────────────────────────────────────────────────────────┘   │   │
    │   └────────────┼────────────────────────────────────────────────────────────────┘   │
    │                │                                                                    │
    │   ┌────────────┼────────────────────────────────────────────────────────────────┐   │
    │   │  3. PMD Polling                                                             │   │
    │   │     - No interrupt, continuous polling                                      │   │
    │   │     - Check RX descriptor ring                                              │   │
    │   │     - If packet ready, process directly                                     │   │
    │   │                                                                             │   │
    │   │  4. Application Processing                                                  │   │
    │   │     - Direct access to packet data in mbuf                                  │   │
    │   │     - Zero copy processing                                                  │   │
    │   │     - No system calls needed                                                │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘

    ADVANTAGES:
    - No hardware interrupts
    - No context switches
    - Zero memory copies
    - No kernel involvement
    - Predictable latency
```

**说明**：
- DPDK 绑定 UIO/VFIO 驱动后，网卡中断被禁用
- DMA 直接写入用户空间的 Huge Page
- 应用程序轮询检查数据包，无需系统调用

---

## 3. UIO/VFIO 驱动机制

### 3.1 驱动绑定过程

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                         Driver Binding Process                                          │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    STEP 1: Unbind Kernel Driver
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   # Check current driver                                                            │
    │   $ lspci -k -s 0000:3b:00.0                                                        │
    │   03:00.0 Ethernet controller: Intel Corporation ...                                │
    │           Kernel driver in use: ixgbe        <-- Kernel driver bound                │
    │                                                                                     │
    │   # Unbind from kernel driver                                                       │
    │   $ echo "0000:3b:00.0" > /sys/bus/pci/drivers/ixgbe/unbind                         │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
    STEP 2: Bind UIO/VFIO Driver
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   # Load UIO driver module                                                          │
    │   $ modprobe uio_pci_generic                                                        │
    │   # or                                                                              │
    │   $ modprobe vfio-pci                                                               │
    │                                                                                     │
    │   # Bind to UIO/VFIO driver                                                         │
    │   $ echo "8086 1528" > /sys/bus/pci/drivers/uio_pci_generic/new_id                  │
    │   $ echo "0000:3b:00.0" > /sys/bus/pci/drivers/uio_pci_generic/bind                 │
    │                                                                                     │
    │   # Or use DPDK tool                                                                │
    │   $ dpdk-devbind.py --bind=vfio-pci 0000:3b:00.0                                    │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
    STEP 3: Device Now Accessible from User Space
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   $ ls -la /dev/uio0                                                                │
    │   crw-rw---- 1 root root 243, 0 ... /dev/uio0                                       │
    │                                                                                     │
    │   # Or for VFIO                                                                     │
    │   $ ls -la /dev/vfio/                                                               │
    │   crw-rw---- 1 root root 243, 0 ... /dev/vfio/vfio                                  │
    │   crw-rw---- 1 root root 243, 1 ... /dev/vfio/42                                    │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
```

**说明**：
- 首先解绑内核原生驱动（如 ixgbe）
- 然后绑定 UIO 或 VFIO 驱动
- 绑定后，设备通过 `/dev/uio*` 或 `/dev/vfio/*` 暴露给用户空间

### 3.2 UIO 机制详解

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                         UIO (Userspace I/O) Architecture                                │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                              USER SPACE                                             │
    │                                                                                     │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                         DPDK Application                                    │   │
    │   │                                                                             │   │
    │   │   ┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐     │   │
    │   │   │  PMD Driver     │      │  Memory Map     │      │  DMA Setup      │     │   │
    │   │   │  (Poll Mode)    │      │  (mmap)         │      │  (ioctl)        │     │   │
    │   │   └────────┬────────┘      └────────┬────────┘      └────────┬────────┘     │   │
    │   │            │                        │                        │              │   │
    │   └────────────┼────────────────────────┼────────────────────────┼──────────────┘   │
    │                │                        │                        │                  │
    └────────────────┼────────────────────────┼────────────────────────┼──────────────────┘
                     │                        │                        │
                     │ open("/dev/uio0")      │ mmap()                 │ ioctl()
                     │                        │                        │
    ┌────────────────┼────────────────────────┼────────────────────────┼──────────────────┐
    │                │                        │                        │                  │
    │   ┌────────────▼────────────────────────▼────────────────────────▼──────────────┐   │
    │   │                         UIO Kernel Module                                   │   │
    │   │                         (uio_pci_generic / igb_uio)                         │   │
    │   │                                                                             │   │
    │   │   Functions:                                                                │   │
    │   │   1. Register PCI device                                                    │   │
    │   │   2. Map device BAR regions to user space                                   │   │
    │   │   3. Handle interrupt (optional, can be disabled)                           │   │
    │   │   4. Provide /dev/uioX interface                                            │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                                                                     │
    │                              KERNEL SPACE                                           │
    └─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         │
    ┌────────────────────────────────────┼────────────────────────────────────────────────┐
    │                                    │                                                │
    │   ┌────────────────────────────────▼────────────────────────────────────────────┐   │
    │   │                              NIC                                            │   │
    │   │                                                                             │   │
    │   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
    │   │   │                    BAR (Base Address Register)                      │   │   │
    │   │   │                                                                     │   │   │
    │   │   │   BAR0: Control/Status Registers (CSR)                              │   │   │
    │   │   │         - Mapped to user space via mmap()                           │   │   │
    │   │   │         - PMD can directly read/write registers                     │   │   │
    │   │   │                                                                     │   │   │
    │   │   │   BAR2: Doorbell Registers                                          │   │   │
    │   │   │         - Notify NIC of new TX/RX descriptors                       │   │   │
    │   │   │                                                                     │   │   │
    │   │   └─────────────────────────────────────────────────────────────────────┘   │   │
    │   │                                                                             │   │
    │   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
    │   │   │                    DMA Engine                                       │   │   │
    │   │   │                                                                     │   │   │
    │   │   │   - Reads/Writes directly to physical memory                        │   │   │
    │   │   │   - Address configured via descriptor rings                         │   │   │
    │   │   │   - No CPU involvement in data transfer                             │   │   │
    │   │   │                                                                     │   │   │
    │   │   └─────────────────────────────────────────────────────────────────────┘   │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                                                                     │
    │                              HARDWARE                                               │
    └─────────────────────────────────────────────────────────────────────────────────────┘
```

**说明**：
- UIO 模块将网卡的 BAR（Base Address Register）区域映射到用户空间
- 用户空间程序通过 `mmap()` 直接访问网卡寄存器
- PMD 驱动可以直接读写网卡控制寄存器，配置 DMA 描述符

### 3.3 VFIO 机制（更安全）

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                         VFIO (Virtual Function I/O) Architecture                        │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                              USER SPACE                                             │
    │                                                                                     │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                         DPDK Application                                    │   │
    │   │                                                                             │   │
    │   │   open("/dev/vfio/vfio")     ──►  VFIO Container                            │   │
    │   │   open("/dev/vfio/<group>")  ──►  VFIO Group                                │   │
    │   │   ioctl(GET_DEVICE_FD)       ──►  Device FD                                 │   │
    │   │   ioctl(VFIO_DEVICE_GET_REGION_INFO)  ──►  BAR info                         │   │
    │   │   mmap(device_fd, BAR_offset)         ──►  Direct register access           │   │
    │   │   ioctl(VFIO_IOMMU_MAP_DMA)           ──►  Setup DMA mapping                │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
    ┌────────────────────────────────────┼────────────────────────────────────────────────┐
    │                                    │                                                │
    │   ┌────────────────────────────────▼────────────────────────────────────────────┐   │
    │   │                         VFIO Kernel Module                                  │   │
    │   │                                                                             │   │
    │   │   Key Differences from UIO:                                                 │   │
    │   │                                                                             │   │
    │   │   1. IOMMU Integration                                                      │   │
    │   │      - Uses hardware IOMMU for DMA address translation                      │   │
    │   │      - Provides memory isolation and protection                             │   │
    │   │      - Device can only access explicitly mapped memory                      │   │
    │   │                                                                             │   │
    │   │   2. Group-based Access Control                                             │   │
    │   │      - Devices grouped by IOMMU domain                                      │   │
    │   │      - Better security model                                                │   │
    │   │                                                                             │   │
    │   │   3. No Root Required (with proper permissions)                             │   │
    │   │      - Can run DPDK as non-root user                                        │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                         │                                           │
    │   ┌─────────────────────────────────────▼───────────────────────────────────────┐   │
    │   │                              IOMMU                                          │   │
    │   │                                                                             │   │
    │   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
    │   │   │              IOVA (I/O Virtual Address) Translation                 │   │   │
    │   │   │                                                                     │   │   │
    │   │   │   User Space      IOMMU Page        Physical                        │   │   │
    │   │   │   Virtual Addr    Table             Address                         │   │   │
    │   │   │                                                                     │   │   │
    │   │   │   0x7f0000000  ──►  [Entry]  ──►  0x100000000 (Huge Page)           │   │   │
    │   │   │                                                                     │   │   │
    │   │   │   Device DMA uses IOVA, IOMMU translates to physical                │   │   │
    │   │   │                                                                     │   │   │
    │   │   └─────────────────────────────────────────────────────────────────────┘   │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                                                                     │
    │                              KERNEL SPACE                                           │
    └─────────────────────────────────────────────────────────────────────────────────────┘
```

**说明**：
- VFIO 使用 IOMMU 进行 DMA 地址转换和内存保护
- 设备只能访问显式映射的内存区域，更安全
- 支持非 root 用户运行 DPDK

---

## 4. DMA 和 IOMMU 机制

### 4.1 DMA 描述符环

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                         DMA Descriptor Ring Mechanism                                   │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                         RX Descriptor Ring                                          │
    │                                                                                     │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                                                                             │   │
    │   │        HEAD (NIC writes here)                                               │   │
    │   │           │                                                                 │   │
    │   │           ▼                                                                 │   │
    │   │   ┌───────┬───────┬───────┬───────┬───────┬───────┬───────┬───────┐         │   │
    │   │   │ Desc0 │ Desc1 │ Desc2 │ Desc3 │ Desc4 │ Desc5 │ Desc6 │ Desc7 │  ...    │   │
    │   │   └───┬───┴───┬───┴───┬───┴───────┴───────┴───────┴───────┴───────┘         │   │
    │   │       │       │       │                                                     │   │
    │   │       ▼       ▼       ▼                                                     │   │
    │   │   ┌───────┐┌───────┐┌───────┐                                               │   │
    │   │   │ mbuf0 ││ mbuf1 ││ mbuf2 │  ... (in Huge Pages)                          │   │
    │   │   │[data] ││[data] ││[data] │                                               │   │
    │   │   └───────┘└───────┘└───────┘                                               │   │
    │   │       ▲                                                                     │   │
    │   │       │                                                                     │   │
    │   │    TAIL (Software updates here)                                             │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                                                                     │
    │   Descriptor Structure:                                                             │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                                                                             │   │
    │   │   struct rx_descriptor {                                                    │   │
    │   │       uint64_t  buffer_addr;    /* Physical address of mbuf data */         │   │
    │   │       uint64_t  header_addr;    /* Header buffer address (optional) */      │   │
    │   │   };                                                                        │   │
    │   │                                                                             │   │
    │   │   struct rx_descriptor_wb {     /* Write-back by NIC after DMA */           │   │
    │   │       uint32_t  status;         /* DD bit indicates packet ready */         │   │
    │   │       uint16_t  length;         /* Packet length */                         │   │
    │   │       uint16_t  vlan_tag;       /* VLAN tag if present */                   │   │
    │   │   };                                                                        │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
```

**说明**：
- 描述符环是网卡和软件之间的共享数据结构
- 每个描述符包含一个 mbuf 数据缓冲区的**物理地址**
- 网卡 DMA 引擎按照描述符中的地址写入数据
- DD (Descriptor Done) 位标识数据包已就绪

### 4.2 DMA 地址转换

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                         DMA Address Translation                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    WITHOUT IOMMU (UIO):
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   User Space                                                                        │
    │   Virtual Address        Physical Address                                           │
    │                                                                                     │
    │   0x7f0000000000   ────────────────────────►   0x100000000                          │
    │        │                                            │                               │
    │        │ Application                                │ NIC DMA                       │
    │        │ accesses via                               │ accesses via                  │
    │        │ virtual addr                               │ physical addr                 │
    │        │                                            │                               │
    │        ▼                                            ▼                               │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                         Huge Page Memory                                    │   │
    │   │                         (2MB or 1GB page)                                   │   │
    │   │                                                                             │   │
    │   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
    │   │   │                    mbuf + packet data                               │   │   │
    │   │   └─────────────────────────────────────────────────────────────────────┘   │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                                                                     │
    │   Key: DPDK uses rte_mem_virt2phy() to get physical address for DMA descriptors     │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘


    WITH IOMMU (VFIO):
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   User Space          IOMMU              Physical                                   │
    │   Virtual Addr        (IOVA)             Address                                    │
    │                                                                                     │
    │   0x7f0000000000  ──►  0x1000000  ──►  0x100000000                                  │
    │        │                  │                 │                                       │
    │        │ App              │ NIC DMA         │ Actual                                │
    │        │ access           │ uses IOVA       │ memory                                │
    │        │                  │                 │                                       │
    │        ▼                  ▼                 ▼                                       │
    │   ┌──────────┐      ┌──────────┐      ┌──────────┐                                  │
    │   │  MMU     │      │  IOMMU   │      │  Huge    │                                  │
    │   │  Page    │      │  Page    │      │  Page    │                                  │
    │   │  Table   │      │  Table   │      │  Memory  │                                  │
    │   └──────────┘      └──────────┘      └──────────┘                                  │
    │                                                                                     │
    │   IOMMU provides:                                                                   │
    │   - Address translation for device DMA                                              │
    │   - Memory isolation (device can only access mapped regions)                        │
    │   - Protection against DMA attacks                                                  │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
```

**说明**：
- 无 IOMMU 时，描述符直接使用物理地址
- 有 IOMMU 时，使用 IOVA（I/O 虚拟地址），由 IOMMU 硬件转换
- DPDK 通过 `rte_mem_virt2phy()` 或 `rte_mem_virt2iova()` 获取 DMA 地址

---

## 5. Huge Page 内存映射

### 5.1 为什么使用 Huge Page

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                         Why Huge Pages?                                                 │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    Regular 4KB Pages:
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   Virtual Address Space (1GB example):                                              │
    │                                                                                     │
    │   ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐                                 │
    │   │P0│P1│P2│P3│P4│P5│P6│P7│P8│P9│..│..│..│..│..│Pn│  262,144 pages!                │
    │   └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘                                 │
    │                                                                                     │
    │   Page Table Entries: 262,144 (for 1GB)                                             │
    │   TLB Entries: Limited (~1000)                                                      │
    │   TLB Miss Rate: HIGH (frequent page table walks)                                   │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘


    2MB Huge Pages:
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   Virtual Address Space (1GB example):                                              │
    │                                                                                     │
    │   ┌──────────┬──────────┬──────────┬──────────┬──────────┐                          │
    │   │  Page 0  │  Page 1  │  Page 2  │  ...     │ Page 511 │  512 pages only!         │
    │   │   2MB    │   2MB    │   2MB    │          │   2MB    │                          │
    │   └──────────┴──────────┴──────────┴──────────┴──────────┘                          │
    │                                                                                     │
    │   Page Table Entries: 512 (for 1GB)                                                 │
    │   TLB Entries: Can cover entire working set                                         │
    │   TLB Miss Rate: LOW (fewer page table walks)                                       │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘


    1GB Huge Pages:
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   Virtual Address Space (1GB example):                                              │
    │                                                                                     │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                            Single 1GB Page                                  │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                                                                     │
    │   Page Table Entries: 1                                                             │
    │   TLB Entries: 1                                                                    │
    │   TLB Miss Rate: ZERO (for this region)                                             │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘


    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   Additional Benefits of Huge Pages:                                                │
    │                                                                                     │
    │   1. Contiguous Physical Memory                                                     │
    │      - Easier DMA setup (single physical address range)                             │
    │      - Better cache line utilization                                                │
    │                                                                                     │
    │   2. Reduced Page Table Overhead                                                    │
    │      - Less memory for page tables                                                  │
    │      - Faster address translation                                                   │
    │                                                                                     │
    │   3. Pinned Memory                                                                  │
    │      - Huge pages are not swappable                                                 │
    │      - Guaranteed physical memory availability                                      │
    │      - No page faults during DMA                                                    │
    │                                                                                     │
    │   4. NUMA Awareness                                                                 │
    │      - Can allocate on specific NUMA node                                           │
    │      - Minimize cross-node memory access                                            │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
```

**说明**：
- Huge Page 大幅减少页表项数量
- TLB（Translation Lookaside Buffer）命中率提高
- 物理内存连续，便于 DMA 配置
- Huge Page 不会被换出到磁盘，保证 DMA 安全

### 5.2 Huge Page 映射过程

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                         Huge Page Mapping Process                                       │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    STEP 1: Reserve Huge Pages (System Boot or Runtime)
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   # Reserve 1024 2MB huge pages                                                     │
    │   $ echo 1024 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages              │
    │                                                                                     │
    │   # Or via kernel boot parameter                                                    │
    │   hugepages=1024 hugepagesz=2M                                                      │
    │                                                                                     │
    │   # Mount hugetlbfs                                                                 │
    │   $ mount -t hugetlbfs nodev /dev/hugepages                                         │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
    STEP 2: DPDK EAL Initialization
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   rte_eal_init() internally:                                                        │
    │                                                                                     │
    │   1. Scan /sys/kernel/mm/hugepages/ for available huge pages                        │
    │                                                                                     │
    │   2. Create memory files in hugetlbfs:                                              │
    │      /dev/hugepages/rtemap_0, rtemap_1, ...                                         │
    │                                                                                     │
    │   3. mmap() each huge page file:                                                    │
    │      void *addr = mmap(NULL, hugepage_size,                                         │
    │                        PROT_READ | PROT_WRITE,                                      │
    │                        MAP_SHARED | MAP_POPULATE,                                   │
    │                        fd, 0);                                                      │
    │                                                                                     │
    │   4. Lock pages in memory:                                                          │
    │      mlock(addr, hugepage_size);                                                    │
    │                                                                                     │
    │   5. Get physical addresses:                                                        │
    │      Read /proc/self/pagemap to get physical page frame numbers                     │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
    STEP 3: Memory Zone and Mempool Creation
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                         Huge Page Memory Layout                             │   │
    │   │                                                                             │   │
    │   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
    │   │   │                    Memory Zone 0 (NUMA 0)                           │   │   │
    │   │   │                                                                     │   │   │
    │   │   │   ┌───────────────────────────────────────────────────────────┐     │   │   │
    │   │   │   │                    MEMPOOL                                │     │   │   │
    │   │   │   │                                                           │     │   │   │
    │   │   │   │   ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐      │     │   │   │
    │   │   │   │   │  mbuf   │  │  mbuf   │  │  mbuf   │  │  mbuf   │ ...  │     │   │   │
    │   │   │   │   │ VA:0x7f │  │ VA:0x7f │  │ VA:0x7f │  │ VA:0x7f │      │     │   │   │
    │   │   │   │   │ PA:0x10 │  │ PA:0x10 │  │ PA:0x10 │  │ PA:0x10 │      │     │   │   │
    │   │   │   │   └─────────┘  └─────────┘  └─────────┘  └─────────┘      │     │   │   │
    │   │   │   │                                                           │     │   │   │
    │   │   │   └───────────────────────────────────────────────────────────┘     │   │   │
    │   │   │                                                                     │   │   │
    │   │   │   ┌───────────────────────────────────────────────────────────┐     │   │   │
    │   │   │   │                    Ring Buffers                           │     │   │   │
    │   │   │   │                    Descriptor Arrays                      │     │   │   │
    │   │   │   │                    Other Structures                       │     │   │   │
    │   │   │   └───────────────────────────────────────────────────────────┘     │   │   │
    │   │   │                                                                     │   │   │
    │   │   └─────────────────────────────────────────────────────────────────────┘   │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
```

**说明**：
- 系统启动时或运行时预留 Huge Page
- DPDK EAL 初始化时映射 Huge Page 到用户空间
- 每个 mbuf 都有对应的虚拟地址和物理地址
- 物理地址用于配置 DMA 描述符

---

## 6. 完整数据流详解

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                         Complete Data Flow: Packet Reception                            │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    INITIALIZATION PHASE:
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   1. DPDK allocates mbufs from mempool (in Huge Pages)                              │
    │                                                                                     │
    │   2. For each mbuf, get physical address:                                           │
    │      phys_addr = rte_mem_virt2phy(mbuf->buf_addr);                                  │
    │                                                                                     │
    │   3. Fill RX descriptor with physical address:                                      │
    │      rx_desc[i].buffer_addr = phys_addr;                                            │
    │                                                                                     │
    │   4. Update RX tail register to tell NIC descriptors are ready:                     │
    │      NIC_REG_WRITE(RDT, n_descriptors);                                             │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘


    PACKET RECEPTION:
    
    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │                              NETWORK WIRE                                           │
    │                                   │                                                 │
    │                                   │ Packet arrives                                  │
    │                                   ▼                                                 │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                              NIC                                            │   │
    │   │                                                                             │   │
    │   │   1. Packet received in NIC internal buffer                                 │   │
    │   │                                                                             │   │
    │   │   2. NIC reads RX descriptor at HEAD pointer:                               │   │
    │   │      buffer_addr = rx_desc[HEAD].buffer_addr;  // Physical address          │   │
    │   │                                                                             │   │
    │   │   3. NIC DMA engine writes packet data:                                     │   │
    │   │      DMA_WRITE(buffer_addr, packet_data, packet_len);                       │   │
    │   │      // Direct write to Huge Page memory!                                   │   │
    │   │                                                                             │   │
    │   │   4. NIC updates descriptor with status and length:                         │   │
    │   │      rx_desc[HEAD].status = DD;  // Descriptor Done                         │   │
    │   │      rx_desc[HEAD].length = packet_len;                                     │   │
    │   │                                                                             │   │
    │   │   5. NIC advances HEAD pointer:                                             │   │
    │   │      HEAD = (HEAD + 1) % RING_SIZE;                                         │   │
    │   │                                                                             │   │
    │   │   6. NO INTERRUPT! (interrupt disabled for PMD)                             │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                   │                                                 │
    │                                   │ DMA Write (physical address)                    │
    │                                   ▼                                                 │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                         HUGE PAGE MEMORY                                    │   │
    │   │                                                                             │   │
    │   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
    │   │   │                    mbuf (packet buffer)                             │   │   │
    │   │   │                                                                     │   │   │
    │   │   │   Physical Addr: 0x100000000                                        │   │   │
    │   │   │   Virtual Addr:  0x7f0000000000                                     │   │   │
    │   │   │                                                                     │   │   │
    │   │   │   ┌─────────────────────────────────────────────────────────────┐   │   │   │
    │   │   │   │  [headroom]  [PACKET DATA - written by DMA]  [tailroom]     │   │   │   │
    │   │   │   └─────────────────────────────────────────────────────────────┘   │   │   │
    │   │   │                                                                     │   │   │
    │   │   └─────────────────────────────────────────────────────────────────────┘   │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                   │                                                 │
    │                                   │ Same memory, different address view             │
    │                                   ▼                                                 │
    │   ┌─────────────────────────────────────────────────────────────────────────────┐   │
    │   │                         USER SPACE APPLICATION                              │   │
    │   │                                                                             │   │
    │   │   PMD Polling Loop:                                                         │   │
    │   │                                                                             │   │
    │   │   while (1) {                                                               │   │
    │   │       // Check descriptor status                                            │   │
    │   │       if (rx_desc[TAIL].status & DD) {                                      │   │
    │   │           // Packet is ready!                                               │   │
    │   │                                                                             │   │
    │   │           // Get mbuf pointer (virtual address)                             │   │
    │   │           mbuf = rx_mbufs[TAIL];                                            │   │
    │   │                                                                             │   │
    │   │           // Access packet data directly (ZERO COPY!)                       │   │
    │   │           data = rte_pktmbuf_mtod(mbuf, void *);                            │   │
    │   │                                                                             │   │
    │   │           // Process packet...                                              │   │
    │   │           process_packet(mbuf);                                             │   │
    │   │                                                                             │   │
    │   │           // Advance TAIL                                                   │   │
    │   │           TAIL = (TAIL + 1) % RING_SIZE;                                    │   │
    │   │       }                                                                     │   │
    │   │   }                                                                         │   │
    │   │                                                                             │   │
    │   └─────────────────────────────────────────────────────────────────────────────┘   │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
```

**说明**：
- 初始化时，DPDK 将 mbuf 的物理地址填入 RX 描述符
- 网卡 DMA 引擎按照描述符中的物理地址写入数据
- 应用程序通过虚拟地址访问同一块内存
- 整个过程无需内核参与，无需内存拷贝

---

## 7. 关键代码分析

### 7.1 获取物理地址

```c
/* DPDK 获取虚拟地址对应的物理地址 */

/* 方法1: 通过 /proc/self/pagemap */
phys_addr_t
rte_mem_virt2phy(const void *virtaddr)
{
    int fd;
    uint64_t page, physaddr;
    unsigned long virt_pfn;
    int page_size;

    /* 打开 pagemap 文件 */
    fd = open("/proc/self/pagemap", O_RDONLY);
    
    page_size = getpagesize();
    
    /* 计算虚拟页帧号 */
    virt_pfn = (unsigned long)virtaddr / page_size;
    
    /* 读取对应的页表项 */
    lseek(fd, virt_pfn * sizeof(uint64_t), SEEK_SET);
    read(fd, &page, sizeof(uint64_t));
    
    /* 提取物理页帧号 */
    physaddr = ((page & 0x7fffffffffffffULL) * page_size)
               + ((unsigned long)virtaddr % page_size);
    
    close(fd);
    return physaddr;
}

/* 方法2: 对于 VFIO，使用 IOVA */
rte_iova_t
rte_mem_virt2iova(const void *virtaddr)
{
    if (rte_eal_iova_mode() == RTE_IOVA_VA)
        return (rte_iova_t)virtaddr;  /* VA == IOVA */
    
    /* Otherwise, translate via IOMMU mapping */
    return rte_mem_virt2phy(virtaddr);
}
```

### 7.2 配置 RX 描述符

```c
/* 简化的 RX 队列设置代码 */
int
setup_rx_queue(uint16_t port_id, uint16_t queue_id, 
               uint16_t nb_desc, struct rte_mempool *mp)
{
    struct rx_desc *rx_ring;
    struct rte_mbuf **rx_mbufs;
    
    /* 分配描述符环 (在 Huge Page 中) */
    rx_ring = rte_zmalloc("rx_ring", 
                          nb_desc * sizeof(struct rx_desc),
                          RTE_CACHE_LINE_SIZE);
    
    /* 分配 mbuf 指针数组 */
    rx_mbufs = rte_zmalloc("rx_mbufs",
                           nb_desc * sizeof(struct rte_mbuf *),
                           RTE_CACHE_LINE_SIZE);
    
    /* 预分配 mbufs 并填充描述符 */
    for (int i = 0; i < nb_desc; i++) {
        /* 从 mempool 分配 mbuf */
        rx_mbufs[i] = rte_pktmbuf_alloc(mp);
        
        /* 获取数据缓冲区的物理地址 */
        phys_addr_t phys_addr = rte_mbuf_data_iova(rx_mbufs[i]);
        
        /* 填充描述符 */
        rx_ring[i].buffer_addr = phys_addr;
        rx_ring[i].status = 0;
    }
    
    /* 将描述符环的物理地址写入网卡寄存器 */
    phys_addr_t ring_phys = rte_mem_virt2iova(rx_ring);
    
    /* 配置网卡 RX 队列基地址寄存器 */
    NIC_REG_WRITE(RDBAL, ring_phys & 0xFFFFFFFF);
    NIC_REG_WRITE(RDBAH, ring_phys >> 32);
    NIC_REG_WRITE(RDLEN, nb_desc * sizeof(struct rx_desc));
    
    /* 设置 HEAD 和 TAIL */
    NIC_REG_WRITE(RDH, 0);
    NIC_REG_WRITE(RDT, nb_desc - 1);  /* 告诉网卡有多少描述符可用 */
    
    return 0;
}
```

### 7.3 PMD 接收数据包

```c
/* 简化的 PMD RX burst 代码 */
uint16_t
eth_rx_burst(uint16_t port_id, uint16_t queue_id,
             struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
{
    struct rx_queue *rxq = &port->rx_queues[queue_id];
    struct rx_desc *rx_ring = rxq->rx_ring;
    struct rte_mbuf **rx_mbufs = rxq->rx_mbufs;
    uint16_t rx_id = rxq->rx_tail;
    uint16_t nb_rx = 0;
    
    while (nb_rx < nb_pkts) {
        /* 检查描述符状态 */
        volatile struct rx_desc *rxdp = &rx_ring[rx_id];
        uint32_t status = rxdp->status;
        
        /* DD (Descriptor Done) 位检查 */
        if (!(status & RX_DESC_STATUS_DD))
            break;  /* 没有更多数据包 */
        
        /* 获取 mbuf */
        struct rte_mbuf *mbuf = rx_mbufs[rx_id];
        
        /* 更新 mbuf 元数据 */
        mbuf->pkt_len = rxdp->length;
        mbuf->data_len = rxdp->length;
        mbuf->port = port_id;
        
        /* 分配新的 mbuf 补充描述符 */
        struct rte_mbuf *new_mbuf = rte_pktmbuf_alloc(rxq->mp);
        rx_mbufs[rx_id] = new_mbuf;
        rxdp->buffer_addr = rte_mbuf_data_iova(new_mbuf);
        rxdp->status = 0;  /* 清除状态 */
        
        /* 返回接收到的 mbuf */
        rx_pkts[nb_rx++] = mbuf;
        
        /* 前进到下一个描述符 */
        rx_id = (rx_id + 1) % rxq->nb_desc;
    }
    
    rxq->rx_tail = rx_id;
    
    /* 更新 RX TAIL 寄存器，通知网卡有新的描述符可用 */
    if (nb_rx > 0)
        NIC_REG_WRITE(RDT, rx_id);
    
    return nb_rx;
}
```

---

## 8. 总结

### 8.1 关键机制总结

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                         Key Mechanisms Summary                                          │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────────────────────┐
    │                                                                                     │
    │   1. DRIVER BINDING (决定数据包去向)                                                 │
    │      ┌─────────────────────────────────────────────────────────────────────────┐    │
    │      │                                                                         │    │
    │      │   Kernel Driver (ixgbe, i40e)  ──►  Kernel Protocol Stack               │    │
    │      │   UIO/VFIO Driver              ──►  User Space (DPDK)                   │    │
    │      │                                                                         │    │
    │      │   绑定不同驱动 = 选择不同数据路径                                          │    │
    │      │                                                                         │    │
    │      └─────────────────────────────────────────────────────────────────────────┘    │
    │                                                                                     │
    │   2. UIO/VFIO (用户空间设备访问)                                                    │
    │      ┌─────────────────────────────────────────────────────────────────────────┐    │
    │      │                                                                         │    │
    │      │   - 将网卡 BAR 区域映射到用户空间                                         │    │
    │      │   - 用户程序可直接读写网卡寄存器                                          │    │
    │      │   - 配置 DMA 描述符、控制网卡行为                                         │    │
    │      │                                                                         │    │
    │      └─────────────────────────────────────────────────────────────────────────┘    │
    │                                                                                     │
    │   3. HUGE PAGES (高效内存管理)                                                      │
    │      ┌─────────────────────────────────────────────────────────────────────────┐    │
    │      │                                                                         │    │
    │      │   - 减少 TLB miss，提高地址转换效率                                       │    │
    │      │   - 提供连续物理内存，便于 DMA                                            │    │
    │      │   - 内存不可换出，保证 DMA 安全                                           │    │
    │      │                                                                         │    │
    │      └─────────────────────────────────────────────────────────────────────────┘    │
    │                                                                                     │
    │   4. DMA DESCRIPTORS (网卡-内存通信)                                                │
    │      ┌─────────────────────────────────────────────────────────────────────────┐    │
    │      │                                                                         │    │
    │      │   - 描述符包含 mbuf 的物理地址                                            │    │
    │      │   - 网卡 DMA 引擎按物理地址写入数据                                       │    │
    │      │   - 应用程序通过虚拟地址访问同一内存                                       │    │
    │      │                                                                         │    │
    │      └─────────────────────────────────────────────────────────────────────────┘    │
    │                                                                                     │
    │   5. POLLING MODE (无中断高效处理)                                                   │
    │      ┌─────────────────────────────────────────────────────────────────────────┐    │
    │      │                                                                         │    │
    │      │   - 禁用网卡中断                                                         │    │
    │      │   - CPU 持续轮询描述符状态                                                │    │
    │      │   - 无上下文切换，低延迟                                                  │    │
    │      │                                                                         │    │
    │      └─────────────────────────────────────────────────────────────────────────┘    │
    │                                                                                     │
    └─────────────────────────────────────────────────────────────────────────────────────┘
```

### 8.2 为什么用户空间可以直接拿到数据包？

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│   答案总结：                                                                             │
│                                                                                         │
│   1. 驱动绑定                                                                            │
│      - 解绑内核驱动，绑定 UIO/VFIO                                                       │
│      - 网卡不再由内核管理，中断被禁用                                                     │
│                                                                                         │
│   2. 内存映射                                                                           │
│      - Huge Page 映射到用户空间                                                          │
│      - 同一物理内存同时有虚拟地址和物理地址                                                │
│                                                                                         │
│   3. DMA 配置                                                                           │
│      - 用户空间程序配置 DMA 描述符                                                       │
│      - 描述符中填入 Huge Page 的物理地址                                                 │
│      - 网卡 DMA 直接写入该物理地址                                                       │
│                                                                                        │
│   4. 地址转换                                                                           │
│      - 网卡使用物理地址写入                                                              │
│      - 应用程序使用虚拟地址读取                                                          │
│      - 指向同一块物理内存 = 零拷贝                                                       │
│                                                                                        │
│   结果：数据包直接出现在用户空间的 mbuf 中，无需内核参与！                                  │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

