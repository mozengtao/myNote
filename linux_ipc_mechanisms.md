# Linux 3.2 进程间通信(IPC)机制详解

---

## 目录

- [IPC 机制概览](#ipc-机制概览)
- [管道 (Pipe)](#管道-pipe)
- [命名管道 (FIFO)](#命名管道-fifo)
- [信号 (Signal)](#信号-signal)
- [System V 消息队列](#system-v-消息队列)
- [System V 共享内存](#system-v-共享内存)
- [System V 信号量](#system-v-信号量)
- [POSIX 消息队列](#posix-消息队列)
- [Unix 域套接字](#unix-域套接字)
- [内存映射 (mmap)](#内存映射-mmap)
- [IPC 机制对比](#ipc-机制对比)
- [选择指南](#选择指南)

---

## IPC 机制概览

### Linux IPC 分类

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                        Linux 进程间通信机制                                      │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                           数据传输类                                     │   │
│   │                                                                          │   │
│   │   ┌───────────────┐ ┌───────────────┐ ┌───────────────┐                │   │
│   │   │    管道       │ │   消息队列    │ │  Unix 套接字  │                │   │
│   │   │   (Pipe)      │ │(Message Queue)│ │ (Unix Socket) │                │   │
│   │   └───────────────┘ └───────────────┘ └───────────────┘                │   │
│   │         │                   │                 │                         │   │
│   │   ┌─────┴─────┐     ┌───────┴───────┐         │                         │   │
│   │   │           │     │               │         │                         │   │
│   │   │ 匿名管道   │     │ System V MQ   │    流/数据报                       │   │
│   │   │ 命名管道   │     │ POSIX MQ      │                                   │   │
│   │   │ (FIFO)    │     │               │                                   │   │
│   │   └───────────┘     └───────────────┘                                   │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                           共享内存类                                     │   │
│   │                                                                          │   │
│   │   ┌───────────────┐ ┌───────────────┐ ┌───────────────┐                │   │
│   │   │ System V SHM  │ │  POSIX SHM    │ │     mmap      │                │   │
│   │   │   (shmget)    │ │ (shm_open)    │ │   (匿名映射)  │                │   │
│   │   └───────────────┘ └───────────────┘ └───────────────┘                │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                           同步/信号类                                    │   │
│   │                                                                          │   │
│   │   ┌───────────────┐ ┌───────────────┐ ┌───────────────┐                │   │
│   │   │    信号       │ │ System V 信号量│ │  POSIX 信号量 │                │   │
│   │   │  (Signal)     │ │   (semget)    │ │  (sem_open)   │                │   │
│   │   └───────────────┘ └───────────────┘ └───────────────┘                │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 内核实现架构

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         IPC 内核实现架构                                         │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  用户空间                                                                        │
│  ─────────────────────────────────────────────────────────────────────────────   │
│                                                                                  │
│    pipe()    msgget()    shmget()    semget()    socket()    mmap()             │
│      │          │           │           │           │          │                │
│      ▼          ▼           ▼           ▼           ▼          ▼                │
│  ═══════════════════════════════════════════════════════════════════════════    │
│                         系统调用接口                                             │
│  ═══════════════════════════════════════════════════════════════════════════    │
│                                                                                  │
│  内核空间                                                                        │
│  ─────────────────────────────────────────────────────────────────────────────   │
│                                                                                  │
│   ┌───────────┐  ┌─────────────────────────┐  ┌───────────┐  ┌───────────┐     │
│   │  fs/pipe.c │  │        ipc/            │  │ net/unix/ │  │   mm/     │     │
│   │            │  │  msg.c shm.c sem.c     │  │ af_unix.c │  │  mmap.c   │     │
│   │ pipefs     │  │  mqueue.c              │  │           │  │  shmem.c  │     │
│   └─────┬──────┘  └───────────┬────────────┘  └─────┬─────┘  └─────┬─────┘     │
│         │                     │                     │              │            │
│         └─────────────────────┴─────────────────────┴──────────────┘            │
│                                       │                                          │
│                                       ▼                                          │
│                            ┌─────────────────────┐                              │
│                            │   VFS / Socket 层   │                              │
│                            │   内存管理子系统    │                              │
│                            └─────────────────────┘                              │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 管道 (Pipe)

### 原理

管道是 Unix 系统最古老的 IPC 机制，本质是内核中的一个**环形缓冲区**。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              管道工作原理                                        │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   进程 A (写端)                                         进程 B (读端)            │
│   ┌──────────────┐                                     ┌──────────────┐         │
│   │              │                                     │              │         │
│   │   write(fd)  │                                     │   read(fd)   │         │
│   │              │                                     │              │         │
│   └──────┬───────┘                                     └──────▲───────┘         │
│          │                                                    │                  │
│          │ fd[1]                                         fd[0]│                  │
│          │                                                    │                  │
│          ▼                                                    │                  │
│   ┌──────────────────────────────────────────────────────────────────────┐      │
│   │                          内核管道缓冲区                               │      │
│   │                                                                       │      │
│   │   ┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐         │      │
│   │   │ buf0 │ buf1 │ buf2 │ buf3 │ buf4 │ buf5 │ ...  │buf15 │         │      │
│   │   │ 4KB  │ 4KB  │ 4KB  │ 4KB  │ 4KB  │ 4KB  │      │ 4KB  │         │      │
│   │   └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘         │      │
│   │                                                                       │      │
│   │   curbuf ──► 当前读位置                                               │      │
│   │   nrbufs ──► 已使用的缓冲区数                                         │      │
│   │   默认容量: 16 * 4KB = 64KB (PIPE_DEF_BUFFERS)                       │      │
│   │                                                                       │      │
│   │   pipe_inode_info 结构                                                │      │
│   └──────────────────────────────────────────────────────────────────────┘      │
│                                                                                  │
│   特点:                                                                          │
│   - 半双工 (数据单向流动)                                                        │
│   - 只能在有亲缘关系的进程间使用 (fork 继承)                                     │
│   - 数据先进先出 (FIFO)                                                         │
│   - 读写阻塞 (缓冲区满/空时)                                                    │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 核心数据结构

```c
// include/linux/pipe_fs_i.h

struct pipe_buffer {
    struct page *page;          // 数据页
    unsigned int offset, len;   // 偏移和长度
    const struct pipe_buf_operations *ops;
    unsigned int flags;
    unsigned long private;
};

struct pipe_inode_info {
    wait_queue_head_t wait;     // 等待队列
    unsigned int nrbufs;        // 非空缓冲区数量
    unsigned int curbuf;        // 当前缓冲区索引
    unsigned int buffers;       // 总缓冲区数 (默认16)
    unsigned int readers;       // 读者计数
    unsigned int writers;       // 写者计数
    unsigned int waiting_writers; // 等待的写者数
    struct page *tmp_page;      // 临时页
    struct inode *inode;        // 关联的 inode
    struct pipe_buffer *bufs;   // 缓冲区数组
};
```

### API 与示例

```c
#include <unistd.h>

// 创建管道
int pipe(int pipefd[2]);
// pipefd[0]: 读端
// pipefd[1]: 写端

// 示例: 父子进程通信
int pipefd[2];
pipe(pipefd);

if (fork() == 0) {
    // 子进程 - 读端
    close(pipefd[1]);           // 关闭写端
    char buf[100];
    read(pipefd[0], buf, sizeof(buf));
    close(pipefd[0]);
} else {
    // 父进程 - 写端
    close(pipefd[0]);           // 关闭读端
    write(pipefd[1], "Hello", 5);
    close(pipefd[1]);
    wait(NULL);
}
```

### 适用场景

- **父子进程通信**: shell 管道 (`ls | grep xxx`)
- **简单数据流**: 一个生产者，一个消费者
- **临时通信**: 不需要持久化

---

## 命名管道 (FIFO)

### 原理

命名管道是管道的扩展，在文件系统中有路径名，允许无亲缘关系的进程通信。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                            命名管道 (FIFO) 原理                                  │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│     进程 A                                               进程 B                  │
│   ┌──────────────┐                                     ┌──────────────┐         │
│   │              │                                     │              │         │
│   │  open(path)  │                                     │  open(path)  │         │
│   │  O_WRONLY    │                                     │  O_RDONLY    │         │
│   │              │                                     │              │         │
│   └──────┬───────┘                                     └──────┬───────┘         │
│          │                                                    │                  │
│          │                                                    │                  │
│          ▼                                                    ▼                  │
│   ┌────────────────────────────────────────────────────────────────────────┐    │
│   │                                                                         │    │
│   │                     文件系统中的 FIFO 文件                              │    │
│   │                        /tmp/my_fifo                                     │    │
│   │                                                                         │    │
│   │   prw-r--r-- 1 user user 0 Nov 26 10:00 /tmp/my_fifo                   │    │
│   │   └── 'p' 表示管道类型                                                  │    │
│   │                                                                         │    │
│   └────────────────────────────────────────────────────────────────────────┘    │
│                                   │                                              │
│                                   ▼                                              │
│   ┌────────────────────────────────────────────────────────────────────────┐    │
│   │                          内核管道缓冲区                                  │    │
│   │                    (与匿名管道共享相同机制)                              │    │
│   └────────────────────────────────────────────────────────────────────────┘    │
│                                                                                  │
│   与匿名管道的区别:                                                              │
│   - 有文件系统路径名                                                            │
│   - 可在任意进程间使用                                                          │
│   - 需要先创建 (mkfifo)                                                         │
│   - 阻塞打开 (等待另一端打开)                                                   │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### API 与示例

```c
#include <sys/types.h>
#include <sys/stat.h>

// 创建命名管道
int mkfifo(const char *pathname, mode_t mode);

// 示例
mkfifo("/tmp/my_fifo", 0666);

// 写进程
int fd = open("/tmp/my_fifo", O_WRONLY);
write(fd, "Hello", 5);
close(fd);

// 读进程 (另一个程序)
int fd = open("/tmp/my_fifo", O_RDONLY);
char buf[100];
read(fd, buf, sizeof(buf));
close(fd);
```

### 适用场景

- **独立进程通信**: 客户端-服务端模式
- **脚本通信**: shell 脚本间数据传输
- **日志收集**: 多进程写日志到单一消费者

---

## 信号 (Signal)

### 原理

信号是一种**异步通知机制**，用于通知进程发生了某个事件。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                               信号机制                                           │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│     发送方                                                 接收方                │
│   ┌──────────────┐                                     ┌──────────────┐         │
│   │   kill()     │                                     │   进程       │         │
│   │   raise()    │─────────────────────────────────────►│              │         │
│   │   alarm()    │                                     │              │         │
│   └──────────────┘                                     └──────┬───────┘         │
│                                                               │                  │
│                                                               │                  │
│   ┌───────────────────────────────────────────────────────────┼───────────────┐ │
│   │                             内核                          │               │ │
│   │                                                           ▼               │ │
│   │   1. 信号产生                                                             │ │
│   │      - 硬件异常 (SIGSEGV, SIGFPE)                                        │ │
│   │      - 软件条件 (SIGPIPE, SIGALRM)                                       │ │
│   │      - 用户操作 (Ctrl+C → SIGINT)                                        │ │
│   │      - 进程调用 (kill, raise)                                            │ │
│   │                                                                           │ │
│   │   2. 信号投递                                                             │ │
│   │      task_struct->pending ──► sigqueue 链表                              │ │
│   │                                                                           │ │
│   │   3. 信号处理 (返回用户态时检查)                                          │ │
│   │      ┌─────────────────────────────────────┐                             │ │
│   │      │ SIG_DFL - 默认处理 (终止/忽略/停止) │                             │ │
│   │      │ SIG_IGN - 忽略信号                  │                             │ │
│   │      │ handler - 用户自定义处理函数        │                             │ │
│   │      └─────────────────────────────────────┘                             │ │
│   └───────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│   常用信号:                                                                       │
│   ┌────────┬──────────────────────────────────────────────────────────────┐     │
│   │ 信号    │ 描述                                                        │     │
│   ├────────┼──────────────────────────────────────────────────────────────┤     │
│   │ SIGINT │ 中断 (Ctrl+C)                                               │     │
│   │ SIGTERM│ 终止请求                                                    │     │
│   │ SIGKILL│ 强制终止 (不可捕获)                                         │     │
│   │ SIGCHLD│ 子进程状态改变                                              │     │
│   │ SIGALRM│ 定时器超时                                                  │     │
│   │ SIGUSR1│ 用户自定义信号1                                             │     │
│   │ SIGUSR2│ 用户自定义信号2                                             │     │
│   │ SIGPIPE│ 管道断开                                                    │     │
│   │ SIGSEGV│ 段错误                                                      │     │
│   └────────┴──────────────────────────────────────────────────────────────┘     │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 核心数据结构

```c
// kernel/signal.c & include/linux/sched.h

struct sigpending {
    struct list_head list;      // sigqueue 链表
    sigset_t signal;            // 待处理信号集
};

struct sigqueue {
    struct list_head list;
    int flags;
    siginfo_t info;             // 信号详细信息
    struct user_struct *user;
};

struct sigaction {
    __sighandler_t sa_handler;  // 处理函数
    unsigned long sa_flags;     // 标志
    sigset_t sa_mask;           // 执行时阻塞的信号
};

// task_struct 中的信号相关字段
struct task_struct {
    struct sigpending pending;      // 线程私有待处理信号
    struct signal_struct *signal;   // 信号处理 (共享)
    struct sighand_struct *sighand; // 信号处理函数
    sigset_t blocked;               // 阻塞信号集
    // ...
};
```

### API 与示例

```c
#include <signal.h>

// 发送信号
int kill(pid_t pid, int sig);
int raise(int sig);  // 向自己发送

// 设置信号处理
sighandler_t signal(int signum, sighandler_t handler);
int sigaction(int signum, const struct sigaction *act, 
              struct sigaction *oldact);

// 示例: 捕获 SIGINT
void handler(int sig) {
    printf("Caught signal %d\n", sig);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGINT, &sa, NULL);
    
    while(1) pause();  // 等待信号
}
```

### 适用场景

- **进程控制**: 终止、暂停、继续
- **定时器**: SIGALRM 实现超时
- **子进程管理**: SIGCHLD 通知
- **异常处理**: 段错误、浮点异常

---

## System V 消息队列

### 原理

消息队列是内核维护的**消息链表**，支持消息类型和优先级。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         System V 消息队列原理                                    │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│    进程 A                                                   进程 B               │
│   ┌────────────────┐                                   ┌────────────────┐       │
│   │                │                                   │                │       │
│   │  msgsnd()      │                                   │  msgrcv()      │       │
│   │  type=1, data  │                                   │  type=1        │       │
│   │                │                                   │                │       │
│   └───────┬────────┘                                   └────────▲───────┘       │
│           │                                                     │               │
│           ▼                                                     │               │
│   ┌─────────────────────────────────────────────────────────────────────────┐  │
│   │                           内核消息队列                                   │  │
│   │                                                                          │  │
│   │   msg_queue (msqid)                                                      │  │
│   │   ┌────────────────────────────────────────────────────────────────┐    │  │
│   │   │                                                                 │    │  │
│   │   │   q_messages (链表头)                                           │    │  │
│   │   │       │                                                         │    │  │
│   │   │       ▼                                                         │    │  │
│   │   │   ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐           │    │  │
│   │   │   │ msg 1  │──►│ msg 2  │──►│ msg 3  │──►│ msg 4  │           │    │  │
│   │   │   │type=1  │   │type=2  │   │type=1  │   │type=3  │           │    │  │
│   │   │   │ data   │   │ data   │   │ data   │   │ data   │           │    │  │
│   │   │   └────────┘   └────────┘   └────────┘   └────────┘           │    │  │
│   │   │                                                                 │    │  │
│   │   │   q_qnum: 4        (消息数量)                                   │    │  │
│   │   │   q_qbytes: 16384  (最大字节数)                                 │    │  │
│   │   │   q_cbytes: 1024   (当前字节数)                                 │    │  │
│   │   │                                                                 │    │  │
│   │   │   q_receivers ──► 等待接收的进程链表                            │    │  │
│   │   │   q_senders   ──► 等待发送的进程链表                            │    │  │
│   │   │                                                                 │    │  │
│   │   └────────────────────────────────────────────────────────────────┘    │  │
│   │                                                                          │  │
│   └──────────────────────────────────────────────────────────────────────────┘  │
│                                                                                  │
│   特点:                                                                          │
│   - 消息有类型，可按类型接收                                                     │
│   - 消息有边界，保持完整性                                                      │
│   - 持久化 (进程退出后仍存在)                                                   │
│   - 系统全局可见 (通过 key 标识)                                                │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 核心数据结构

```c
// include/linux/msg.h

struct msg_msg {
    struct list_head m_list;    // 消息链表
    long m_type;                // 消息类型
    int m_ts;                   // 消息文本大小
    struct msg_msgseg *next;    // 大消息分段
    void *security;
    /* 消息数据紧随其后 */
};

struct msg_queue {
    struct kern_ipc_perm q_perm;    // IPC 权限
    time_t q_stime;                 // 最后 msgsnd 时间
    time_t q_rtime;                 // 最后 msgrcv 时间
    time_t q_ctime;                 // 最后修改时间
    unsigned long q_cbytes;         // 队列当前字节数
    unsigned long q_qnum;           // 队列消息数量
    unsigned long q_qbytes;         // 队列最大字节数
    pid_t q_lspid;                  // 最后发送者 PID
    pid_t q_lrpid;                  // 最后接收者 PID
    struct list_head q_messages;    // 消息链表
    struct list_head q_receivers;   // 等待接收者
    struct list_head q_senders;     // 等待发送者
};
```

### API 与示例

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

// 创建/获取消息队列
int msgget(key_t key, int msgflg);

// 发送消息
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

// 接收消息
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, 
               long msgtyp, int msgflg);

// 控制操作
int msgctl(int msqid, int cmd, struct msqid_ds *buf);

// 示例
struct msgbuf {
    long mtype;
    char mtext[256];
};

key_t key = ftok("/tmp", 'A');
int msqid = msgget(key, IPC_CREAT | 0666);

// 发送
struct msgbuf msg = {1, "Hello"};
msgsnd(msqid, &msg, strlen(msg.mtext) + 1, 0);

// 接收 (type=1 的消息)
struct msgbuf recv;
msgrcv(msqid, &recv, sizeof(recv.mtext), 1, 0);

// 删除队列
msgctl(msqid, IPC_RMID, NULL);
```

### 适用场景

- **多对一通信**: 多客户端向服务端发请求
- **消息分类**: 按类型处理不同消息
- **松耦合**: 发送者和接收者解耦

---

## System V 共享内存

### 原理

共享内存是**最快的 IPC 方式**，多个进程将同一物理内存映射到各自的虚拟地址空间。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         System V 共享内存原理                                    │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│     进程 A                                              进程 B                   │
│   ┌────────────────┐                              ┌────────────────┐            │
│   │ 虚拟地址空间    │                              │ 虚拟地址空间    │            │
│   │                │                              │                │            │
│   │ 0x7f001000 ────┼──────────────────────────────┼──── 0x7f002000 │            │
│   │     │          │                              │          │     │            │
│   │     │          │                              │          │     │            │
│   │     ▼          │                              │          ▼     │            │
│   │  ┌────────┐    │                              │    ┌────────┐  │            │
│   │  │  VMA   │    │                              │    │  VMA   │  │            │
│   │  └───┬────┘    │                              │    └────┬───┘  │            │
│   └──────┼─────────┘                              └─────────┼──────┘            │
│          │                                                  │                    │
│          │                                                  │                    │
│          │         ┌──────────────────────────────┐         │                    │
│          │         │          页表                │         │                    │
│          └─────────┤                              ├─────────┘                    │
│                    │   PTE ──► 物理页帧           │                             │
│                    └──────────────────────────────┘                             │
│                                   │                                              │
│                                   ▼                                              │
│                    ┌──────────────────────────────┐                             │
│                    │                              │                             │
│                    │        物理内存页            │                             │
│                    │                              │                             │
│                    │   ┌────────────────────────┐ │                             │
│                    │   │    共享数据区域        │ │                             │
│                    │   │                        │ │                             │
│                    │   │  shmid_kernel 管理     │ │                             │
│                    │   └────────────────────────┘ │                             │
│                    │                              │                             │
│                    └──────────────────────────────┘                             │
│                                                                                  │
│   特点:                                                                          │
│   - 零拷贝，最高效的 IPC                                                        │
│   - 需要同步机制 (信号量) 保护                                                  │
│   - 持久化直到显式删除                                                          │
│   - 进程退出后仍保留数据                                                        │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 核心数据结构

```c
// include/linux/shm.h

struct shmid_kernel {
    struct kern_ipc_perm shm_perm;
    struct file *shm_file;          // 关联的 shmem 文件
    unsigned long shm_nattch;       // 当前连接数
    unsigned long shm_segsz;        // 段大小 (字节)
    time_t shm_atim;                // 最后 shmat 时间
    time_t shm_dtim;                // 最后 shmdt 时间
    time_t shm_ctim;                // 最后修改时间
    pid_t shm_cprid;                // 创建者 PID
    pid_t shm_lprid;                // 最后操作者 PID
    struct user_struct *mlock_user; // 锁定用户
    struct task_struct *shm_creator; // 创建进程
};
```

### API 与示例

```c
#include <sys/ipc.h>
#include <sys/shm.h>

// 创建/获取共享内存
int shmget(key_t key, size_t size, int shmflg);

// 连接共享内存
void *shmat(int shmid, const void *shmaddr, int shmflg);

// 断开连接
int shmdt(const void *shmaddr);

// 控制操作
int shmctl(int shmid, int cmd, struct shmid_ds *buf);

// 示例
key_t key = ftok("/tmp", 'S');
int shmid = shmget(key, 4096, IPC_CREAT | 0666);

// 连接
char *ptr = shmat(shmid, NULL, 0);

// 写入
strcpy(ptr, "Hello Shared Memory");

// 读取 (另一进程)
printf("Data: %s\n", ptr);

// 断开
shmdt(ptr);

// 删除
shmctl(shmid, IPC_RMID, NULL);
```

### 适用场景

- **大量数据共享**: 数据库缓存、图像处理
- **高性能 IPC**: 需要最小延迟
- **持久化数据**: 进程重启后数据保留

---

## System V 信号量

### 原理

信号量是一种**同步原语**，用于进程间同步和互斥。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          System V 信号量原理                                     │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│                           信号量集 (sem_array)                                   │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                                                                          │   │
│   │   sem_array (semid)                                                      │   │
│   │                                                                          │   │
│   │   ┌──────────┬──────────┬──────────┬──────────┐                         │   │
│   │   │  sem[0]  │  sem[1]  │  sem[2]  │   ...    │                         │   │
│   │   │ semval=1 │ semval=0 │ semval=3 │          │                         │   │
│   │   └──────────┴──────────┴──────────┴──────────┘                         │   │
│   │                                                                          │   │
│   │   sem_pending ──► 等待的操作队列                                         │   │
│   │                                                                          │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                  │
│   信号量操作 (P/V 原语):                                                         │
│                                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                                                                          │   │
│   │   P 操作 (等待/获取)                V 操作 (释放/发信号)                 │   │
│   │   ─────────────────────             ─────────────────────                │   │
│   │                                                                          │   │
│   │   semop(semid, {                    semop(semid, {                       │   │
│   │       .sem_num = 0,                     .sem_num = 0,                    │   │
│   │       .sem_op = -1,  // 减少           .sem_op = +1,  // 增加           │   │
│   │       .sem_flg = 0                      .sem_flg = 0                     │   │
│   │   }, 1);                            }, 1);                               │   │
│   │                                                                          │   │
│   │   如果 semval < |sem_op|:           semval += sem_op                    │   │
│   │       阻塞等待                       唤醒等待进程                        │   │
│   │                                                                          │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                  │
│   互斥锁示例:                                                                    │
│                                                                                  │
│   ┌───────────────┐        ┌───────────────┐        ┌───────────────┐          │
│   │    进程 A     │        │   临界区      │        │    进程 B     │          │
│   │               │        │               │        │               │          │
│   │   P(sem)      │───────►│   访问共享    │◄───────│   P(sem)      │          │
│   │   (sem=0)     │        │   资源        │        │   (阻塞)      │          │
│   │   ...         │        │               │        │   ...         │          │
│   │   V(sem)      │───────►│               │───────►│   (唤醒)      │          │
│   │   (sem=1)     │        │               │        │               │          │
│   └───────────────┘        └───────────────┘        └───────────────┘          │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 核心数据结构

```c
// include/linux/sem.h & ipc/sem.c

struct sem {
    int semval;                     // 当前值
    int sempid;                     // 最后操作的 PID
    struct list_head sem_pending;   // 等待的操作
};

struct sem_array {
    struct kern_ipc_perm sem_perm;
    time_t sem_otime;               // 最后 semop 时间
    time_t sem_ctime;               // 最后修改时间
    struct sem *sem_base;           // 信号量数组
    struct list_head sem_pending;   // 等待的复杂操作
    struct list_head list_id;       // undo 请求
    int sem_nsems;                  // 信号量数量
    int complex_count;              // 复杂操作计数
};

struct sembuf {
    unsigned short sem_num;         // 信号量索引
    short sem_op;                   // 操作值
    short sem_flg;                  // 标志 (SEM_UNDO, IPC_NOWAIT)
};
```

### API 与示例

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

// 创建/获取信号量集
int semget(key_t key, int nsems, int semflg);

// 信号量操作
int semop(int semid, struct sembuf *sops, unsigned nsops);

// 控制操作
int semctl(int semid, int semnum, int cmd, ...);

// 示例: 二元信号量 (互斥锁)
union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

key_t key = ftok("/tmp", 'M');
int semid = semget(key, 1, IPC_CREAT | 0666);

// 初始化为 1
union semun arg = {.val = 1};
semctl(semid, 0, SETVAL, arg);

// P 操作 (加锁)
struct sembuf p_op = {0, -1, SEM_UNDO};
semop(semid, &p_op, 1);

// 临界区
// ...

// V 操作 (解锁)
struct sembuf v_op = {0, 1, SEM_UNDO};
semop(semid, &v_op, 1);
```

### 适用场景

- **互斥访问**: 保护共享内存
- **资源计数**: 有限资源的分配
- **生产者-消费者**: 同步缓冲区访问

---

## POSIX 消息队列

### 原理

POSIX 消息队列是对 System V 消息队列的现代化替代，基于文件系统实现。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          POSIX 消息队列原理                                      │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   特点:                                                                          │
│   - 基于文件描述符 (可用 select/poll/epoll)                                     │
│   - 消息有优先级 (最高优先级先出)                                               │
│   - 支持异步通知 (信号或线程)                                                   │
│   - 接口更简洁                                                                  │
│                                                                                  │
│   ┌────────────────────────────────────────────────────────────────────────┐    │
│   │                                                                         │    │
│   │   mqueue 文件系统 (/dev/mqueue)                                        │    │
│   │                                                                         │    │
│   │   $ ls -la /dev/mqueue/                                                │    │
│   │   -rw-r--r-- 1 user user 80 Nov 26 10:00 /my_queue                     │    │
│   │                                                                         │    │
│   └────────────────────────────────────────────────────────────────────────┘    │
│                           │                                                      │
│                           ▼                                                      │
│   ┌────────────────────────────────────────────────────────────────────────┐    │
│   │   mqueue_inode_info                                                     │    │
│   │                                                                         │    │
│   │   ┌────────────────────────────────────────────────────────────────┐   │    │
│   │   │   attr                                                          │   │    │
│   │   │   ├── mq_maxmsg  = 10     (最大消息数)                         │   │    │
│   │   │   ├── mq_msgsize = 256    (最大消息大小)                       │   │    │
│   │   │   └── mq_curmsgs = 3      (当前消息数)                         │   │    │
│   │   │                                                                 │   │    │
│   │   │   messages[] ──► 按优先级排序的消息数组                        │   │    │
│   │   │                                                                 │   │    │
│   │   │   ┌─────────┐ ┌─────────┐ ┌─────────┐                         │   │    │
│   │   │   │ prio=10 │ │ prio=5  │ │ prio=1  │                         │   │    │
│   │   │   │ "high"  │ │ "med"   │ │ "low"   │                         │   │    │
│   │   │   └─────────┘ └─────────┘ └─────────┘                         │   │    │
│   │   │                                                                 │   │    │
│   │   │   e_wait_q[] ──► 等待发送/接收的进程                           │   │    │
│   │   │   notify ──► 异步通知配置                                       │   │    │
│   │   └────────────────────────────────────────────────────────────────┘   │    │
│   └────────────────────────────────────────────────────────────────────────┘    │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### API 与示例

```c
#include <mqueue.h>

// 打开/创建消息队列
mqd_t mq_open(const char *name, int oflag, mode_t mode, 
              struct mq_attr *attr);

// 发送消息 (带优先级)
int mq_send(mqd_t mqdes, const char *msg_ptr, 
            size_t msg_len, unsigned msg_prio);

// 接收消息
ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, 
                   size_t msg_len, unsigned *msg_prio);

// 关闭
int mq_close(mqd_t mqdes);

// 删除
int mq_unlink(const char *name);

// 异步通知
int mq_notify(mqd_t mqdes, const struct sigevent *sevp);

// 示例
struct mq_attr attr = {
    .mq_maxmsg = 10,
    .mq_msgsize = 256
};

mqd_t mq = mq_open("/my_queue", O_CREAT | O_RDWR, 0666, &attr);

// 发送 (优先级 5)
mq_send(mq, "Hello", 6, 5);

// 接收
char buf[256];
unsigned prio;
mq_receive(mq, buf, sizeof(buf), &prio);

mq_close(mq);
mq_unlink("/my_queue");
```

### 适用场景

- **现代应用**: 推荐替代 System V 消息队列
- **事件驱动**: 配合 epoll 使用
- **优先级处理**: 紧急消息优先

---

## Unix 域套接字

### 原理

Unix 域套接字是**本地套接字**，提供流和数据报两种模式。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          Unix 域套接字原理                                       │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│                        ┌─────────────────────────┐                              │
│                        │   Unix 域套接字类型     │                              │
│                        └─────────────────────────┘                              │
│                                    │                                             │
│                 ┌──────────────────┼──────────────────┐                         │
│                 ▼                  ▼                  ▼                         │
│   ┌─────────────────────┐ ┌─────────────────────┐ ┌─────────────────────┐      │
│   │    SOCK_STREAM      │ │    SOCK_DGRAM       │ │    SOCK_SEQPACKET   │      │
│   │    (流式)           │ │    (数据报)         │ │    (顺序包)         │      │
│   │                     │ │                     │ │                     │      │
│   │  - 面向连接        │ │  - 无连接           │ │  - 面向连接        │      │
│   │  - 可靠有序        │ │  - 不可靠           │ │  - 保持消息边界    │      │
│   │  - 双向通信        │ │  - 双向通信         │ │  - 可靠有序        │      │
│   │  - 无边界          │ │  - 有边界           │ │                     │      │
│   └─────────────────────┘ └─────────────────────┘ └─────────────────────┘      │
│                                                                                  │
│   SOCK_STREAM 通信模型:                                                          │
│                                                                                  │
│   服务端                                              客户端                     │
│   ┌────────────────┐                              ┌────────────────┐            │
│   │                │                              │                │            │
│   │   socket()     │                              │   socket()     │            │
│   │       │        │                              │       │        │            │
│   │       ▼        │                              │       │        │            │
│   │   bind()       │                              │       │        │            │
│   │       │        │                              │       │        │            │
│   │       ▼        │                              │       │        │            │
│   │   listen()     │                              │       │        │            │
│   │       │        │                              │       ▼        │            │
│   │       ▼        │  connect()                   │   connect()    │            │
│   │   accept() ◄───┼─────────────────────────────┼───────         │            │
│   │       │        │                              │       │        │            │
│   │       ▼        │                              │       ▼        │            │
│   │   read/write ◄─┼─────────────────────────────┼──► read/write  │            │
│   │       │        │                              │       │        │            │
│   │       ▼        │                              │       ▼        │            │
│   │   close()      │                              │   close()      │            │
│   │                │                              │                │            │
│   └────────────────┘                              └────────────────┘            │
│                                                                                  │
│   特点:                                                                          │
│   - 可传递文件描述符 (SCM_RIGHTS)                                               │
│   - 可传递凭证 (SCM_CREDENTIALS)                                                │
│   - 性能优于 TCP (无网络协议栈开销)                                             │
│   - 支持 abstract namespace (不需要文件)                                        │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### API 与示例

```c
#include <sys/socket.h>
#include <sys/un.h>

// 服务端
int server_fd = socket(AF_UNIX, SOCK_STREAM, 0);

struct sockaddr_un addr;
addr.sun_family = AF_UNIX;
strcpy(addr.sun_path, "/tmp/my_socket");

unlink("/tmp/my_socket");
bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
listen(server_fd, 5);

int client_fd = accept(server_fd, NULL, NULL);

// 通信
char buf[256];
read(client_fd, buf, sizeof(buf));
write(client_fd, "Response", 9);

close(client_fd);
close(server_fd);

// 客户端
int fd = socket(AF_UNIX, SOCK_STREAM, 0);

struct sockaddr_un addr;
addr.sun_family = AF_UNIX;
strcpy(addr.sun_path, "/tmp/my_socket");

connect(fd, (struct sockaddr*)&addr, sizeof(addr));

write(fd, "Request", 8);
char buf[256];
read(fd, buf, sizeof(buf));

close(fd);

// 传递文件描述符
struct msghdr msg = {0};
struct cmsghdr *cmsg;
char cmsgbuf[CMSG_SPACE(sizeof(int))];

msg.msg_control = cmsgbuf;
msg.msg_controllen = sizeof(cmsgbuf);

cmsg = CMSG_FIRSTHDR(&msg);
cmsg->cmsg_level = SOL_SOCKET;
cmsg->cmsg_type = SCM_RIGHTS;
cmsg->cmsg_len = CMSG_LEN(sizeof(int));
*((int*)CMSG_DATA(cmsg)) = fd_to_send;

sendmsg(sock, &msg, 0);
```

### 适用场景

- **本地客户端-服务端**: 数据库连接、D-Bus
- **多进程服务**: 传递连接给工作进程
- **权限传递**: 传递打开的文件描述符

---

## 内存映射 (mmap)

### 原理

mmap 可以创建匿名共享映射或文件共享映射，实现进程间内存共享。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                            mmap 共享内存原理                                     │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   匿名共享映射 (MAP_ANONYMOUS | MAP_SHARED):                                     │
│                                                                                  │
│     父进程 fork() 前:                                                            │
│     ┌──────────────────────────────────────────────────────────────────┐        │
│     │                                                                   │        │
│     │   ptr = mmap(NULL, size, PROT_READ|PROT_WRITE,                   │        │
│     │              MAP_ANONYMOUS|MAP_SHARED, -1, 0);                   │        │
│     │                                                                   │        │
│     └──────────────────────────────────────────────────────────────────┘        │
│                                                                                  │
│     fork() 后:                                                                   │
│     ┌────────────────┐                              ┌────────────────┐          │
│     │   父进程       │                              │   子进程       │          │
│     │                │                              │                │          │
│     │   ptr ─────────┼──────────────────────────────┼───────► ptr    │          │
│     │                │                              │                │          │
│     └────────────────┘                              └────────────────┘          │
│                                    │                                             │
│                                    ▼                                             │
│                        ┌───────────────────────┐                                │
│                        │      共享物理页       │                                │
│                        │                       │                                │
│                        │   (写入立即可见)      │                                │
│                        └───────────────────────┘                                │
│                                                                                  │
│   文件共享映射 (无亲缘关系):                                                     │
│                                                                                  │
│     进程 A:                                         进程 B:                      │
│     ┌──────────────────────────────────────────────────────────────────┐        │
│     │ fd = open("/tmp/shared", ...);                                   │        │
│     │ ftruncate(fd, size);                                             │        │
│     │ ptr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); │        │
│     └──────────────────────────────────────────────────────────────────┘        │
│                                    │                                             │
│                                    ▼                                             │
│                        ┌───────────────────────┐                                │
│                        │    /tmp/shared        │                                │
│                        │    (普通文件)         │                                │
│                        │                       │                                │
│                        │    或 tmpfs 文件      │                                │
│                        │    /dev/shm/xxx       │                                │
│                        └───────────────────────┘                                │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### API 与示例

```c
#include <sys/mman.h>

// 匿名共享映射 (父子进程)
void *ptr = mmap(NULL, 4096, 
                 PROT_READ | PROT_WRITE,
                 MAP_ANONYMOUS | MAP_SHARED,
                 -1, 0);

if (fork() == 0) {
    // 子进程写入
    strcpy(ptr, "Hello from child");
    exit(0);
} else {
    wait(NULL);
    // 父进程读取
    printf("Data: %s\n", ptr);
}

munmap(ptr, 4096);

// POSIX 共享内存 (无亲缘关系)
#include <fcntl.h>

// 进程 A: 创建
int fd = shm_open("/my_shm", O_CREAT | O_RDWR, 0666);
ftruncate(fd, 4096);
void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, 
                 MAP_SHARED, fd, 0);
strcpy(ptr, "Shared data");

// 进程 B: 打开
int fd = shm_open("/my_shm", O_RDWR, 0);
void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
                 MAP_SHARED, fd, 0);
printf("Data: %s\n", ptr);

// 清理
munmap(ptr, 4096);
shm_unlink("/my_shm");
```

### 适用场景

- **父子进程共享**: fork 后共享数据
- **大文件处理**: 数据库、日志文件
- **POSIX 共享内存**: /dev/shm 上的快速共享

---

## IPC 机制对比

### 综合对比表

| 特性 | 管道 | FIFO | 信号 | 消息队列 | 共享内存 | 信号量 | Unix 套接字 |
|------|------|------|------|----------|----------|--------|-------------|
| **通信方向** | 单向 | 单向 | 单向 | 双向 | 双向 | N/A | 双向 |
| **进程关系** | 亲缘 | 任意 | 任意 | 任意 | 任意 | 任意 | 任意 |
| **数据边界** | 无 | 无 | N/A | 有 | 无 | N/A | 可选 |
| **数据拷贝** | 2次 | 2次 | 0次 | 2次 | 0次 | N/A | 2次 |
| **容量限制** | 64KB | 64KB | N/A | 可配置 | 可配置 | N/A | 可配置 |
| **持久性** | 进程 | 文件系统 | 无 | 内核 | 内核 | 内核 | 文件系统 |
| **同步机制** | 内置 | 内置 | 异步 | 内置 | 需要 | 就是 | 内置 |
| **适合数据量** | 中 | 中 | 极小 | 中 | 大 | 极小 | 中-大 |

### 性能对比

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           IPC 性能对比 (相对值)                                  │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   延迟 (越低越好)                                                                │
│   ─────────────────────────────────────────────────────────────────────────────  │
│                                                                                  │
│   共享内存    ████                                                      最低    │
│   信号        ██████                                                            │
│   Unix 套接字 ████████                                                          │
│   管道        ████████                                                          │
│   消息队列    ██████████                                                        │
│   网络套接字  ████████████████████                                      最高    │
│                                                                                  │
│   吞吐量 (越高越好)                                                              │
│   ─────────────────────────────────────────────────────────────────────────────  │
│                                                                                  │
│   共享内存    ████████████████████████████████████████████████████████  最高    │
│   Unix 套接字 ██████████████████████████████████                                │
│   管道        ████████████████████████████                                      │
│   消息队列    ██████████████████                                                │
│   网络套接字  ██████████████                                            最低    │
│                                                                                  │
│   注: 共享内存性能最高因为零拷贝，但需要额外同步开销                            │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 使用复杂度

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           使用复杂度对比                                         │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   简单 ◄──────────────────────────────────────────────────────────────► 复杂    │
│                                                                                  │
│   信号        ██                                                                │
│   管道        ████                                                              │
│   FIFO        ██████                                                            │
│   消息队列    ████████                                                          │
│   共享内存    ████████████ (需要同步)                                           │
│   Unix 套接字 ██████████████                                                    │
│   信号量      ████████████████ (复杂语义)                                       │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 选择指南

### 决策流程图

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                            IPC 选择决策流程                                      │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│                              开始选择 IPC                                        │
│                                   │                                              │
│                                   ▼                                              │
│                        ┌─────────────────────┐                                  │
│                        │ 需要跨机器通信吗？  │                                  │
│                        └──────────┬──────────┘                                  │
│                                   │                                              │
│                    ┌──── 是 ─────┤───── 否 ────┐                               │
│                    ▼              │              ▼                               │
│             网络套接字           │    ┌─────────────────────┐                   │
│           (TCP/UDP/...)          │    │ 父子进程通信？      │                   │
│                                  │    └──────────┬──────────┘                   │
│                                  │               │                               │
│                                  │    ┌── 是 ───┤─── 否 ───┐                    │
│                                  │    ▼          │          ▼                    │
│                                  │  管道         │   ┌─────────────────────┐    │
│                                  │  mmap共享     │   │ 需要大量数据传输？  │    │
│                                  │               │   └──────────┬──────────┘    │
│                                  │               │              │                │
│                                  │               │   ┌── 是 ───┤─── 否 ───┐     │
│                                  │               │   ▼          │          ▼     │
│                                  │               │ 共享内存     │   ┌──────────┐ │
│                                  │               │ + 信号量    │   │消息边界？│ │
│                                  │               │              │   └────┬─────┘ │
│                                  │               │              │        │       │
│                                  │               │              │   ┌─是┤否─┐   │
│                                  │               │              │   ▼    │   ▼   │
│                                  │               │              │ 消息队列│ Unix │
│                                  │               │              │        │套接字 │
│                                  │               │              │        │ FIFO  │
│                                  └───────────────┴──────────────┴────────┴───────┘
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 场景推荐

| 场景 | 推荐方案 | 理由 |
|------|----------|------|
| Shell 命令管道 | 匿名管道 | 简单、父子进程 |
| 进程间事件通知 | 信号 | 异步、轻量 |
| 数据库缓存共享 | 共享内存 + 信号量 | 高性能、大数据量 |
| 多客户端服务 | Unix 域套接字 | 双向、多连接 |
| 任务队列 | 消息队列 | 解耦、可靠 |
| 配置热更新通知 | 信号 (SIGHUP) | 标准惯例 |
| 日志收集 | 命名管道 | 多写单读 |
| 进程同步 | 信号量 | 专为同步设计 |

### 源码文件索引

| 机制 | 核心源码 | 头文件 |
|------|----------|--------|
| 管道 | fs/pipe.c | include/linux/pipe_fs_i.h |
| 信号 | kernel/signal.c | include/linux/signal.h |
| 消息队列 (SysV) | ipc/msg.c | include/linux/msg.h |
| 共享内存 (SysV) | ipc/shm.c | include/linux/shm.h |
| 信号量 (SysV) | ipc/sem.c | include/linux/sem.h |
| POSIX 消息队列 | ipc/mqueue.c | include/linux/mqueue.h |
| Unix 域套接字 | net/unix/af_unix.c | include/linux/un.h |
| mmap | mm/mmap.c, mm/shmem.c | include/linux/mman.h |

---

## 总结

Linux 提供了丰富的 IPC 机制，各有特点:

1. **管道/FIFO**: 简单的字节流传输
2. **信号**: 异步事件通知
3. **消息队列**: 结构化消息传递
4. **共享内存**: 最高性能的数据共享
5. **信号量**: 进程同步原语
6. **Unix 套接字**: 功能最全面的本地通信

选择原则:
- **简单场景**: 管道或信号
- **性能敏感**: 共享内存
- **需要同步**: 信号量
- **功能需求多**: Unix 域套接字
- **消息传递**: 消息队列

