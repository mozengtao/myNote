- 地址的概念
	- 物理地址
		- ^^MMU看到的地址^^
		- CPU地址总线传来的地址，具体含义由硬件电路决定。程序指令中的虚拟地址经过MMU后形成物理地址，物理地址被放到CPU的地址线上。
		- 物理地址中很大一部分是留给内存条中的^^内存^^的，但也常被映射到^^其他存储器^^上 （如显存、BIOS等），还有一部分要给^^总线^^用（总线上还挂着别的 许多设备）
	- 总线地址
		- ^^设备看到的地址^^
		- 物理地址与总线地址之间的关系由系统的设计决定的。在x86平台上，物理地址就是总线地址，这是因为它们共享相同的地址空间。在其他平台上，可能需要转换/映射
	- 虚拟地址
		- ^^CPU，程序员操作的地址^^
		- 处理器启用了MMU，CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address）
-
- 编址方式
	- 外设都是通过读写设备上的寄存器来进行的，^^外设寄存器也称为I/O端口^^，而IO端口有两种编址方式
		- ((6386e262-950e-47d4-8264-293efd048109))
		- ((6386e270-db56-444d-95e1-947f2404d285))
		- 对于某一既定的系统，它要么是独立编址、要么是统一编址，具体采用哪一种则取决于CPU的体系结构。对于Linux内核而言，它可能用于不同的CPU，所以它必须都要考虑这两种方式，于是它采 用一种新的方法，将基于I/O映射方式的或内存映射方式的I/O端口通称为“I/O区域”（I/O region），不论你采用哪种方式，都要先申请IO区域：request_resource()，结束时释放 它：release_resource()
	- 访问外设
		- 访问I/O内存的流程是：request_mem_region() -> ioremap() -> ioread8()/iowrite8() -> iounmap() -> release_mem_region()
		- 访问IO端口的2种途径
			- I/O映射方式（I/O－mapped）
				- 不映射到内存空间，直接使用 intb()/outb()之类的函数来读写IO端口
			- 内存映射方式（Memory－mapped）
				- 先把IO端口映射到IO内存（“内存空间”），再使用访问IO内存的函数来访问 IO端口
				- void** ioport_map**(unsigned long port, unsigned int count) 可以把port开始的count个连续的IO端口映射为一段“内存空间”，然后就可以在其返回的地址是像访问IO内存一样访问这些IO端口
		- IO端口
			- 外设寄存器统称为IO端口，通常包括：控制寄存器，状态寄存器和数据寄存器。
			- 当寄存器或内存位于 IO 空间时，称为 IO 端口。一般寄存器也俗称 I/O 端口,或者说 I/O ports,这个 I/O 端口可以被映射在 Memory Space,也可以被映射在 I/O Space
		- IO内存
			- 当寄存器或内存位于内存空间时，称为 IO 内存
			- 例如，在 PC 上可以插上一块图形卡，有 2MB 的存储空间，甚至可能还带有 ROM,其中装有可执行代码
			- ![image.png](../assets/image_1669794755594_0.png)
		- 内存空间
			- 内存地址寻址范围，32 位操作系统内存空间为 2 的 32 次幂，即 4G
		- IO空间
			- X86 特有的一个空间，与内存空间彼此独立的地址空间，32 位 X86 有 64K 的 IO 空间
			-
		- Linux下的IO端口和IO内存
			- Linux将基于IO映射方式的和内存映射方式的IO端口统称为IO区域（IO region），IO region仍然是一种IO资源，因此它仍然可以用resource结构类型来描述
				- request_region
				- check_region
				- release_region
				- 对IO内存资源的访问
					- request_mem_region
					- check_mem_region
					- release_mem_region
				-
			-