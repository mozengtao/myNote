[C Online Compiler](https://www.programiz.com/c-programming/online-compiler/)  
[va_list in C: exploring ft_printf](https://medium.com/@turman1701/va-list-in-c-exploring-ft-printf-bb2a19fcd128)  
[SystemProgramming Wiki](https://csresources.github.io/SystemProgrammingWiki/SystemProgramming/C-Programming,-Part-1:-Introduction/)  
[**Beej's Guide to C Programming**](https://beej.us/guide/bgc/html/split/index.html)  
[]()  
[]()  
[]()  

[Understanding the C Runtime: crt0, crt1, crti, and crtn](https://www.inferara.com/en/blog/c-runtime/)  
[C/C++ Runtime Startup](https://etherealwake.com/2021/09/crt-startup/)  
[Explanation of crt0, crt1, crt1, and crtn (C- Runtime)](https://thejat.in/learn/explanation-of-crt0-crt1-crt1-and-crtn-c-runtime)  
[CRT: C Run Time Before Starting main()](https://vishalchovatiya.com/posts/crt-run-time-before-starting-main/)  
[**Linux-dlsym**](https://lambertxiao.github.io/posts/linux-dlsym/doc/)  
[çœŸæ­£ç†è§£ RTLD_NEXT çš„ä½œç”¨](https://csstormq.github.io/)  
[Dynamic Linking Example](https://vishalchovatiya.com/posts/dynamic-linking-example/)  
[]()  
[]()  
[]()  
[How to make a system call in C](https://jameshfisher.com/2018/02/19/how-to-syscall-in-c/)  
[How do I call a program from C?](https://jameshfisher.com/2017/02/07/how-do-i-call-a-program-in-c/)  
[How do I call a program in C, setting up standard pipes?](https://jameshfisher.com/2017/02/17/how-do-i-call-a-program-in-c-with-pipes/)  
[How do I use fork in C?](https://jameshfisher.com/2017/02/06/how-do-i-use-fork-in-c/)  
[What is a â€œfile descriptorâ€, really?](https://jameshfisher.com/2016/12/15/file-descriptor-misnomer/)  
[What does getaddrinfo do?](https://jameshfisher.com/2018/02/03/what-does-getaddrinfo-do/)  
[What is a a FIFO, or â€œnamed pipeâ€? What is mkfifo in C?](https://jameshfisher.com/2017/02/21/mkfifo-c/)  
[What is static linking in C?](https://jameshfisher.com/2017/08/26/static-linking/)  
[What are setjmp and longjmp in C?](https://jameshfisher.com/2017/02/18/what-are-setjmp-longjmp/)  
[How to generate Intel and AT&T assembly with clang](https://jameshfisher.com/2017/02/19/clang-assembly-att-intel/)  
[How do I duplicate a file descriptor in C?](https://jameshfisher.com/2017/02/15/c-dup-syscall/)  
[How do I use execve in C?](https://jameshfisher.com/2017/02/05/how-do-i-use-execve-in-c/)  
[How do I generate assembly from a C file?](https://jameshfisher.com/2017/02/03/c-generate-assembly/)  
[How can I read a file with mmap in C?](https://jameshfisher.com/2017/01/27/mmap-file-read/)  
[What is realloc in C?](https://jameshfisher.com/2016/12/01/c-realloc/)  
[What is mmap in C?](https://jameshfisher.com/2017/01/26/mmap/)  
[How can I write a file with mmap in C?](https://jameshfisher.com/2017/01/28/mmap-file-write/)  
[In what ways can processes communicate?](https://jameshfisher.com/2017/01/29/process-communication-methods/)  
[What are â€˜signalsâ€™ in C?](https://jameshfisher.com/2017/01/09/c-signals/)  
[What does the C signal function return?](https://jameshfisher.com/2017/01/10/c-signal-return-value/)  
[How do I unregister a signal handler in C?](https://jameshfisher.com/2017/01/11/c-signal-unregister/)  
[What does void mean as a function parameter in C?](https://jameshfisher.com/2016/11/27/c-void-params/)  
[What are lvalue and rvalue in C?](https://jameshfisher.com/2017/01/21/c-lvalue-rvalue/)  
[What are the domain and type arguments to the socket system call?](https://jameshfisher.com/2017/02/27/socket-types/)  
[Variadic Function Working in C](https://www.thejat.in/blog/variadic-function-working-in-c)  
[Understanding Complex C/C++ Declarations](https://www.thejat.in/blog/understanding-complex-cc-declarations)  
[Exploring Singleton Pattern in C++: Ensuring Unique Instances](https://www.thejat.in/blog/exploring-singleton-pattern-in-c-ensuring-unique-instances)  
[]()  

## C å·¥ç¨‹æŠ€å·§
![å•ä¾‹æ¨¡å¼](./c_tips/01_å•ä¾‹æ¨¡å¼_Singleton.md)  
![å•ä¾‹æ¨¡å¼](./c_tips/01_å•ä¾‹æ¨¡å¼_Singleton_Pattern.md)  
![å·¥å‚æ¨¡å¼](./c_tips/02_å·¥å‚æ¨¡å¼_Factory.md)  
![é€‚é…å™¨æ¨¡å¼](./c_tips/03_é€‚é…å™¨æ¨¡å¼_Adapter.md)  
![è§‚å¯Ÿè€…æ¨¡å¼](./c_tips/04_è§‚å¯Ÿè€…æ¨¡å¼_Observer.md)  
![ç­–ç•¥æ¨¡å¼](./c_tips/05_ç­–ç•¥æ¨¡å¼_Strategy.md)  
![çŠ¶æ€æ¨¡å¼](./c_tips/06_çŠ¶æ€æ¨¡å¼_State.md)  
![å›è°ƒæ¨¡å¼](./c_tips/07_å›è°ƒæ¨¡å¼_Callback.md)  
![Cè¯­è¨€è½¯ä»¶å·¥ç¨‹æŠ€å·§](./c_tips/08_Cè¯­è¨€è½¯ä»¶å·¥ç¨‹æŠ€å·§.md)  
![ä¸é€æ˜æŒ‡é’ˆ](./c_tips/09_ä¸é€æ˜æŒ‡é’ˆ_Opaque_Pointer.md)  
![X-MacæŠ€æœ¯](./c_tips/10_X-MacroæŠ€æœ¯.md)  
![å†…å­˜æ± ](./c_tips/11_å†…å­˜æ± _Memory_Pool.md)  
![é”™è¯¯å¤„ç†ç­–](./c_tips/12_é”™è¯¯å¤„ç†ç­–ç•¥_Error_Handling.md)  
![å¥‘çº¦å¼ç¼–ç¨‹](./c_tips/13_å¥‘çº¦å¼ç¼–ç¨‹_Design_by_Contract.md)  
![ä¾µå…¥å¼æ•°æ®ç»“æ„](./c_tips/14_ä¾µå…¥å¼æ•°æ®ç»“æ„_Intrusive.md)  
![ç¼–è¯‘æ—¶æ–­è¨€](./c_tips/15_ç¼–è¯‘æ—¶æ–­è¨€_Static_Assert.md)  
![å±æ€§æ¸…ç†](./c_tips/16_å±æ€§æ¸…ç†_RAII_Cleanup.md)  
![æ³›å‹å®ç¼–ç¨‹](./c_tips/17_æ³›å‹å®ç¼–ç¨‹_Generic.md)  
[é˜²å¾¡å¼ç¼–ç¨‹](./c_tips/18_é˜²å¾¡å¼ç¼–ç¨‹_Defensive.md)  
![]()  
![]()  
![]()  
![]()  
![]()  
![]()  
![]()  


## link list
![å•å‘é“¾è¡¨](./link_list/singly_linked_list.md)  
![åŒå‘é“¾è¡¨](./link_list/doubly_linked_list.md)  
![]()  

## tree
![æ ‘å½¢æ•°æ®ç»“æ„](./tree/tree_data_structures.md)  
![]()  


## ç±»å‹æ“¦é™¤ + ä¾èµ–æ³¨å…¥
![ä¾èµ–æ³¨å…¥ (Dependency Injection)](./DI/Dependency_Injection_in_C.md)  
[Dependency Injection](https://github.com/rahff/Software_book) #pdf  
[Dependency Injection in .NET](https://github.com/huutoannht/Books)#pdf  
[Design Pattern Online Training using .NET](https://dotnettutorials.net/lesson/design-patterns-online-training/)  
[Dependency Injection](https://blog.ploeh.dk/tags/#Dependency%20Injection-ref)  
[Hands-On Dependency Injection in Go](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go)  
[]()  
[]()  
[]()  
[]()  
```
æ ¸å¿ƒæ¦‚å¿µï¼š

    WITHOUT DI (ç´§è€¦åˆ)                    WITH DI (æ¾è€¦åˆ)

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  OrderService   â”‚                   â”‚  OrderService   â”‚
    â”‚                 â”‚                   â”‚                 â”‚
    â”‚  FileLogger log â”‚â”€â”€â”                â”‚  Logger *logger â”‚â”€â”€â–º <<interface>>
    â”‚  log.write(...) â”‚  â”‚                â”‚  logger->log()  â”‚         Logger
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
                        â”‚                                         â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
                        â–¼                                         â–¼         â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              FileLogger  MockLogger
                â”‚ FileLogger  â”‚
                â”‚ (hardcoded) â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Cè¯­è¨€å®ç°å…³é”®æŠ€æœ¯ï¼š

    /* æ¥å£ = å‡½æ•°æŒ‡é’ˆç»“æ„ä½“ */
    typedef struct Logger {
        void (*log)(struct Logger *self, const char *msg);
        void (*destroy)(struct Logger *self);
        void *private_data;  /* å®ç°ç‰¹å®šæ•°æ® */
    } Logger;

    /* æ„é€ å‡½æ•°æ³¨å…¥ */
    OrderService* order_service_create(Logger *logger) {
        OrderService *svc = malloc(sizeof(OrderService));
        svc->logger = logger;  /* æ³¨å…¥ä¾èµ– */
        return svc;
    }

è¯†åˆ«éœ€è¦ä¾èµ–æ³¨å…¥çš„ä»£ç åå‘³é“ï¼š

    åå‘³é“	        ç¤ºä¾‹
    ç›´æ¥å®ä¾‹åŒ–	    FileLogger *log = file_logger_create();
    å…¨å±€å˜é‡	    static Database *g_database;
    ç¡¬ç¼–ç è°ƒç”¨	    send_email("smtp.example.com", ...)
    æ¡ä»¶åˆ†æ”¯åˆ‡æ¢	if (use_file) {...} else if (use_syslog) {...}

é‡æ„6æ­¥éª¤ï¼š
    1. è¯†åˆ«ä¾èµ– - æ‰¾åˆ°å‡½æ•°å†…åˆ›å»ºçš„å…·ä½“å¯¹è±¡
    2. æå–æ¥å£ - å®šä¹‰å‡½æ•°æŒ‡é’ˆç»“æ„ä½“
    3. æ·»åŠ ä¾èµ–å­—æ®µ - åœ¨ä¸»ç»“æ„ä½“ä¸­æ·»åŠ æ¥å£æŒ‡é’ˆ
    4. æ„é€ å‡½æ•°æ³¨å…¥ - é€šè¿‡åˆ›å»ºå‡½æ•°ä¼ å…¥ä¾èµ–
    5. ä½¿ç”¨æ¥å£ - ä¸šåŠ¡é€»è¾‘åªè°ƒç”¨æ¥å£æ–¹æ³•
    6. ç»„åˆæ ¹ - åœ¨ main ä¸­åˆ›å»ºå’Œç»„è£…æ‰€æœ‰å¯¹è±¡
```
- ç±»å‹æ“¦é™¤  =  ç»Ÿä¸€æ¥å£ + void* ä½œä¸º Opaque å®ä¾‹
- ä¾èµ–æ³¨å…¥  =  å¤–éƒ¨æä¾›/èµ‹å€¼/æ³¨å†Œ opsï¼Œå®ç°æ§åˆ¶åè½¬å’Œå¯æ›¿æ¢å®ç°

- ç±»å‹æ“¦é™¤ (Type Erasure)
	æŠŠå…·ä½“ç±»å‹éšè—/æ“¦æ‰ï¼Œåªé€šè¿‡ä¸€ä¸ªç»Ÿä¸€çš„æŠ½è±¡æ¥å£æ¥æ“ä½œå¯¹è±¡

    - Cå®ç°æ–¹æ³•:
        void* ä½œä¸ºé€šç”¨å®¹å™¨ï¼ˆç±»å‹è¢«â€œæ“¦æ‰â€ï¼‰
        å‡½æ•°æŒ‡é’ˆ (*fn)(void*) ä½œä¸ºç»Ÿä¸€æ“ä½œæ¥å£

- ä¾èµ–æ³¨å…¥ (Dependency Injection, DI)
	ä¸€ä¸ªæ¨¡å—ä¸è‡ªå·±åˆ›å»ºå®ƒä¾èµ–çš„å¯¹è±¡ï¼Œè€Œæ˜¯ç”±å¤–éƒ¨æŠŠä¾èµ–"æ³¨å…¥"ï¼ˆä¼ å…¥ï¼‰ç»™å®ƒ

    - ç›®çš„:
        è§£è€¦
        æ–¹ä¾¿æ›¿æ¢å®ç°(Mock/Test/Plugin)
        æ§åˆ¶åè½¬(IoC: Inversion of Control)(ä½ ä¸æ‰¾ä¾èµ–ï¼Œè€Œæ˜¯ä¾èµ–æ‰¾ä½ )

    - Cå®ç°æ–¹æ³•:
        é€šè¿‡å‡½æ•°å‚æ•°ä¼ å…¥ä¾èµ–
        é€šè¿‡ç»“æ„ä½“ä¿å­˜ä¾èµ–çš„æ¥å£æˆ–void*æŒ‡é’ˆ

- ç¤ºä¾‹:
```c
/* version 1: å‡½æ•°å‚æ•°æ³¨å…¥ä¾èµ– */

#include <stdio.h>
#include <string.h>

// -------- æŠ½è±¡ä¾èµ–æ¥å£ï¼ˆç±»å‹æ“¦é™¤å°è£…ï¼‰ --------
typedef struct {
    void *instance;                     // è¢«æ“¦é™¤çš„å…·ä½“ç±»å‹
    void (*logFn)(void *, const char *);// ç»Ÿä¸€æ“ä½œæ¥å£
} Logger;

// -------- å…·ä½“ä¾èµ–å®ç° 1 --------
typedef struct {
    char prefix[16];
} ConsoleLogger;

void consoleLog(void *self, const char *msg) {
    ConsoleLogger *logger = (ConsoleLogger*)self;
    printf("%s: %s\n", logger->prefix, msg);
}

// -------- å…·ä½“ä¾èµ–å®ç° 2ï¼ˆå¯è¢«æ›¿æ¢ï¼‰--------
typedef struct { } SimpleLogger;

void simpleLog(void *self, const char *msg) {
    (void)self;
    printf("[LOG] %s\n", msg);
}

// -------- éœ€è¦è¢«æ³¨å…¥ä¾èµ–çš„å‡½æ•° --------
void fun(Logger logger) {
    logger.logFn(logger.instance, "Linux boot study is fun!");
}

// -------- main è´Ÿè´£åˆ›å»ºå¹¶æ³¨å…¥ä¾èµ– --------
int main() {
    // åˆ›å»º logger å®ç° 1
    ConsoleLogger clog;
    strcpy(clog.prefix, "Kernel");

    Logger logger1 = { &clog, consoleLog };
    fun(logger1);  // ä¾èµ–æ³¨å…¥ + ç±»å‹æ“¦é™¤è°ƒç”¨

    // ä¹Ÿå¯ä»¥æ›¿æ¢ä¸ºå®ç° 2
    SimpleLogger slog;
    Logger logger2 = { &slog, simpleLog };
    fun(logger2);  // æ— éœ€ä¿®æ”¹ fun å†…éƒ¨ä»£ç 

    return 0;
}

/* version 2: ç»“æ„ä½“æˆå‘˜æ³¨å…¥ä¾èµ– */

#include <stdio.h>
#include <string.h>

// è¢«æ“¦é™¤çš„ä¾èµ–æ¥å£
typedef struct {
    void *instance;
    void (*logFn)(void *, const char *);
} Logger;

// å…·ä½“ä¾èµ–å®ç°
typedef struct {
    char prefix[16];
} ConsoleLogger;

void consoleLog(void *self, const char *msg) {
    ConsoleLogger *logger = (ConsoleLogger*)self;
    printf("%s: %s\n", logger->prefix, msg);
}

// ä¸šåŠ¡æ¨¡å—ç»“æ„ä½“ï¼Œä¾èµ–é€šè¿‡æˆå‘˜æ³¨å…¥
typedef struct {
    Logger logger; // ä¾èµ–
} Module;

void fun(Module *module) {
    module->logger.logFn(module->logger.instance, "Injected by struct member!");
}

int main() {
    // åˆ›å»ºå…·ä½“ Logger
    ConsoleLogger clog;
    strcpy(clog.prefix, "Boot");

    // æ³¨å…¥åˆ° Module ç»“æ„ä½“æˆå‘˜
    Module m = { .logger = { &clog, consoleLog } };

    fun(&m);
    return 0;
}


/* version 3: å‡½æ•°æŒ‡é’ˆè¡¨æ¨¡æ‹Ÿé¢å‘å¯¹è±¡ + å¤šæ€ */

#include <stdio.h>
#include <string.h>

// ----- æ¨¡æ‹ŸæŠ½è±¡åŸºç±» -----
typedef struct Logger Logger;

typedef struct {
    void (*log)(Logger*, const char *);
} LoggerOps;

struct Logger {
    void *instance;
    LoggerOps *ops; // vtable
};

// ----- å…·ä½“ç±» 1 -----
typedef struct {
    char prefix[16];
} ConsoleLogger;

void consoleLogger_log(Logger *logger, const char *msg) {
    ConsoleLogger *c = (ConsoleLogger*)logger->instance;
    printf("%s: %s\n", c->prefix, msg);
}

LoggerOps consoleOps = {
    .log = (void(*)(Logger*,const char*))consoleLogger_log
};

// ----- å…·ä½“ç±» 2 -----
typedef struct { } SimpleLogger;

void simpleLogger_log(Logger *logger, const char *msg) {
    (void)logger;
    printf("[SIMPLE] %s\n", msg);
}

LoggerOps simpleOps = {
    .log = (void(*)(Logger*,const char*))simpleLogger_log
};

// ----- ä¸šåŠ¡ä»£ç ï¼Œä¾èµ–æŠ½è±¡ Loggerï¼ˆå¤šæ€ï¼‰ -----
typedef struct {
    Logger logger; // é€šè¿‡æˆå‘˜ç»„åˆæŒæœ‰
} Module;

void fun(Module *m) {
    m->logger.ops->log((Logger*)&m->logger.ops[-1], "Polymorphism style!"); 
    // â†‘ è¿™é‡Œåªæ˜¯æ¼”ç¤º Linux-like ops è°ƒç”¨ï¼Œä¸æ¨èåœ¨çœŸå®ä»£ç é‡Œè¿™ä¹ˆå†™
}

int main() {
    // åˆ›å»ºå…·ä½“å¯¹è±¡ 1
    ConsoleLogger clog;
    strcpy(clog.prefix, "Kernel");
    Logger logger1 = { .instance = &clog, .ops = &consoleOps };

    // åˆ›å»ºå…·ä½“å¯¹è±¡ 2
    SimpleLogger slog;
    Logger logger2 = { .instance = &slog, .ops = &simpleOps };

    Module m1 = { .logger = logger1 };
    Module m2 = { .logger = logger2 };

    printf("--- module 1 ---\n");
    fun(&m1);

    printf("--- module 2 ---\n");
    fun(&m2);

    return 0;
}

/* version 4: Mini æ’ä»¶æ¡†æ¶ */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ----- æ’ä»¶ Ops æ¥å£ï¼ˆæŠ½è±¡èƒ½åŠ›ï¼Œç±»ä¼¼ Linux driver/file opsï¼‰-----
typedef struct {
    const char *name;
    void (*run)(void*);
    void (*destroy)(void*);
} PluginOps;

// ----- æ’ä»¶å®ä¾‹çš„é€šç”¨å®¹å™¨ï¼ˆç±»å‹æ“¦é™¤ï¼‰-----
typedef struct Plugin {
    void *instance;
    PluginOps *ops;
} Plugin;

// ----- æ’ä»¶å®ç° 1 -----
typedef struct {
    char message[64];
} PluginA;

void pluginA_run(void *self) {
    PluginA *a = (PluginA*)self;
    printf("[PluginA Run] %s\n", a->message);
}

void pluginA_destroy(void *self) {
    printf("[PluginA Destroy]\n");
    free(self);
}

PluginOps pluginA_ops = {
    .name = "pluginA",
    .run = pluginA_run,
    .destroy = pluginA_destroy,
    .destroy = pluginA_destroy
};

// ----- æ’ä»¶å®ç° 2 -----
typedef struct { int x; } PluginB;

void pluginB_run(void *self) {
    PluginB *b = (PluginB*)self;
    printf("[PluginB Run] x = %d\n", b->x);
}

void pluginB_destroy(void *self) {
    printf("[PluginB Destroy]\n");
    free(self);
}

PluginOps pluginB_ops = {
    .name = "pluginB",
    .run = pluginB_run,
    .destroy = pluginB_destroy
};

// ----- æ¡†æ¶æ ¸å¿ƒï¼šæ’ä»¶æ³¨å†Œä¸æ§åˆ¶åè½¬ï¼ˆä¾èµ–æ³¨å…¥ç‚¹ï¼‰-----
#define MAX_PLUGINS 8
Plugin *registry[MAX_PLUGINS];
int count = 0;

void registerPlugin(void *instance, PluginOps *ops) {
    if (count >= MAX_PLUGINS) return;
    registry[count] = malloc(sizeof(Plugin));
    registry[count]->instance = instance;
    registry[count]->ops = ops;
    count++;
}

void runAll() {
    for (int i = 0; i < count; i++) {
        printf(">>> running %s\n", registry[i]->ops->name);
        registry[i]->ops->run(registry[i]->instance);
    }
}

void cleanup() {
    for (int i = 0; i < count; i++) {
        registry[i]->ops->destroy(registry[i]->instance);
        free(registry[i]);
    }
}

int main() {
    // åˆ›å»ºå¹¶æ³¨å…¥ PluginA
    PluginA *a = malloc(sizeof(PluginA));
    strcpy(a->message, "Hello from pluginA");

    // åˆ›å»ºå¹¶æ³¨å…¥ PluginB
    PluginB *b = malloc(sizeof(PluginB));
    b->x = 42;

    // æ³¨å†Œåˆ°æ¡†æ¶ï¼ˆä¾èµ–æ³¨å…¥ + ç±»å‹æ“¦é™¤ï¼‰
    registerPlugin(a, &pluginA_ops);
    registerPlugin(b, &pluginB_ops);

    // è¿è¡Œæ’ä»¶
    runAll();

    // æ¸…ç†
    cleanup();
    return 0;
}

/* linux å†…æ ¸ä»£ç ä¸­ç±»å‹æ“¦é™¤ä¸ä¾èµ–æ³¨å…¥ æ ¸å¿ƒä»£ç æ‘˜è¦ */

// ç±»å‹æ“¦é™¤ (Type Erasure)ï¼švoid* + opsï¼ˆå‡½æ•°æŒ‡é’ˆè¡¨ / vtableï¼‰
// æŠ½è±¡èƒ½åŠ›é€šè¿‡ ops æè¿°ï¼Œå®ä¾‹ç”¨ void* æ“¦é™¤å…·ä½“ç±»å‹
struct file_operations {
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    int     (*open) (struct inode *, struct file *);
};

struct device_driver {
    const char *name;
    int (*probe)(struct device *);   // ç»Ÿä¸€å…¥å£
    void(*remove)(struct device *);
};

// å…·ä½“å®ä¾‹æ˜¯ opaque çš„ï¼Œåªçœ‹æˆ void*
struct file {
    const struct file_operations *f_op;
    void *private_data;  // ç±»å‹è¢«æ“¦é™¤
}

è°ƒç”¨ç‚¹ï¼šä¸å…³å¿ƒå®é™…ç±»å‹ï¼Œåªå…³å¿ƒ ops

file->f_op->read(...);
drv->probe(dev);  // ç»Ÿä¸€è°ƒç”¨

// ä¾èµ–æ³¨å…¥ (Dependency Injection / IoC)ï¼šæ ¸å¿ƒä¸è‡ªå·±åˆ›å»ºï¼Œç”±æ¡†æ¶å±‚ä¼ å…¥æˆ–æ³¨å†Œ
// æ¡†æ¶å±‚åˆ›å»ºç¡¬ä»¶æŠ½è±¡å¯¹è±¡ï¼Œå¹¶æ³¨å…¥ Driver ops
driver->probe = my_probe_impl;  // é€šè¿‡èµ‹å€¼æ³¨å…¥ä¾èµ–å®ç°

// å¹³å°/ç¡¬ä»¶ä¿¡æ¯ç”±å¤–éƒ¨æ³¨å…¥ï¼Œè€Œä¸æ˜¯ Driver å†…éƒ¨ç”Ÿæˆ
int my_probe_impl(struct device *dev) {
    struct of_node *dn = dev->of_node; 
    const void *dt_data = of_get_property(dn, "config", NULL);
    // â†‘ è®¾å¤‡é…ç½®ä¿¡æ¯æ¥è‡ª Device Tree (bootloader/æ¡†æ¶ä¼ å…¥)
}

Linux å…¸å‹æ•°æ®æµï¼ˆæ§åˆ¶åè½¬ï¼‰ï¼š

Bootloader è§£æ DTB -> åˆ›å»º device -> æ³¨å†Œ/åŒ¹é… driver -> è°ƒç”¨ driver->probe(device)

Driver ä¸è´Ÿè´£ new è®¾å¤‡å¯¹è±¡æˆ–å¹³å°æ•°æ®ï¼Œå®ƒåªæ˜¯è¢«åŠ¨å®ç° ops->probe()ï¼Œä¾èµ–ç”±å¤–éƒ¨æ³¨å…¥

```

- Linux `start_kernel()` ä¸­çš„ IoCï¼ˆæ§åˆ¶åè½¬ï¼‰ä½“ç°æ€»ç»“
    - Linux å¯åŠ¨åˆå§‹åŒ–éµå¾ªå…¸å‹çš„**æ§åˆ¶åè½¬ (IoC)** è®¾è®¡ï¼š
        **æ ¸å¿ƒï¼ˆä¸Šå±‚ï¼‰ä»£ç æŒæ§æµç¨‹**
        **å…·ä½“æ¨¡å—åªæ³¨å†Œèƒ½åŠ›/å›è°ƒ (ops)ï¼Œä¸ç›´æ¥æ‰§è¡Œè°ƒç”¨**
        **å¯¹è±¡å’Œä¾èµ–å®ä¾‹ç”±æ¡†æ¶å±‚åˆ›å»ºæˆ–æ³¨å…¥**
        **è°ƒç”¨æ—¶æœºç”±æ¡†æ¶ç¼–æ’ï¼Œè€Œéæ¨¡å—å†…éƒ¨å†³å®š**

- 1. Console æœºåˆ¶ï¼šä¾èµ–æ³¨å…¥ + å›è°ƒæ³¨å†Œ (IoC + DI)

    - å…³é”®ç‚¹
        `start_kernel()` è°ƒç”¨ `console_init()` åªæ˜¯åˆå§‹åŒ– console æ¡†æ¶
        **å…·ä½“ `write` å®ç°ç”± Console Driver é€šè¿‡ `register_console()` æ³¨å…¥**
        print/log ä»£ç  later åªé€šè¿‡ `console->write()` è°ƒç”¨ï¼Œä¸å…³å¿ƒå…·ä½“ç±»å‹

    - æ ¸å¿ƒä»£ç æ‘˜è¦
        ```c
        void console_init(void) {
            // åˆå§‹åŒ– console æ¡†æ¶ï¼ˆconsole_list ç­‰ï¼‰ï¼Œä½†ä¸åŒ…å«å…·ä½“ write å®ç°
        }

        register_console(&my_console);  // Console driver æ³¨å…¥å…·ä½“ ops

        struct console {
            void (*write)(struct console *con, const char *s, unsigned n); // å›è°ƒè¡¨
        };
    
    - è¯´æ˜
        print ä»£ç ä¸æ˜¯ä¸»åŠ¨æ§åˆ¶è°æ‰“å°ã€æ€ä¹ˆæ‰“å°ï¼Œè€Œæ˜¯æŠŠæ§åˆ¶æƒäº¤ç»™å…·ä½“ console driver é€šè¿‡ ops æä¾›å®ç° â†’ æ§åˆ¶åè½¬

- Bus/Driver/Device Modelï¼šè®¾å¤‡ç”±æ¡†æ¶åˆ›å»ºï¼ŒProbe later è§¦å‘
    - å…³é”®ç‚¹
        å†…æ ¸å…ˆ bus_register() å»ºç«‹ç»Ÿä¸€æ€»çº¿æ¡†æ¶
        driver_register() åªæ˜¯æ³¨å†Œ opsï¼Œä¸å†³å®š probe æ—¶æœº
        struct device ç”± Bootloader è§£æ DTã€ACPIã€bus scan æˆ– hotplug ç”Ÿæˆå¹¶æ³¨å…¥ Driver
        framework later è§¦å‘ driver->probe(dev)

    - æ ¸å¿ƒä»£ç æ‘˜è¦
    ```c
    bus_register(&platform_bus_type); // å†…æ ¸å»ºç«‹ Bus æ¡†æ¶

    driver_register(&drv); 
        // ä»…æ³¨å†Œ probe/remove/suspend ç­‰ opsï¼Œä¸ç«‹å³è°ƒç”¨

    platform_device_register(dev); 
        // è®¾å¤‡ç”± platform/æ¡†æ¶åˆ›å»ºå¹¶æ³¨å…¥ model

    ---------------------------------------

    struct device_driver {
        const char *name;
        int  (*probe)  (struct device *dev);
        void (*remove) (struct device *dev);
    };

    struct device {
        const struct device_driver *driver; // later ç”±æ¡†æ¶ä¾èµ–æ³¨å…¥
        void *platform_data; // ç±»å‹æ“¦é™¤ï¼Œopaque ä¾èµ–å®ä¾‹
    };
    ```

    -è¯´æ˜
        åˆ›å»ºå¯¹è±¡ + è°ƒç”¨è°ƒç”¨æ—¶æœºæ§åˆ¶æƒåœ¨ Bus æ¡†æ¶ï¼Œä¸åœ¨ driver â†’ IoC

- initcall æœºåˆ¶ï¼šåˆå§‹åŒ–å‡½æ•°ç”±æ¨¡å—æ³¨å†Œï¼Œç”±å†…æ ¸ later æŒ‰ section è°ƒç”¨
    - å…³é”®ç‚¹
        æ¨¡å—é€šè¿‡ *_initcall(fn) æ³¨å†Œåˆå§‹åŒ–èƒ½åŠ›
        start_kernel() later ç»Ÿä¸€æŒ‰é¢„å®šä¹‰é¡ºåºè°ƒç”¨ï¼Œä¸æ˜¯æ¨¡å—å†…éƒ¨è°ƒç”¨
        è®©å†…æ ¸åˆå§‹åŒ–è¿‡ç¨‹å¯æ‰©å±• + å¯å®šåˆ¶

    - æ ¸å¿ƒä»£ç æ‘˜è¦
    ```c
    early_initcall(my_early_fn);   // å…³é”®åŸºç¡€èƒ½åŠ›æ³¨å†Œ
    core_initcall(my_core_fn);     // æ ¸å¿ƒæœºåˆ¶æ³¨å†Œ
    device_initcall(my_driver_fn); // è®¾å¤‡é©±åŠ¨ç±»åˆå§‹åŒ–æ³¨å†Œ

    // start_kernel later ç»Ÿä¸€è°ƒç”¨æ‰€æœ‰æ³¨å†Œçš„ initcallï¼ˆæ§åˆ¶åè½¬ï¼‰
    do_initcalls();
    ```

    - è¯´æ˜
        initcall çš„æ³¨å†Œè€…æä¾›èƒ½åŠ›å®šä¹‰ï¼ŒçœŸæ­£æ‰§è¡Œè€…æ˜¯å†…æ ¸æ¡†æ¶ï¼Œè°ƒç”¨é¡ºåºæ¥è‡ª ELF section æ³¨å†Œå¸ƒå±€ â†’ IoC

-  ops ç»“æ„ä½“ + void* å®ä¾‹ï¼šLinux style OOP æŠ½è±¡ä¸å¤šæ€
    - å…³é”®ç‚¹
        é€šè¿‡å‡½æ•°æŒ‡é’ˆè¡¨å®ç°é¢å‘å¯¹è±¡ä¸å¤šæ€
        é€šè¿‡ void* æ“¦é™¤ç±»å‹å®ç°Opaque ä¾èµ–å®ä¾‹
        å…·ä½“èƒ½åŠ›é€šè¿‡ ops æä¾›ï¼Œä¾èµ–é€šè¿‡æˆå‘˜æ³¨å…¥ (DI)

    - æ ¸å¿ƒä»£ç æ‘˜è¦
    ```c
    struct file_operations {
        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
        int     (*open) (struct inode *, struct file *);
    };

    struct net_device_ops {
        int (*ndo_start_xmit)(struct sk_buff *skb, struct net_device *dev);
    };

    struct file {
        const struct file_operations *f_op; // ä¾èµ–æ³¨å…¥ (DI)
        void *private_data; // ç±»å‹æ“¦é™¤ (Type Erasure)
    };
    ```

    - è¯´æ˜
        è¿™äº›ç³»ç»Ÿè°ƒç”¨ç‚¹ later é€šè¿‡ file->f_op->read()ã€dev->netdev_ops->ndo_start_xmit() è¿›è¡Œè°ƒç”¨ï¼Œ
        ä¸Šå±‚ä¸å…³å¿ƒå…·ä½“ç±»å‹ï¼Œåªå…³å¿ƒè¡Œä¸ºæ¥å£ ops â†’ IoC + Polymorphism

-  IoC åœ¨ Linux å¯åŠ¨é˜¶æ®µæ•°æ® & æ§åˆ¶æµæ€»è§ˆ
    Power On
    â†“ (ç¡¬ä»¶æµç¨‹æŒæ§è€…)
    BIOS / Firmware (UEFI)
    â†“ (åŠ è½½ä¸åŒ…è£¹æ‰§è¡Œç¯å¢ƒï¼Œä½†ä¸æŒæ§ kernel init é€»è¾‘)
    Bootloader (GRUB / U-Boot / etc)
    â†“ (è§£æç¡¬ä»¶é…ç½®ï¼Œæ„å»º Device Tree / å¹³å°ä¿¡æ¯)
    Kernel (`start_kernel()`)
    â†“ (æ„å»º IoC æ¡†æ¶å®¹å™¨ï¼Œæ³¨å†Œæœºåˆ¶)
    bus_register(), console_init()
    â†“ (æ³¨å†Œæ¨¡å—èƒ½åŠ›)
    driver_register(), *_initcall(fn)
    â†“ (Later è§¦å‘â€”â€”è°ƒç”¨æ—¶æœºäº¤ç»™ framework)
    driver->probe(device), console->write(...), do_initcalls()
    â†“ (æœ€åæ§åˆ¶åè½¬äº¤åˆ°ç”¨æˆ·æ€è¿›ä¸€æ­¥æ¥ç®¡)
    PID1 init è¿›ç¨‹å¯åŠ¨

- ä¸€å¥è¯æ€»ç»“
Linux å¯åŠ¨åˆå§‹åŒ–ä¸­çš„ IoC æœ¬è´¨ï¼š
    æ¡†æ¶å±‚åˆ›å»ºå¯¹è±¡ + æŒæ§è°ƒç”¨æ—¶æœºï¼›
    æ¨¡å—å±‚æ³¨å†Œèƒ½åŠ›/ops + æ¥æ”¶ä¾èµ–å®ä¾‹ï¼›
    è°ƒç”¨ç‚¹ä¸å…³å¿ƒåº•å±‚ç±»å‹ï¼Œä»…è°ƒç”¨ ops æŒ‡é’ˆ

## ä¾èµ–æ³¨å…¥DI/IoC(Inversion of Control)
![linuxé©±åŠ¨æ¨¡å‹](./01_driver_model_ioc.md)  
![linux consoleå­ç³»ç»Ÿ](./02_console_subsystem_ioc.md)  
![VFSå¤šæ€](./03_vfs_polymorphic_ops_ioc.md)  
![ç½‘ç»œå­ç³»ç»Ÿ](./04_net_device_ops_ioc.md)  
![initcallç¼–æ’æœºåˆ¶](./05_initcall_mechanism_ioc.md)  

- linux-ioc-patterns
â”œâ”€â”€ README.md                    (360è¡Œ)  - ç´¢å¼•ä¸å­¦ä¹ æŒ‡å—
â”œâ”€â”€ 01_driver_model.md          (947è¡Œ)  - Linux é©±åŠ¨æ¨¡å‹
â”œâ”€â”€ 02_console_subsystem.md     (786è¡Œ)  - æ§åˆ¶å°å­ç³»ç»Ÿ
â”œâ”€â”€ 03_vfs_file_operations.md   (807è¡Œ)  - VFS å¤šæ€ ops
â”œâ”€â”€ 04_net_device_ops.md        (920è¡Œ)  - ç½‘ç»œè®¾å¤‡ ops
â””â”€â”€ 05_initcall_mechanism.md    (791è¡Œ)  - initcall æœºåˆ¶

- äº”ç§ IoC æ¨¡å¼å¯¹æ¯”
    åœºæ™¯	        æ³¨å…¥æ—¶æœº	                æ§åˆ¶åè½¬ä½“ç°	                           æ ¸å¿ƒå¥½å¤„
    Driver Model	è¿è¡Œæ—¶ (driver_register)	é©±åŠ¨ä¸ä¸»åŠ¨æ‰¾è®¾å¤‡ï¼Œæ¡†æ¶è‡ªåŠ¨åŒ¹é…ç»‘å®š	        çƒ­æ’æ‹”ã€ç»Ÿä¸€ç”Ÿå‘½å‘¨æœŸ
    Console	        è¿è¡Œæ—¶ (register_console)	printk ä¸çŸ¥é“è¾“å‡ºåˆ°å“ªï¼Œconsole åŠ¨æ€æ³¨å…¥	   å¤šè¾“å‡ºå¹¶è¡Œã€è¿è¡Œæ—¶åˆ‡æ¢
    VFS ops	        è¿è¡Œæ—¶ (inode åˆ›å»ºæ—¶)	    read/write è°ƒç”¨ä¸å…³å¿ƒå…·ä½“æ–‡ä»¶ç³»ç»Ÿ	        ç»Ÿä¸€æ¥å£ã€å¤šæ€å®ç°
    net_device_ops	è¿è¡Œæ—¶ (probe æ—¶)	        åè®®æ ˆä¸å…³å¿ƒå…·ä½“ç¡¬ä»¶	                   ç¡¬ä»¶æŠ½è±¡ã€ä¸­é—´å±‚è®¾å¤‡
    initcall	    ç¼–è¯‘æ—¶ (é“¾æ¥å™¨)	            æ¨¡å—ä¸å†³å®šåˆå§‹åŒ–æ—¶æœºå’Œé¡ºåº	                è‡ªåŠ¨æ’åºã€é›¶è€¦åˆ

- IoC å…±åŒæ¨¡å¼
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Linux å†…æ ¸ IoC é€šç”¨æ¨¡å¼                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   1. å®šä¹‰æ¥å£å¥‘çº¦ (å‡½æ•°æŒ‡é’ˆç»“æ„ä½“)                                           â”‚
â”‚      struct xxx_ops {                                                        â”‚
â”‚          int (*operation_a)(...);                                           â”‚
â”‚          int (*operation_b)(...);                                           â”‚
â”‚      };                                                                      â”‚
â”‚                                                                              â”‚
â”‚   2. å…·ä½“å®ç°æ³¨å…¥ (å¡«å……å‡½æ•°æŒ‡é’ˆ)                                             â”‚
â”‚      static const struct xxx_ops my_ops = {                                 â”‚
â”‚          .operation_a = my_impl_a,                                          â”‚
â”‚          .operation_b = my_impl_b,                                          â”‚
â”‚      };                                                                      â”‚
â”‚                                                                              â”‚
â”‚   3. æ³¨å†Œåˆ°æ¡†æ¶ (å…³è”å¯¹è±¡ä¸ ops)                                             â”‚
â”‚      obj->ops = &my_ops;                                                    â”‚
â”‚      register_xxx(obj);                                                     â”‚
â”‚                                                                              â”‚
â”‚   4. æ¡†æ¶è°ƒç”¨ (å¤šæ€åˆ†å‘)                                                     â”‚
â”‚      obj->ops->operation_a(...);                                            â”‚
â”‚                                                                              â”‚
â”‚   å¥½å¤„:                                                                      â”‚
â”‚   - è°ƒç”¨è€…ä¸å®ç°è§£è€¦                                                         â”‚
â”‚   - æ”¯æŒè¿è¡Œæ—¶æ›¿æ¢                                                           â”‚
â”‚   - ç»Ÿä¸€çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†                                                       â”‚
â”‚   - æ˜“äºæ‰©å±•æ–°å®ç°                                                           â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## äºŒçº§æŒ‡é’ˆ
![Cè¯­è¨€ä¸­äºŒçº§æŒ‡é’ˆ](./Cè¯­è¨€ä¸­äºŒçº§æŒ‡é’ˆ.md)  

## æœºåˆ¶ä¸ç­–ç•¥åˆ†ç¦»
![Linuxå†…æ ¸ä¸­æœºåˆ¶ä¸ç­–ç•¥åˆ†ç¦»çš„å…¸å‹åœºæ™¯](./Linuxå†…æ ¸ä¸­æœºåˆ¶ä¸ç­–ç•¥åˆ†ç¦»çš„å…¸å‹åœºæ™¯.md)  
![Cè¯­è¨€æœºåˆ¶ä¸ç­–ç•¥åˆ†ç¦»ç¤ºä¾‹ä»£ç ](./Cè¯­è¨€æœºåˆ¶ä¸ç­–ç•¥åˆ†ç¦»ç¤ºä¾‹ä»£ç .md)  
![private_data usage demo](./private_data_demo.c)  
![]()  
- æœºåˆ¶
    æœºåˆ¶è´Ÿè´£'èƒ½åšä»€ä¹ˆ'ï¼Œå®ƒæä¾›ä¸€ç»„èƒ½åŠ›/é’©å­/APIï¼Œæœ¬èº«ä¸å†³å®šè¦æ€ä¹ˆç”¨

- ç­–ç•¥
    ç­–ç•¥è´Ÿè´£'å…·ä½“æ€ä¹ˆåš'ï¼Œå†³å®šå…·ä½“è¡Œä¸º

- æœºåˆ¶ä¸ç­–ç•¥åˆ†ç¦»çš„ä¼˜åŠ¿
    å¯æ‰©å±•ï¼šå¢åŠ æ–°ç­–ç•¥ï¼Œåªéœ€å®ç°ä¸€ç»„å›è°ƒ / æ–°çš„ç­–ç•¥æ¨¡å—ï¼Œä¸æ”¹é€šç”¨æœºåˆ¶
    å¯æµ‹è¯•ï¼šæœºåˆ¶ä»£ç å¯ä»¥ç”¨ 'å‡ç­–ç•¥' æµ‹è¯•ï¼ˆä¾‹å¦‚ stub ç­–ç•¥ï¼‰ï¼Œæ–¹ä¾¿å•å…ƒæµ‹è¯•
    å¯å¤ç”¨ï¼šåŒä¸€æœºåˆ¶å¯ä»¥è¢«å¤šä¸ªç­–ç•¥ä½¿ç”¨ï¼ˆä¾‹å¦‚ä¸åŒè°ƒåº¦ç®—æ³•ã€ä¸åŒæ—¥å¿—åç«¯ï¼‰
    éš”ç¦»å¤æ‚æ€§ï¼šå¤æ‚ä¸šåŠ¡é€»è¾‘é›†ä¸­åœ¨ç­–ç•¥å±‚ï¼Œæœºåˆ¶å±‚ä»£ç æ›´å°ã€æ›´ç¨³å®š

- å…³é”®æ€æƒ³
    æœºåˆ¶ = é€šç”¨æ¡†æ¶ + é’©å­
    ç­–ç•¥ = é€šè¿‡é’©å­å¡«å…¥çš„å…·ä½“å®ç°

- å¦‚ä½•å®ç°æœºåˆ¶ä¸ç­–ç•¥åˆ†ç¦»
    1. è¯†åˆ«æœºåˆ¶
        æ‰¾å‡º 'æ€»æ˜¯éœ€è¦çš„æ¡†æ¶æ€§å·¥ä½œ'ï¼Œä¾‹å¦‚
            å¾ªç¯è°ƒåº¦æ¡†æ¶ï¼ˆwhile(1) è½®è¯¢ï¼‰
            å…±äº«å†…å­˜æ˜ å°„ã€é”ç®¡ç†
            åè®®æŠ¥æ–‡çš„é€šç”¨è§£æ
    2. è¯†åˆ«ç­–ç•¥
        æ‰¾å‡º 'ç»å¸¸å˜' çš„è§„åˆ™ï¼Œä¾‹å¦‚
            ä¸åŒçš„è½¬å‘ç­–ç•¥ / ACL / è®¡è´¹è§„åˆ™
            ä¸åŒçš„è°ƒåº¦ç®—æ³• / ä¼˜å…ˆçº§è§„åˆ™
            ä¸åŒçš„å¯¼å‡ºç›®æ ‡ï¼ˆcollectd / Prometheus / è‡ªå®šä¹‰ logï¼‰
    3. æŠ½è±¡å‡ºæ¥å£
        è®¾è®¡ä¸€ä¸ª *_ops ç»“æ„ä½“ï¼Œæˆ–ä¸€ç»„å‡½æ•°æŒ‡é’ˆ
        è®©æœºåˆ¶ä»£ç åªé¢å‘è¿™ä¸ªæ¥å£ï¼Œè€Œä¸æ˜¯å…·ä½“å®ç°
    4. é€šè¿‡æ³¨å…¥é€‰æ‹©ç­–ç•¥
        åœ¨åˆå§‹åŒ–é˜¶æ®µï¼Œæ ¹æ®é…ç½® / ç¼–è¯‘é€‰é¡¹åˆ›å»ºå…·ä½“ç­–ç•¥å¯¹è±¡ï¼Œå¡«å¥½ ops å’Œ ctx
        æŠŠå®ƒä»¬äº¤ç»™æœºåˆ¶å±‚ç»Ÿä¸€ä½¿ç”¨
    5. ä¿æŒæ¥å£ç¨³å®š
        æ”¹ç­–ç•¥æ—¶ï¼ŒåªåŠ¨æ–°ç­–ç•¥æ¨¡å—ï¼Œä¸æ”¹æœºåˆ¶å±‚ API
        æœºåˆ¶å±‚åªåšä¸ç­–ç•¥æ— å…³çš„é€šç”¨å·¥ä½œï¼ˆèµ„æºç®¡ç†ã€è°ƒåº¦æ¡†æ¶ã€é”™è¯¯å¤„ç†ï¼‰

- Cè¯­è¨€ä¸­æœºåˆ¶ä¸ç­–ç•¥åˆ†ç¦»çš„å®ç°æ‰‹æ®µ
    å‡½æ•°æŒ‡é’ˆ
    å›è°ƒè¡¨
    ä¸é€æ˜æŒ‡é’ˆ
    æ¨¡å—åŒ–è®¾è®¡

```c
// å›è°ƒè¡¨
// å…¸å‹å†™æ³•: æœºåˆ¶å®šä¹‰ä¸€ä¸ª 'æ“ä½œè¡¨(ops)'ï¼Œç­–ç•¥æä¾›å…·ä½“å®ç°
typedef struct {
    int  (*open)(void *ctx);
    int  (*close)(void *ctx);
    int  (*send)(void *ctx, const void *buf, size_t len);
    int  (*recv)(void *ctx, void *buf, size_t len);
} net_ops_t;

typedef struct {
    net_ops_t *ops;  // ç­–ç•¥
    void      *ctx;  // ç­–ç•¥ä¸Šä¸‹æ–‡ï¼ˆsocketã€fdã€DPDK port ç­‰ï¼‰
} net_if_t;

// æœºåˆ¶ï¼šä¸Šå±‚åªä¾èµ– net_if_tï¼Œä¸å…³å¿ƒå…·ä½“ç­–ç•¥
int net_send_packet(net_if_t *iface, const void *buf, size_t len)
{
    return iface->ops->send(iface->ctx, buf, len);
}
/*
æœºåˆ¶å±‚ï¼šnet_send_packet ç­‰å‡½æ•°ï¼ŒåªçŸ¥é“é€šè¿‡ ops->send å‘é€
ç­–ç•¥å±‚ï¼šæä¾› tcp_opsã€udp_opsã€dpdk_ops ç­‰ä¸åŒå®ç°
å½“æ¢æˆ DPDKã€AF_XDP æˆ–æ™®é€š socketï¼Œåªéœ€è¦æ¢ ops å’Œ ctxï¼Œæœºåˆ¶ä¸å˜
*/

// ä¸Šä¸‹æ–‡ç»“æ„ + å›è°ƒ
// å¸¸è§äºåº“æˆ–æ¡†æ¶ï¼šæœºåˆ¶å®šä¹‰ä¸€ä¸ªâ€œæ¡†æ¶æµç¨‹â€ï¼Œç•™å‡ºè‹¥å¹²å›è°ƒç‚¹
typedef struct {
    int  (*on_packet)(void *user_ctx, const uint8_t *pkt, size_t len);
    void (*on_error)(void *user_ctx, int err);
    void *user_ctx;
} packet_handler_t;

// æœºåˆ¶ï¼šè½®è¯¢æ”¶åŒ…ï¼Œå¹¶åœ¨é€‚å½“æ—¶æœºè°ƒç”¨ç­–ç•¥
void run_loop(int fd, packet_handler_t *handler)
{
    uint8_t buf[2048];
    ssize_t len;

    for (;;) {
        len = recv(fd, buf, sizeof(buf), 0);
        if (len < 0) {
            if (handler->on_error)
                handler->on_error(handler->user_ctx, errno);
            continue;
        }
        if (handler->on_packet)
            handler->on_packet(handler->user_ctx, buf, (size_t)len);
    }
}

/*
run_loop æ˜¯æ•°æ®é¢æœºåˆ¶ï¼šè´Ÿè´£æ”¶åŒ…ã€å¾ªç¯ã€é”™è¯¯å¤„ç†æ¡†æ¶
ç­–ç•¥é€šè¿‡ handler->on_packet å’Œ user_ctx å†³å®šâ€œæ¯ä¸ªåŒ…æ€ä¹ˆå¤„ç†â€
*/

// void * + ç”¨æˆ·è‡ªå®šä¹‰æ•°æ®ç»“æ„
// æœºåˆ¶å®šä¹‰æ“ä½œæ¥å£å’Œä¸€ä¸ªä¸é€æ˜çš„ void * å¥æŸ„ï¼Œç­–ç•¥å®šä¹‰çœŸæ­£çš„ç»“æ„å’Œè¡Œä¸º
typedef struct allocator allocator_t;

allocator_t *allocator_create(void *impl, 
                              void *(*alloc)(void *impl, size_t),
                              void (*dealloc)(void *impl, void *));
void        *allocator_alloc(allocator_t *a, size_t size);
void         allocator_free(allocator_t *a, void *p);

/*
æœºåˆ¶ï¼šåªå®ç° allocator_t çš„è°ƒåº¦ã€ç»Ÿè®¡ã€é”ç­‰é€šç”¨é€»è¾‘
ç­–ç•¥ï¼šåœ¨ impl ä¸­æ”¾ä¸åŒç®—æ³•çš„æ•°æ®ç»“æ„ï¼ˆbuddy/é“¾è¡¨/slabï¼‰ï¼Œå¹¶æä¾›ç›¸åº”åˆ†é…/é‡Šæ”¾å‡½æ•°
*/

// è°ƒåº¦å™¨ï¼ˆSchedulerï¼‰ä¸è°ƒåº¦ç®—æ³•
// æœºåˆ¶: æä¾›â€œæ·»åŠ ä»»åŠ¡â€ã€â€œé€‰æ‹©ä¸‹ä¸€ä¸ªä»»åŠ¡â€ã€â€œè®°å½•è°ƒåº¦ç»Ÿè®¡â€ç­‰åŸºæœ¬æ“ä½œ
// ç­–ç•¥: FIFOã€ä¼˜å…ˆçº§é˜Ÿåˆ—ã€åŠ æƒè½®è¯¢ï¼ˆWRRï¼‰ã€WFQã€DRR ç­‰
// å®šä¹‰é€šç”¨çš„ scheduler_t
typedef struct scheduler_ops {
    void (*enqueue)(void *ctx, task_t *t);
    task_t *(*dequeue)(void *ctx);
} scheduler_ops_t;

typedef struct {
    scheduler_ops_t *ops;
    void            *ctx;
} scheduler_t;
// å„ç§è°ƒåº¦ç®—æ³•å®ç°è‡ªå·±çš„ ctx + opsï¼Œç»Ÿä¸€æŒ‚åœ¨ scheduler_t ä¸Šä½¿ç”¨
// å¾ˆå¤šç½‘ç»œæ ˆã€ç‰¹åˆ«æ˜¯ DPDK HQoSã€SF é˜Ÿåˆ—è¿™ç±»ä»£ç ï¼Œéƒ½é‡‡ç”¨è¿™ç§æ¨¡å¼

// æ—¥å¿—æœºåˆ¶ä¸æ—¥å¿—ç­–ç•¥
æœºåˆ¶ï¼šæä¾› log_debug, log_info, log_error ç­‰ç»Ÿä¸€å…¥å£ï¼Œå¹¶å¤„ç†çº¿ç¨‹å®‰å…¨ã€æ ¼å¼åŒ–
ç­–ç•¥ï¼š
    è¾“å‡ºåˆ° syslog
    è¾“å‡ºåˆ°æ–‡ä»¶
    è¾“å‡ºåˆ°è¿œç¨‹ server æˆ– ring buffer

C å®ç°ï¼š
    åœ¨ log_init() æ—¶æ³¨å†Œä¸€ä¸ª log_backend å›è°ƒè¡¨ï¼ˆwrite_line, flushï¼‰
    ä¸åŒéƒ¨ç½²é€šè¿‡é…ç½®é€‰æ‹©ä¸åŒç­–ç•¥å®ç°
```

## mark a function parameter as intentionally unused
```c
void handler(int event, void *ctx)
{
    (void)ctx;  // ctx required by the signature, but unused
    printf("event = %d\n", event);
}

// how (void)parameter; works
It performs a cast-to-void, which evaluates parameter but explicitly throws away the result.
This counts as a â€œuseâ€, so the compiler no longer warns.
It has zero runtime effect: the compiler optimizes it out completely.

(void)parameter; is used to:
    âœ” Silence "unused parameter" warnings
    âœ” Indicate intentional non-use
    âœ” Guarantee zero runtime cost
```

## kobject
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

// ç®€å•çš„é“¾è¡¨å®ç°ï¼ˆæ”¾åœ¨æœ€å‰ä»¥ä¾¿åç»­ç»“æ„ä½“ä½¿ç”¨ï¼‰
struct list_head {
    struct list_head *next, *prev;
};

#define LIST_HEAD_INIT(name) { &(name), &(name) }
#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)

#define list_entry(ptr, type, member) \
    ((type *)((char *)(ptr) - (unsigned long)(&((type *)0)->member)))

// éå†å®
#define list_for_each(pos, head) \
    for ((pos) = (head)->next; (pos) != (head); (pos) = (pos)->next)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
    list->next = list;
    list->prev = list;
}

static inline void __list_add(struct list_head *new,
                              struct list_head *prev,
                              struct list_head *next)
{
    next->prev = new;
    new->next = next;
    new->prev = prev;
    prev->next = new;
}

static inline void list_add(struct list_head *new, struct list_head *head)
{
    __list_add(new, head, head->next);
}

static inline void __list_del(struct list_head *prev, struct list_head *next)
{
    next->prev = prev;
    prev->next = next;
}

static inline void list_del(struct list_head *entry)
{
    __list_del(entry->prev, entry->next);
    entry->next = NULL;
    entry->prev = NULL;
}

// æ¨¡æ‹Ÿ kref (å¼•ç”¨è®¡æ•°)
struct kref {
    int refcount;
};

// æ¨¡æ‹Ÿ kobject
struct kobject {
    char name[32];
    struct kref kref;
    void (*release)(struct kobject *kobj);
    struct list_head list;
};

// å…¨å±€å¯¹è±¡åˆ—è¡¨
static LIST_HEAD(object_list);

// åˆå§‹åŒ–é“¾è¡¨å¤´
void list_head_init(void)
{
    INIT_LIST_HEAD(&object_list);
}

// kref æ“ä½œå‡½æ•°
void kref_init(struct kref *kref)
{
    kref->refcount = 1;
    printf("kref_init: refcount = 1\n");
}

void kref_get(struct kref *kref)
{
    kref->refcount++;
    printf("kref_get: refcount = %d\n", kref->refcount);
}

int kref_put(struct kref *kref, void (*release)(struct kref *kref))
{
    kref->refcount--;
    printf("kref_put: refcount = %d\n", kref->refcount);
    
    if (kref->refcount == 0) {
        if (release) {
            release(kref);
        }
        return 1;
    }
    return 0;
}

// kobject æ“ä½œå‡½æ•°
void kobject_init(struct kobject *kobj, const char *name)
{
    strncpy(kobj->name, name, sizeof(kobj->name) - 1);
    kobj->name[sizeof(kobj->name) - 1] = '\0';
    kref_init(&kobj->kref);
    INIT_LIST_HEAD(&kobj->list);
    
    // æ·»åŠ åˆ°å…¨å±€åˆ—è¡¨
    list_add(&kobj->list, &object_list);
    printf("kobject_init: created '%s'\n", name);
}

struct kobject *kobject_get(struct kobject *kobj)
{
    if (kobj) {
        kref_get(&kobj->kref);
    }
    return kobj;
}

static void kobject_release(struct kref *kref)
{
    struct kobject *kobj = (struct kobject *)((char *)kref - 
                         (unsigned long)(&((struct kobject *)0)->kref));
    
    printf("kobject_release: releasing '%s'\n", kobj->name);
    
    // ä»åˆ—è¡¨ä¸­åˆ é™¤
    list_del(&kobj->list);
    
    // è°ƒç”¨ç”¨æˆ·æä¾›çš„releaseå‡½æ•°
    if (kobj->release) {
        kobj->release(kobj);
    }
}

void kobject_put(struct kobject *kobj)
{
    if (kobj) {
        printf("kobject_put: putting '%s'\n", kobj->name);
        kref_put(&kobj->kref, kobject_release);
    }
}

// ç¤ºä¾‹è®¾å¤‡ç»“æ„
struct my_device {
    char description[64];
    int device_id;
    struct kobject kobj;
};

void device_release(struct kobject *kobj)
{
    struct my_device *dev = list_entry(kobj, struct my_device, kobj);
    
    printf("device_release: freeing device '%s' (id=%d)\n", 
           dev->description, dev->device_id);
    
    // å®é™…é‡Šæ”¾è®¾å¤‡å†…å­˜
    free(dev);
}

// åˆ›å»ºè®¾å¤‡å‡½æ•°
struct my_device *create_device(const char *desc, int id)
{
    struct my_device *dev = malloc(sizeof(struct my_device));
    if (!dev) {
        return NULL;
    }
    
    strncpy(dev->description, desc, sizeof(dev->description) - 1);
    dev->description[sizeof(dev->description) - 1] = '\0';
    dev->device_id = id;
    
    // åˆå§‹åŒ–å†…åµŒçš„ kobject
    kobject_init(&dev->kobj, desc);
    dev->kobj.release = device_release;
    
    return dev;
}

// æ˜¾ç¤ºå½“å‰æ‰€æœ‰å¯¹è±¡
void show_all_objects(void)
{
    struct list_head *pos;
    struct kobject *kobj;
    
    printf("\n=== Current Objects ===\n");
    list_for_each(pos, &object_list) {
        kobj = list_entry(pos, struct kobject, list);
        printf("Object: %s (refcount=%d)\n", kobj->name, kobj->kref.refcount);
    }
    printf("=======================\n\n");
}

// æµ‹è¯•å‡½æ•°
void test_kobject_lifecycle(void)
{
    printf("=== å¼€å§‹ kobject ç”Ÿå‘½å‘¨æœŸæµ‹è¯• ===\n\n");
    
    // åˆ›å»ºè®¾å¤‡å¯¹è±¡
    struct my_device *dev1 = create_device("Network Card", 1);
    struct my_device *dev2 = create_device("USB Controller", 2);
    
    show_all_objects();
    
    // æ¨¡æ‹Ÿå¤šä¸ªæ¨¡å—ä½¿ç”¨è®¾å¤‡
    printf("=== æ¨¡æ‹Ÿæ¨¡å—Aä½¿ç”¨ç½‘ç»œå¡ ===\n");
    struct kobject *dev1_ref1 = kobject_get(&dev1->kobj);
    
    printf("=== æ¨¡æ‹Ÿæ¨¡å—Bä½¿ç”¨ç½‘ç»œå¡ ===\n");
    struct kobject *dev1_ref2 = kobject_get(&dev1->kobj);
    
    show_all_objects();
    
    // æ¨¡å—Båœæ­¢ä½¿ç”¨
    printf("=== æ¨¡å—Båœæ­¢ä½¿ç”¨ç½‘ç»œå¡ ===\n");
    kobject_put(dev1_ref2);
    
    show_all_objects();
    
    // å°è¯•é‡Šæ”¾ USB æ§åˆ¶å™¨ï¼ˆåº”è¯¥ä¸ä¼šçœŸçš„é‡Šæ”¾ï¼Œå› ä¸ºè¿˜æœ‰å¼•ç”¨ï¼‰
    printf("=== å°è¯•é‡Šæ”¾USBæ§åˆ¶å™¨ ===\n");
    kobject_put(&dev2->kobj);
    
    show_all_objects();
    
    // æ¨¡å—Aåœæ­¢ä½¿ç”¨ç½‘ç»œå¡
    printf("=== æ¨¡å—Aåœæ­¢ä½¿ç”¨ç½‘ç»œå¡ ===\n");
    kobject_put(dev1_ref1);
    
    show_all_objects();
    
    // æœ€ç»ˆé‡Šæ”¾ç½‘ç»œå¡
    printf("=== æœ€ç»ˆé‡Šæ”¾ç½‘ç»œå¡ ===\n");
    kobject_put(&dev1->kobj);
    
    show_all_objects();
    
    // æœ€ç»ˆé‡Šæ”¾USBæ§åˆ¶å™¨
    printf("=== æœ€ç»ˆé‡Šæ”¾USBæ§åˆ¶å™¨ ===\n");
    kobject_put(&dev2->kobj);
    
    show_all_objects();
}

int main(void)
{
    // åˆå§‹åŒ–å…¨å±€é“¾è¡¨
    list_head_init();
    
    // è¿è¡Œæµ‹è¯•
    test_kobject_lifecycle();
    
    printf("=== æµ‹è¯•å®Œæˆ ===\n");
    return 0;
}
```

## Cè¯­è¨€å¯æ‰§è¡Œç¨‹åºçš„æ•°æ®æ®µå¤§å°æ˜¯å¦‚ä½•ç¡®å®šçš„
- c program's memory layout
```
+-------------------------+
| Stack (grows downward)  |
+-------------------------+
| Heap (grows upward)     |
+-------------------------+
| BSS Segment             | â† uninitialized globals/static vars
+-------------------------+
| Data Segment            | â† initialized globals/static vars
+-------------------------+
| Text Segment            | â† compiled code (functions)
+-------------------------+
```
- ç¼–è¯‘å’Œé“¾æ¥å…±åŒå†³å®šäº†æ•°æ®æ®µçš„å¤§å°
```
| æ®µå        | ä½œç”¨                                      | ä¸¾ä¾‹å˜é‡                           | æ˜¯å¦å ç”¨æ–‡ä»¶ç©ºé—´   |
| ---------   | ------------------------                 | ------------------------------     | ---------- |
| `.text`     | ç¨‹åºæŒ‡ä»¤ï¼ˆæœºå™¨ç ï¼‰                         | å‡½æ•°ä½“                             | âœ…          |
| `.data`     | **å·²åˆå§‹åŒ–çš„å…¨å±€/é™æ€å˜é‡**                 | `int a = 5; static int b = 6;`    | âœ…          |
| `.bss`      | **æœªåˆå§‹åŒ–ï¼ˆæˆ–åˆå§‹åŒ–ä¸º0ï¼‰çš„å…¨å±€/é™æ€å˜é‡**   | `int c; static int d;`             | âŒï¼ˆåªåœ¨è¿è¡Œæ—¶åˆ†é…ï¼‰ |
| `.rodata`   | åªè¯»æ•°æ®ï¼ˆå¸¸é‡å­—ç¬¦ä¸²ã€`const`å˜é‡ï¼‰          | `"Hello"` / `const int x = 1;`    | âœ…          |

ç¼–è¯‘é˜¶æ®µ(.c -> .o)
	ç¼–è¯‘å™¨ï¼ˆå¦‚ gccï¼‰ä¼šä¸ºæ¯ä¸ªæºæ–‡ä»¶ç”Ÿæˆä¸€ä¸ªç›®æ ‡æ–‡ä»¶ .o
	ç¼–è¯‘å™¨æ ¹æ®å˜é‡çš„åˆå§‹åŒ–æƒ…å†µï¼ŒæŠŠç¬¦å·æ”¾å…¥ä¸åŒçš„æ®µï¼š
		å·²åˆå§‹åŒ–çš„ â†’ .data
		æœªåˆå§‹åŒ–æˆ–åˆå§‹åŒ–ä¸º0çš„ â†’ .bss
		å­—ç¬¦ä¸²å¸¸é‡æˆ– const â†’ .rodata
	ç¼–è¯‘å™¨ä¼šç”Ÿæˆè¿™äº›æ®µçš„â€œç¬¦å·è¡¨é¡¹â€ï¼Œè®°å½•å˜é‡å¤§å°ã€å¯¹é½è¦æ±‚
ğŸ‘‰ æ¯ä¸ª .o æ–‡ä»¶è‡ªå·±æœ‰ç‹¬ç«‹çš„ .dataã€.bss æ®µ

æ±‡ç¼–ä¸å¯¹é½
	ç¼–è¯‘å™¨ä¼šåœ¨ .o ä¸­æŒ‡å®šæ¯ä¸ªæ®µçš„å¯¹é½è¦æ±‚ï¼ˆalignmentï¼‰ï¼š
		é€šå¸¸ .data æ®µæŒ‰ 8 æˆ– 16 å­—èŠ‚å¯¹é½
		å¦‚æœç»“æ„ä½“ä¸­æœ‰å¤§å­—æ®µï¼ˆä¾‹å¦‚ doubleï¼‰ï¼Œä¼šå¢åŠ å¯¹é½å¡«å……

é“¾æ¥é˜¶æ®µï¼ˆ.o â†’ ELF å¯æ‰§è¡Œæ–‡ä»¶ï¼‰
é“¾æ¥å™¨ï¼ˆldï¼‰ä¼šï¼š
	1. æŠŠæ‰€æœ‰ .data æ®µæ‹¼æ¥èµ·æ¥
	2. è®¡ç®—æ€»å¯¹é½ã€åç§»
	3. è®°å½•æœ€ç»ˆçš„æ®µå¤§å°åˆ° ELF header
	4. .bss æ®µä¸ä¼šå®é™…å†™å…¥æ–‡ä»¶ï¼Œè€Œåªè®°å½•å¤§å°ï¼ˆåŠ è½½æ—¶ç”±å†…æ ¸åˆ†é…é›¶å¡«å……å†…å­˜ï¼‰
å› æ­¤æœ€ç»ˆ .data æ®µçš„å¤§å° = æ‰€æœ‰å·²åˆå§‹åŒ–é™æ€/å…¨å±€å˜é‡çš„å¤§å° + å¯¹é½å¡«å……


åŠ è½½é˜¶æ®µ
å½“ç¨‹åºè¿è¡Œæ—¶ï¼š
	Linux ELF loaderï¼ˆåŠ¨æ€é“¾æ¥å™¨ï¼‰ä¼šï¼š
		ä»å¯æ‰§è¡Œæ–‡ä»¶ä¸­ æ˜ å°„ .data æ®µå†…å®¹åˆ°å†…å­˜ï¼›
		ä¸º .bss æ®µ åˆ†é…ç›¸åº”å¤§å°çš„é›¶å¡«å……ç©ºé—´ï¼›
		åœ¨è¿›ç¨‹è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­åˆ†åˆ«åˆ›å»ºè¿™ä¸¤ä¸ªå†…å­˜åŒºåŸŸ
å¯ä»¥é€šè¿‡ /proc/<pid>/maps çœ‹åˆ°å®ƒä»¬çš„ä½ç½®ï¼ˆé€šå¸¸ç›¸é‚»ï¼‰
```

```c
#include <stdio.h>

int global_var = 10;
int global_var_uninitialized;

int main(void)
{
    static int static_var = 20;
    static int static_var_uninitialized;
    printf("global_var: %d\n", global_var);
    printf("static_var: %d\n", static_var);
    printf("global_var_uninitialized: %d\n", global_var_uninitialized);
    printf("static_var_uninitialized: %d\n", static_var_uninitialized);
    return 0;
}

gcc -o main main.c && size main
   text    data     bss     dec     hex filename
   1553     608      16    2177     881 main
```

## opaque handle
[Opaque Pointers](https://blog.mbedded.ninja/programming/design-patterns/opaque-pointers/)  
[Incomplete Types](https://www.gnu.org/software/c-intro-and-ref/manual/html_node/Incomplete-Types.html)  
[Incomplete Types](https://beej.us/guide/bgc/html/split/incomplete-types.html)  
[Incomplete Array Types](https://www.gnu.org/software/c-intro-and-ref/manual/html_node/Incomplete-Array-Types.html)  
[]()  
[]()  
[]()  
[]()  

- incomplete type
  - an incomplete type is a type that's declared but but yet fully defined, the compiler knows that the type exists, but not how big it is or what it contains.
```c
// "incomplete type" acts like a promise:
	// Iâ€™ll tell you what this type looks like later â€” but for now, you can pass pointers around

// why it works even without struct definition in main.c
	// The compiler only needs the type name and pointer size (8 bytes on x86-64) to compile calls and variable declarations.
	// The definition of the struct is only required where you dereference or allocate it (malloc, w->id, etc.).
	// The linker just connects symbols â€” it doesnâ€™t care about structs at all.

| Concept                       | Meaning                                              |
| ----------------------------- | ---------------------------------------------------- |
| **Incomplete type**           | Type is declared but not defined (size unknown)      |
| **Opaque pointer**            | Pointer to such a type used to hide implementation   |
| **Compile-time in user code** | Compiler only checks pointer usage & prototypes      |
| **Compile-time in impl code** | Compiler knows struct layout                         |
| **Link-time**                 | Functions matched by symbol names, not struct layout |
| **Runtime**                   | Only addresses are passed â€” type info gone           |


struct Foo;		// declaration only - incomplete type
// what compiler knows:
	// 1. there is a type called 'struct Foo'
	// 2. but its size, members and layout are unknown

// you can use pointers or references to it:
struct Foo *p;							// Ok - pointer to incomplete type
extern struct Foo *foo_create(void);	// Ok
// but cannot
struct Foo f;		// âŒ Error: incomplete type
p->member = 1;		// âŒ Error: struct not defined
sizeof(struct Foo); // âŒ Error: incomplete type

// when you define the structure, it becomes "complete"
struct Foo {
	int a;
}
// what compiler knows:
	// its size, fields
	// how to allocate and access it
struct Foo f;      // âœ… OK
f.a = 10;          // âœ… OK
```

- opaque pointer
  - an opaque pointer is a pointer to an incomplete type used intentionally to hide implementation details
```c
// An opaque pointer is a pointer to an incomplete type that remains incomplete in the public interface, allowing you to compile, link, and run code that manipulates data whose layout is known only to its implementation file.

// don't expose the struct definition in the header file
typedef struct Foo Foo;   // forward-declare and alias

// Foo* is an opaque pointer, users can hold it, pass it abound, but cannot look inside
Foo* foo_create(void);
void foo_destroy(Foo* f);

// "Every opaque pointer is based on an incomplete type, but not every incomplete type is opaque."
// Incomplete type = "compiler doesnâ€™t know layout yet."

// Opaque pointer = "you intentionally keep it incomplete in the public interface."
| Concept         | Example                                             | Visible to user?                              | Used for                           |
| --------------- | --------------------------------------------------- | --------------------------------------------- | ---------------------------------- |
| Incomplete type | `struct A;`                                         | Temporarily incomplete, will be defined later | Internal modular code organization |
| Opaque pointer  | `typedef struct Foo Foo;` (no definition in header) | Intentionally hidden forever                  | Encapsulation / API design         |

```

```c
// .h
typedef struct Foo Foo;
extern Foo* get_Foo(int);

// opaque handle
	Declare public-facing function prototypes in a header (.h),
	Without exposing the internal structure of Foo,
	While still allowing client code to use Foo* handles.

// declares incomplete type + alias
typedef struct Foo Foo;
does the following 2 things:
1. forward declares a struct type named 'struct Foo', meaning:
	"there exists a struct type called struct Foo, but its contents are not defined yet"
2. creates an alias (typedef) called Foo for 'struct Foo'

what means for the compiler:
| Expression        | Meaning                               | Defined?                         |
| ----------------- | ------------------------------------- | -------------------------------- |
| `struct Foo`      | A tag name for a struct type          | âœ… Declared, âŒ Not defined yet |
| `Foo`             | A typedef alias for `struct Foo`      | âœ… Declared, âŒ Not defined yet |

// the compiler can use them for pointer declarations or function prototypes, even though it doesn't yet know what the construct contains.

// pointer to incomplete type
extern Foo* get_Foo(int);
// because the compiler already knows that Foo is a typedef name for an incomplete struct type, it can handle:
1. declaring a pointer to that type (Foo*)
2. declaring a function that returns that pointer

// c allows pointers to incomplete types (like forward-declared structs), because the size and layout of the struct aren't needed to declare or pass around a pointer - only when you dereference it does the full definition become necessary.

```

- example 1
  - code structure
```
Couter library:
	a public header (counter.h) - for users, hides implementation details
	a private implementation (counter.c) - defines the real struct

Users can create, use and destroy counter only through provided API functions, without ever seeing the struct layout.

.
â”œâ”€â”€ counter.c
â”œâ”€â”€ counter.h
â””â”€â”€ main.c
```
  - code
```c
// counter.h
#ifndef COUNTER_H
#define COUNTER_H

#include <stdint.h>

/* Forward declaration + typedef alias */
typedef struct Counter Counter;

/* Public API */
Counter* counter_create(void);
void counter_destroy(Counter* c);
void counter_increment(Counter* c);
int counter_get_value(const Counter* c);

#endif

// counter.c
#include "counter.h"
#include <stdlib.h>
#include <stdio.h>

/* Define the struct â€” private to this file */
struct Counter {
    int value;
};

Counter* counter_create(void) {
    Counter* c = malloc(sizeof(*c));
    if (c) c->value = 0;
    return c;
}

void counter_destroy(Counter* c) {
    free(c);
}

void counter_increment(Counter* c) {
    if (c) c->value++;
}

int counter_get_value(const Counter* c) {
    return c ? c->value : 0;
}

// main.c
#include "counter.h"
#include <stdio.h>

int main(void) {
    Counter* c = counter_create();
    counter_increment(c);
    counter_increment(c);
    printf("Counter = %d\n", counter_get_value(c));
    counter_destroy(c);
    return 0;
}

```
- example 2 (handle-style API version)
```c
// counter.h
#ifndef COUNTER_H
#define COUNTER_H

#include <stdint.h>

/* Fully opaque handle type */
typedef void* CounterHandle;

/* Public API */
CounterHandle counter_create(void);
void counter_destroy(CounterHandle h);
void counter_increment(CounterHandle h);
int counter_get_value(CounterHandle h);

#endif

// counter.c
#include "counter.h"
#include <stdlib.h>
#include <stdio.h>

/* Private internal struct (invisible to users) */
typedef struct Counter {
    int value;
} Counter;

CounterHandle counter_create(void) {
    Counter* c = malloc(sizeof(*c));
    if (c) c->value = 0;
    return (CounterHandle)c;
}

void counter_destroy(CounterHandle h) {
    Counter* c = (Counter*)h;
    free(c);
}

void counter_increment(CounterHandle h) {
    Counter* c = (Counter*)h;
    if (c) c->value++;
}

int counter_get_value(CounterHandle h) {
    Counter* c = (Counter*)h;
    return c ? c->value : 0;
}

// main.c
#include "counter.h"
#include <stdio.h>

int main(void) {
    CounterHandle h = counter_create();
    counter_increment(h);
    counter_increment(h);
    printf("Counter = %d\n", counter_get_value(h));
    counter_destroy(h);
    return 0;
}

// Struct Pointer vs Handle
| Feature                  | `typedef struct Counter Counter;`            | `typedef void* CounterHandle;` |
| ------------------------ | -------------------------------------------  | ------------------------------ |
| Type safety              | âœ… Strong (compiler knows itâ€™s a `Counter*`) | âš ï¸ Weak (just a `void*`)       |
| ABI stability            | âš ï¸ Needs care if struct layout changes       | âœ… Totally opaque               |
| Can dereference directly | âŒ No                                        | âŒ No                           |
| Common in                | Library APIs, C codebases                    | System APIs, drivers, SDKs     |
| Example                  | POSIX `DIR*`, OpenSSL `SSL*`                 | Win32 `HANDLE`, Vulkan handles |


```
- example 3 (hybrid approach â€” where we keep type safety but still hide the struct definition (like how FILE* in C stdio works)
  - code
```c
// counter.h
#ifndef COUNTER_H
#define COUNTER_H

#include <stdint.h>

/* Forward declare + typedef alias (type-safe opaque pointer) */
typedef struct Counter Counter;

/* Public API */
Counter* counter_create(void);
void counter_destroy(Counter* c);
void counter_increment(Counter* c);
int counter_get_value(const Counter* c);

#endif

// counter.c
#include "counter.h"
#include <stdlib.h>
#include <stdio.h>

/* Define the struct privately â€” hidden from users */
struct Counter {
    int value;
};

Counter* counter_create(void) {
    Counter* c = malloc(sizeof(*c));
    if (c) c->value = 0;
    return c;
}

void counter_destroy(Counter* c) {
    free(c);
}

void counter_increment(Counter* c) {
    if (c) c->value++;
}

int counter_get_value(const Counter* c) {
    return c ? c->value : 0;
}

// main.c
#include "counter.h"
#include <stdio.h>

int main(void) {
    Counter* c = counter_create();
    counter_increment(c);
    counter_increment(c);
    printf("Counter = %d\n", counter_get_value(c));
    counter_destroy(c);
    return 0;
}

// Comparison of all three styles
Pattern					Example typedef					Type safety		ABI stability			 Struct hidden?		Common use
Struct pointer (public) typedef struct Counter { 		âœ… Strong	  âŒ Low (layout public)	  âŒ No	  			Internal-only APIs
						int value; } Counter;
Opaque handle (void)*	typedef void* CounterHandle;	âŒ Weak		  âœ… Very high			  âœ… Fully			System-level APIs
Opaque typed pointer	typedef struct Counter Counter;	âœ… Strong	  âœ… High				  âœ… Yes				Most libraries (stdio, OpenSSL, SQLite)
```
- example 4 (multiple opaque types coexist cleanly while keeping each subsystem encapsulated and type-safe)
  - code structure
```
What this achieves:
| Feature                      | Description                                                                              |
| ---------------------------- | ---------------------------------------------------------------------------------------- |
| **Encapsulation per module** | Each `.c` file owns and hides its own `struct`.                                          |
| **Type safety**              | You canâ€™t pass a `Logger*` to a `Connection` function by accident â€” compiler catches it. |
| **Separation of concerns**   | Each moduleâ€™s internal details are private.                                              |
| **Stable ABI**               | Struct layouts can change without recompiling user code.                                 |
| **Real-world pattern**       | Matches the style of `FILE*`, `DIR*`, `SSL*`, etc.                                       |

.
â”œâ”€â”€ connection.c
â”œâ”€â”€ connection.h
â”œâ”€â”€ logger.c
â”œâ”€â”€ logger.h
â”œâ”€â”€ main.c
â”œâ”€â”€ session.c
â”œâ”€â”€ session.h
```
  - code
```c
// logger.h
#ifndef LOGGER_H
#define LOGGER_H

typedef struct Logger Logger;

Logger* logger_create(const char* path);
void logger_log(Logger* l, const char* msg);
void logger_destroy(Logger* l);

#endif

// connection.h
#ifndef CONNECTION_H
#define CONNECTION_H

typedef struct Connection Connection;

Connection* connection_open(const char* addr, int port);
void connection_send(Connection* c, const char* data);
void connection_close(Connection* c);

#endif

// session.h
#ifndef SESSION_H
#define SESSION_H

#include "connection.h"
#include "logger.h"

typedef struct Session Session;

Session* session_create(const char* addr, int port, const char* log_path);
void session_send(Session* s, const char* msg);
void session_destroy(Session* s);

#endif

// logger.c
#include "logger.h"
#include <stdio.h>
#include <stdlib.h>

struct Logger {
    FILE* fp;
};

Logger* logger_create(const char* path) {
    Logger* l = malloc(sizeof(*l));
    if (!l) return NULL;
    l->fp = fopen(path, "a");
    return l;
}

void logger_log(Logger* l, const char* msg) {
    if (l && l->fp) fprintf(l->fp, "[log] %s\n", msg);
}

void logger_destroy(Logger* l) {
    if (!l) return;
    if (l->fp) fclose(l->fp);
    free(l);
}

// connection.c
#include "connection.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Connection {
    char addr[64];
    int port;
};

Connection* connection_open(const char* addr, int port) {
    Connection* c = malloc(sizeof(*c));
    if (!c) return NULL;
    snprintf(c->addr, sizeof(c->addr), "%s", addr);
    c->port = port;
    printf("Connecting to %s:%d...\n", addr, port);
    return c;
}

void connection_send(Connection* c, const char* data) {
    printf("[Conn %s:%d] sending: %s\n", c->addr, c->port, data);
}

void connection_close(Connection* c) {
    printf("[Conn %s:%d] closed\n", c->addr, c->port);
    free(c);
}

// session.c
#include "session.h"
#include <stdlib.h>

struct Session {
    Connection* conn;
    Logger* log;
};

Session* session_create(const char* addr, int port, const char* log_path) {
    Session* s = malloc(sizeof(*s));
    if (!s) return NULL;
    s->conn = connection_open(addr, port);
    s->log  = logger_create(log_path);
    return s;
}

void session_send(Session* s, const char* msg) {
    if (!s) return;
    connection_send(s->conn, msg);
    logger_log(s->log, msg);
}

void session_destroy(Session* s) {
    if (!s) return;
    connection_close(s->conn);
    logger_destroy(s->log);
    free(s);
}

// main.c
#include "session.h"
#include <stdio.h>

int main(void) {
    Session* s = session_create("127.0.0.1", 8080, "session.log");
    session_send(s, "Hello, world!");
    session_send(s, "Second message!");
    session_destroy(s);
    return 0;
}

```

## macro + struct + function pointer
- åŸºæœ¬æ€æƒ³
  -  macros reduce repetition
  -  structs bundle data
  -  function pointers enable runtime polymorphism

- å…¸å‹åº”ç”¨
  - é¢å‘å¯¹è±¡æ¨¡æ‹Ÿ
  - çŠ¶æ€æœºå®ç°
  - å›è°ƒæœºåˆ¶ä¸äº‹ä»¶ç³»ç»Ÿ
  - æ³›å‹å®¹å™¨å®ç°
  - ç­–ç•¥æ¨¡å¼
  - æ’ä»¶ç³»ç»Ÿ
  - plug-in registration
  - state machine
  - state machine

- é¢å‘å¯¹è±¡æ¨¡æ‹Ÿ
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// åŸºç±»å®šä¹‰
typedef struct Animal {
	char name[50];
	int age;
	void (*speak)(struct Animal* self);
	void (*destroy)(struct Animal* self);
} Animal;

// å®å®šä¹‰ç®€åŒ–å¯¹è±¡åˆ›å»º
#define ANIMAL_INIT(n, a) {.name = n, .age = a}

// æ–¹æ³•å®ç°
void animal_speak(Animal* self) {
	printf("%s (age %d) makes a sound\n", self->name, self->age);
}

void animal_destroy(Animal* self) {
	printf("Destroying animal: %s\n", self->name);
	free(self);
}

// æ´¾ç”Ÿç±» - Dog
typedef struct {
	Animal base;
	char breed[50];
} Dog;

void dog_speak(Animal* self) {
	Dog* dog = (Dog*)self;
	printf("%s (a %s, age %d) says: Woof!\n", 
		   dog->base.name, dog->breed, dog->base.age);
}

Dog* dog_create(const char* name, int age, const char* breed) {
	Dog* dog = malloc(sizeof(Dog));
	strcpy(dog->base.name, name);
	dog->base.age = age;
	strcpy(dog->breed, breed);
	dog->base.speak = dog_speak;
	dog->base.destroy = (void (*)(Animal*))free;
	return dog;
}

// æ´¾ç”Ÿç±» - Cat
typedef struct {
	Animal base;
	int lives;
} Cat;

void cat_speak(Animal* self) {
	Cat* cat = (Cat*)self;
	printf("%s (lives: %d, age %d) says: Meow!\n", 
		   cat->base.name, cat->lives, cat->base.age);
}

Cat* cat_create(const char* name, int age, int lives) {
	Cat* cat = malloc(sizeof(Cat));
	strcpy(cat->base.name, name);
	cat->base.age = age;
	cat->lives = lives;
	cat->base.speak = cat_speak;
	cat->base.destroy = (void (*)(Animal*))free;
	return cat;
}

int main() {
	// å¤šæ€æ¼”ç¤º
	Animal* animals[3];
		
	animals[0] = (Animal*)dog_create("Buddy", 3, "Golden Retriever");
	animals[1] = (Animal*)cat_create("Whiskers", 2, 9);
	animals[2] = (Animal*)dog_create("Max", 5, "Labrador");
		
	printf("=== Animal Sounds ===\n");
	for (int i = 0; i < 3; i++) {
		animals[i]->speak(animals[i]);
	}
		
	// æ¸…ç†
	for (int i = 0; i < 3; i++) {
		animals[i]->destroy(animals[i]);
	}
		
	return 0;
}
```
- çŠ¶æ€æœºå®ç°
```c
#include <stdio.h>
#include <stdlib.h>

// çŠ¶æ€å’Œäº‹ä»¶å®šä¹‰
typedef enum {
	STATE_IDLE,
	STATE_RUNNING,
	STATE_PAUSED,
	STATE_STOPPED
} State;

typedef enum {
	EVENT_START,
	EVENT_PAUSE,
	EVENT_RESUME,
	EVENT_STOP
} Event;

// çŠ¶æ€æœºç»“æ„
typedef struct StateMachine {
	State current_state;
	void (*transition)(struct StateMachine*, Event);
	void (*on_enter[4])(void);  // è¿›å…¥çŠ¶æ€å›è°ƒ
	void (*on_exit[4])(void);   // ç¦»å¼€çŠ¶æ€å›è°ƒ
} StateMachine;

// çŠ¶æ€è¿›å…¥/é€€å‡ºå›è°ƒ
void on_idle_enter() { printf("Entering Idle state\n"); }
void on_running_enter() { printf("Entering Running state\n"); }
void on_paused_enter() { printf("Entering Paused state\n"); }
void on_stopped_enter() { printf("Entering Stopped state\n"); }

void on_idle_exit() { printf("Leaving Idle state\n"); }
void on_running_exit() { printf("Leaving Running state\n"); }
void on_paused_exit() { printf("Leaving Paused state\n"); }
void on_stopped_exit() { printf("Leaving Stopped state\n"); }

// çŠ¶æ€è½¬æ¢å‡½æ•°
void state_transition(StateMachine* sm, Event event) {
	State old_state = sm->current_state;
	State new_state = old_state;
		
	// çŠ¶æ€è½¬æ¢é€»è¾‘
	switch (old_state) {
		case STATE_IDLE:
			if (event == EVENT_START) new_state = STATE_RUNNING;
			break;
		case STATE_RUNNING:
			if (event == EVENT_PAUSE) new_state = STATE_PAUSED;
			else if (event == EVENT_STOP) new_state = STATE_STOPPED;
			break;
		case STATE_PAUSED:
			if (event == EVENT_RESUME) new_state = STATE_RUNNING;
			else if (event == EVENT_STOP) new_state = STATE_STOPPED;
			break;
		case STATE_STOPPED:
			if (event == EVENT_START) new_state = STATE_RUNNING;
			break;
	}
		
	// æ‰§è¡ŒçŠ¶æ€è½¬æ¢
	if (old_state != new_state) {
		if (sm->on_exit[old_state]) sm->on_exit[old_state]();
		sm->current_state = new_state;
		if (sm->on_enter[new_state]) sm->on_enter[new_state]();
	}
}

// åˆ›å»ºçŠ¶æ€æœºçš„å®
#define CREATE_STATE_MACHINE() &(StateMachine){ \
	.current_state = STATE_IDLE, \
	.transition = state_transition, \
	.on_enter = {on_idle_enter, on_running_enter, on_paused_enter, on_stopped_enter}, \
	.on_exit = {on_idle_exit, on_running_exit, on_paused_exit, on_stopped_exit} \
}

int main() {
	StateMachine* sm = CREATE_STATE_MACHINE();
		
	printf("=== State Machine Demo ===\n");
		
	// æµ‹è¯•çŠ¶æ€è½¬æ¢
	sm->transition(sm, EVENT_START);   // IDLE -> RUNNING
	sm->transition(sm, EVENT_PAUSE);	// RUNNING -> PAUSED
	sm->transition(sm, EVENT_RESUME);   // PAUSED -> RUNNING
	sm->transition(sm, EVENT_STOP);	 // RUNNING -> STOPPED
	sm->transition(sm, EVENT_START);	// STOPPED -> RUNNING
		
	//free(sm);
	return 0;
}
```
- å›è°ƒæœºåˆ¶ä¸äº‹ä»¶ç³»ç»Ÿ
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// äº‹ä»¶ç±»å‹å®šä¹‰
typedef enum {
	EVENT_BUTTON_PRESS,
	EVENT_TIMER_EXPIRED,
	EVENT_DATA_RECEIVED
} EventType;

// äº‹ä»¶ç»“æ„
typedef struct {
	EventType type;
	void* data;
	size_t data_size;
} Event;

// äº‹ä»¶å›è°ƒå‡½æ•°ç±»å‹
typedef void (*EventHandler)(Event* event);

// äº‹ä»¶ç®¡ç†å™¨
typedef struct {
	EventHandler* handlers;
	int capacity;
	int count;
} EventManager;

// åˆ›å»ºäº‹ä»¶ç®¡ç†å™¨
EventManager* event_manager_create(int capacity) {
	EventManager* em = malloc(sizeof(EventManager));
	em->handlers = malloc(sizeof(EventHandler) * capacity);
	em->capacity = capacity;
	em->count = 0;
	return em;
}

// æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
#define EVENT_REGISTER(em, handler) \
	do { \
		if ((em)->count < (em)->capacity) { \
			(em)->handlers[(em)->count++] = handler; \
		} \
	} while(0)

// è§¦å‘äº‹ä»¶
void event_trigger(EventManager* em, Event* event) {
	printf("Triggering event %d\n", event->type);
	for (int i = 0; i < em->count; i++) {
		em->handlers[i](event);
	}
}

// å…·ä½“çš„äº‹ä»¶å¤„ç†å™¨
void button_press_handler(Event* event) {
	if (event->type == EVENT_BUTTON_PRESS) {
		char* button = (char*)event->data;
		printf("Button pressed: %s\n", button);
	}
}

void timer_handler(Event* event) {
	if (event->type == EVENT_TIMER_EXPIRED) {
		int* timer_id = (int*)event->data;
		printf("Timer %d expired\n", *timer_id);
	}
}

void data_handler(Event* event) {
	if (event->type == EVENT_DATA_RECEIVED) {
		char* data = (char*)event->data;
		printf("Data received: %s\n", data);
	}
}

// æ—¥å¿—ä¸­é—´ä»¶
void logging_middleware(Event* event) {
	printf("[LOG] Event %d processed\n", event->type);
}

int main() {
	EventManager* em = event_manager_create(10);

	// æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
	EVENT_REGISTER(em, button_press_handler);
	EVENT_REGISTER(em, timer_handler);
	EVENT_REGISTER(em, data_handler);
	EVENT_REGISTER(em, logging_middleware);  // æ—¥å¿—ä¸­é—´ä»¶

	printf("=== Event System Demo ===\n");

	// åˆ›å»ºå¹¶è§¦å‘äº‹ä»¶
	Event e1 = {EVENT_BUTTON_PRESS, "OK", 0};
	event_trigger(em, &e1);

	int timer_id = 123;
	Event e2 = {EVENT_TIMER_EXPIRED, &timer_id, sizeof(int)};
	event_trigger(em, &e2);

	Event e3 = {EVENT_DATA_RECEIVED, "Hello World", 0};
	event_trigger(em, &e3);

	free(em->handlers);
	free(em);
	return 0;
}
```
- æ³›å‹å®¹å™¨å®ç°
```c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// é€šç”¨é“¾è¡¨èŠ‚ç‚¹
typedef struct ListNode {
	void* data;
	struct ListNode* next;
	void (*print_func)(void* data);
	int (*compare_func)(void* a, void* b);
	void (*free_func)(void* data);
} ListNode;

// é“¾è¡¨ç»“æ„
typedef struct {
	ListNode* head;
	int size;
} LinkedList;

// ç±»å‹ç‰¹å®šçš„å‡½æ•°
void int_print(void* data) {
	printf("%d", *(int*)data);
}

void string_print(void* data) {
	printf("%s", (char*)data);
}

int int_compare(void* a, void* b) {
	return *(int*)a - *(int*)b;
}

int string_compare(void* a, void* b) {
	return strcmp((char*)a, (char*)b);
}

void basic_free(void* data) {
	free(data);
}

// åˆ›å»ºèŠ‚ç‚¹çš„è¾…åŠ©å‡½æ•°ï¼ˆåœ¨å †ä¸Šåˆ†é…ï¼Œé¿å…å®å‚æ•°ä¸æˆå‘˜åå†²çªï¼‰
static ListNode* create_node(
	void* payload,
	void (*print_fn)(void*),
	int (*compare_fn)(void*, void*),
	void (*free_fn)(void*)
) {
	ListNode* node = (ListNode*)malloc(sizeof(ListNode));
	if (!node) {
		perror("malloc");
		exit(EXIT_FAILURE);
	}
	node->data = payload;
	node->print_func = print_fn;
	node->compare_func = compare_fn;
	node->free_func = free_fn;
	node->next = NULL;
	return node;
}

// å®åŒ…è£…ï¼Œä¿æŒè°ƒç”¨ç®€æ´
#define CREATE_NODE(payload, print_fn, compare_fn, free_fn) \
	create_node((payload), (print_fn), (compare_fn), (free_fn))

// é“¾è¡¨æ“ä½œ
void list_append(LinkedList* list, ListNode* node) {
	if (!list->head) {
		list->head = node;
	} else {
		ListNode* current = list->head;
		while (current->next) {
			current = current->next;
		}
		current->next = node;
	}
	list->size++;
}

void list_print(LinkedList* list) {
	ListNode* current = list->head;
	printf("List[%d]: ", list->size);
	while (current) {
		current->print_func(current->data);
		printf(" -> ");
		current = current->next;
	}
	printf("NULL\n");
}

void list_free(LinkedList* list) {
	ListNode* current = list->head;
	while (current) {
		ListNode* next = current->next;
		if (current->free_func) {
			current->free_func(current->data);
		}
		free(current);
		current = next;
	}
}

int main() {
	LinkedList int_list = {0};
	LinkedList string_list = {0};

	printf("=== Generic Container Demo ===\n");

	// æ•´æ•°é“¾è¡¨
	int* num1 = malloc(sizeof(int)); *num1 = 10;
	int* num2 = malloc(sizeof(int)); *num2 = 20;
	int* num3 = malloc(sizeof(int)); *num3 = 30;

	list_append(&int_list, CREATE_NODE(num1, int_print, int_compare, basic_free));
	list_append(&int_list, CREATE_NODE(num2, int_print, int_compare, basic_free));
	list_append(&int_list, CREATE_NODE(num3, int_print, int_compare, basic_free));

	list_print(&int_list);

	// å­—ç¬¦ä¸²é“¾è¡¨
	char* str1 = strdup("Hello");
	char* str2 = strdup("World");
	char* str3 = strdup("!");

	list_append(&string_list, CREATE_NODE(str1, string_print, string_compare, basic_free));
	list_append(&string_list, CREATE_NODE(str2, string_print, string_compare, basic_free));
	list_append(&string_list, CREATE_NODE(str3, string_print, string_compare, basic_free));

	list_print(&string_list);

	// æ¸…ç†
	list_free(&int_list);
	list_free(&string_list);

	return 0;
}
```
- ç­–ç•¥æ¨¡å¼
```c
#include <stdio.h>
#include <stdlib.h>

// æ’åºç­–ç•¥æ¥å£
typedef struct {
	char name[50];
	void (*sort)(int* array, int size);
	int (*compare)(int a, int b);  // æ¯”è¾ƒç­–ç•¥
} SortStrategy;

// å…·ä½“çš„æ’åºç®—æ³•
void bubble_sort(int* array, int size) {
	for (int i = 0; i < size - 1; i++) {
		for (int j = 0; j < size - i - 1; j++) {
			if (array[j] > array[j + 1]) {
				int temp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = temp;
			}
		}
	}
}

void selection_sort(int* array, int size) {
	for (int i = 0; i < size - 1; i++) {
		int min_idx = i;
		for (int j = i + 1; j < size; j++) {
			if (array[j] < array[min_idx]) {
				min_idx = j;
			}
		}
		int temp = array[i];
		array[i] = array[min_idx];
		array[min_idx] = temp;
	}
}

// æ¯”è¾ƒç­–ç•¥
int ascending(int a, int b) { return a - b; }
int descending(int a, int b) { return b - a; }

// ç­–ç•¥å®ä¾‹
SortStrategy bubble_ascending = {"Bubble Sort (Ascending)", bubble_sort, ascending};
SortStrategy bubble_descending = {"Bubble Sort (Descending)", bubble_sort, descending};
SortStrategy selection_ascending = {"Selection Sort (Ascending)", selection_sort, ascending};

// æ’åºä¸Šä¸‹æ–‡
typedef struct {
	SortStrategy* strategy;
	int* data;
	int size;
} SortContext;

// è®¾ç½®ç­–ç•¥çš„å®
#define SET_STRATEGY(ctx, s) do { (ctx)->strategy = s; } while(0)

void sort_context_execute(SortContext* ctx) {
	printf("Using strategy: %s\n", ctx->strategy->name);

	// ä½¿ç”¨ç­–ç•¥çš„æ¯”è¾ƒå‡½æ•°è¿›è¡Œæ’åº
	for (int i = 0; i < ctx->size - 1; i++) {
		for (int j = 0; j < ctx->size - i - 1; j++) {
			if (ctx->strategy->compare(ctx->data[j], ctx->data[j + 1]) > 0) {
				int temp = ctx->data[j];
				ctx->data[j] = ctx->data[j + 1];
				ctx->data[j + 1] = temp;
			}
		}
	}
}

void print_array(int* array, int size) {
	for (int i = 0; i < size; i++) {
		printf("%d ", array[i]);
	}
	printf("\n");
}

int main() {
	int data[] = {64, 34, 25, 12, 22, 11, 90};
	int size = sizeof(data) / sizeof(data[0]);

	SortContext ctx = {0};
	ctx.data = data;
	ctx.size = size;

	printf("=== Strategy Pattern Demo ===\n");
	printf("Original array: ");
	print_array(data, size);

	// æµ‹è¯•ä¸åŒç­–ç•¥
	SET_STRATEGY(&ctx, &bubble_ascending);
	sort_context_execute(&ctx);
	printf("Sorted array: ");
	print_array(data, size);

	// é‡ç½®æ•°æ®
	int data2[] = {64, 34, 25, 12, 22, 11, 90};
	ctx.data = data2;

	SET_STRATEGY(&ctx, &bubble_descending);
	sort_context_execute(&ctx);
	printf("Sorted array (descending): ");
	print_array(data2, size);

	return 0;
}
```
- æ’ä»¶ç³»ç»Ÿ
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// æ’ä»¶æ¥å£
typedef struct {
	char name[50];
	int version;
	int (*initialize)(void);
	int (*process)(const char* input, char* output, int output_size);
	void (*shutdown)(void);
} Plugin;

// æ’ä»¶ç®¡ç†å™¨
typedef struct {
	Plugin* plugins[10];
	int count;
} PluginManager;

// æ³¨å†Œæ’ä»¶çš„å®
#define PLUGIN_REGISTER(pm, p) \
	do { \
		if ((pm)->count < 10) { \
			(pm)->plugins[(pm)->count++] = p; \
		} \
	} while(0)

// å…·ä½“æ’ä»¶å®ç°
int logger_init(void) {
	printf("Logger plugin initialized\n");
	return 0;
}

int logger_process(const char* input, char* output, int output_size) {
	snprintf(output, output_size, "[LOG] %s", input);
	return 0;
}

void logger_shutdown(void) {
	printf("Logger plugin shutdown\n");
}

Plugin logger_plugin = {
	.name = "Logger",
	.version = 1,
	.initialize = logger_init,
	.process = logger_process,
	.shutdown = logger_shutdown
};

// åŠ å¯†æ’ä»¶
int encryptor_init(void) {
	printf("Encryptor plugin initialized\n");
	return 0;
}

int encryptor_process(const char* input, char* output, int output_size) {
	// ç®€å•çš„"åŠ å¯†" - å­—ç¬¦åç§»
	int len = strlen(input);
	for (int i = 0; i < len && i < output_size - 1; i++) {
		output[i] = input[i] + 1;  // æ¯ä¸ªå­—ç¬¦+1
	}
	output[len < output_size - 1 ? len : output_size - 1] = '\0';
	return 0;
}

void encryptor_shutdown(void) {
	printf("Encryptor plugin shutdown\n");
}

Plugin encryptor_plugin = {
	.name = "Encryptor",
	.version = 1,
	.initialize = encryptor_init,
	.process = encryptor_process,
	.shutdown = encryptor_shutdown
};

void plugin_manager_init(PluginManager* pm) {
	pm->count = 0;
}

void plugin_manager_start(PluginManager* pm) {
	printf("=== Starting %d plugins ===\n", pm->count);
	for (int i = 0; i < pm->count; i++) {
		pm->plugins[i]->initialize();
	}
}

void plugin_manager_process(PluginManager* pm, const char* input) {
	char output[256];

	for (int i = 0; i < pm->count; i++) {
		pm->plugins[i]->process(input, output, sizeof(output));
		printf("Plugin '%s' output: %s\n", pm->plugins[i]->name, output);
	}
}

void plugin_manager_shutdown(PluginManager* pm) {
	printf("=== Shutting down %d plugins ===\n", pm->count);
	for (int i = 0; i < pm->count; i++) {
		pm->plugins[i]->shutdown();
	}
}

int main() {
	PluginManager pm;
	plugin_manager_init(&pm);

	// æ³¨å†Œæ’ä»¶
	PLUGIN_REGISTER(&pm, &logger_plugin);
	PLUGIN_REGISTER(&pm, &encryptor_plugin);

	// ä½¿ç”¨æ’ä»¶ç³»ç»Ÿ
	plugin_manager_start(&pm);

	printf("\n=== Processing Data ===\n");
	plugin_manager_process(&pm, "Hello, Plugin System!");
	plugin_manager_process(&pm, "Test Message");

	plugin_manager_shutdown(&pm);

	return 0;
}
```

- plug-in registration
```c
#include <stdio.h>

typedef struct plugin
{
	const char *name;
	void (*init)(void);
	void (*run)(void);
} plugin;

#define PLUGIN_DECL(NAME, INIT_FN, RUN_FN) \
	plugin NAME = {#NAME, INIT_FN, RUN_FN}

static void alpha_init(void) { puts("alpha init"); }
static void alpha_run(void) { puts("alpha run"); }
PLUGIN_DECL(alpha_plugin, alpha_init, alpha_run);

static void beta_init(void) { puts("beta init"); }
static void beta_run(void) { puts("beta run"); }
PLUGIN_DECL(beta_plugin, beta_init, beta_run);

static plugin *registry[] = {&alpha_plugin, &beta_plugin};

int main(void)
{
	for (size_t i = 0; i < sizeof registry / sizeof registry[0]; ++i)
	{
		registry[i]->init();
		registry[i]->run();
	}
	return 0;
}
```
- state machine
```c
#include <stdio.h>

typedef struct state state;
struct state
{
	const char *name;
	void (*on_enter)(void);
	const state *(*next)(void);
};

#define STATE(NAME)                                               \
	static void NAME##_enter(void);                               \
	static const state *NAME##_next(void);                        \
	static const state NAME = {#NAME, NAME##_enter, NAME##_next}; \
	static void NAME##_enter(void)
#define STATE_NEXT(NAME) static const state *NAME##_next(void)

STATE(idle) { puts("enter idle"); }
STATE(running) { puts("enter running"); }

STATE_NEXT(idle) { return &running; }
STATE_NEXT(running) { return &idle; }

int main(void)
{
	const state *current = &idle;
	for (int i = 0; i < 4; ++i)
	{
		current->on_enter();
		current = current->next();
	}
	return 0;
}
```
- command dispather
```c
#include <stdio.h>
#include <string.h>

typedef void (*command_fn)(const char *);

typedef struct command
{
	const char *opcode;
	command_fn handler;
} command;

#define CMD(OPCODE, FN) {OPCODE, FN}

static void handle_status(const char *payload)
{
	printf("status: %s\n", payload);
}

static void handle_reset(const char *payload)
{
	printf("reset issued by %s\n", payload);
}

static command table[] = {
	CMD("STATUS", handle_status),
	CMD("RESET", handle_reset)};

static command_fn lookup(const char *opcode)
{
	for (size_t i = 0; i < sizeof table / sizeof table[0]; ++i)
	{
		if (strcmp(table[i].opcode, opcode) == 0)
		{
			return table[i].handler;
		}
	}
	return NULL;
}

int main(void)
{
	struct
	{
		const char *opcode;
		const char *payload;
	} script[] = {
		{"STATUS", "worker-42"},
		{"RESET", "admin"}
	};

	for (size_t i = 0; i < sizeof script / sizeof script[0]; ++i)
	{
		command_fn fn = lookup(script[i].opcode);
		if (fn)
			fn(script[i].payload);
		else
			printf("unknown opcode: %s\n", script[i].opcode);
	}
	return 0;
}
```

- Example: stats handler for several subsystems
- file list
```
.
â”œâ”€â”€ stats_handler1.c
â”œâ”€â”€ stats_handler1.h
â”œâ”€â”€ stats_handler2.c
â”œâ”€â”€ stats_handler2.h
â”œâ”€â”€ stats_handler.c
â””â”€â”€ stats_level.h
```
- stats_level.h
```c
#ifndef STATS_LEVEL_H
#define STATS_LEVEL_H

enum stats_level {
	STATS_LEVEL_INFO = 0,
	STATS_LEVEL_DEBUG = 1
};

#endif
```
- stats_handler1.h
```c
#ifndef STATS_HANDLER1_H
#define STATS_HANDLER1_H

#include "stats_level.h"

void stats_handler1_init(const char *app);
void stats_handler1_free(void);
void stats_handler1_update(void);
void stats_handler1_print(enum stats_level level);
const char *stats_handler1_data_provider_get(void);

#endif
```
- stats_handler2.h
```c
#ifndef STATS_HANDLER2_H
#define STATS_HANDLER2_H

#include "stats_level.h"

void stats_handler2_init(const char *app);
void stats_handler2_free(void);
void stats_handler2_update(void);
void stats_handler2_print(enum stats_level level);
const char *stats_handler2_data_provider_get(void);

#endif
```
- stats_handler.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include "stats_level.h"
#include "stats_handler1.h"
#include "stats_handler2.h"


typedef void (*stats_handler_ops_init)(const char *app);
typedef void (*stats_handler_ops_free)(void);
typedef void (*stats_handler_ops_update)(void);
typedef void (*stats_handler_ops_print)(enum stats_level);
typedef const char* (*stats_handler_ops_data_provider_get)(void);

struct stats_handler_ops {
	stats_handler_ops_init init;
	stats_handler_ops_free free;
	stats_handler_ops_update update;
	stats_handler_ops_print print;
	stats_handler_ops_data_provider_get data_provider_get;
};

static int app_common_enabled_check(const char *name)
{
	if (strcmp(name, "stats_handler1") == 0 ||
		strcmp(name, "stats_handler2") == 0) {
		return 1;
	}

	return 0;
}

/* Dummy "app" just needs to be non-NULL to pass the macro's check */
static int dummy_app_instance = 1;
static void *app = &dummy_app_instance;

/* Macro modeled after your code */
#define IF_PROVIDER_REGISTERED(component, operation)     \
do {                                                     \
	if (app) {                                           \
		const char *o = component.data_provider_get();   \
		if (o) {                                         \
			char *owner = strdup(o);                     \
			uint8_t enabled = 0;                         \
			char *pch, *sp;                              \
			pch = strtok_r(owner, "|", &sp);             \
			while (pch != NULL) {                        \
				if (app_common_enabled_check(pch)) {     \
					enabled = 1;                         \
					break;                               \
				}                                        \
				pch = strtok_r(NULL, "|", &sp);          \
			}                                            \
			if (enabled) {                               \
				component.operation;                     \
			}                                            \
			free(owner);                                 \
		}                                                \
	}                                                    \
}                                                        \
while (0)

static struct stats_handler_ops stats_handler1_ops = {
		.init = stats_handler1_init,
		.free = stats_handler1_free,
		.update = stats_handler1_update,
		.print = stats_handler1_print,
		.data_provider_get = stats_handler1_data_provider_get
};

static struct stats_handler_ops stats_handler2_ops = {
		.init = stats_handler2_init,
		.free = stats_handler2_free,
		.update = stats_handler2_update,
		.print = stats_handler2_print,
		.data_provider_get = stats_handler2_data_provider_get
};

static int stats_enabled = 1;

static void stats_handler_all_init(const char *app)
{
	if (stats_enabled) {
		IF_PROVIDER_REGISTERED(stats_handler1_ops, init(app));
		IF_PROVIDER_REGISTERED(stats_handler2_ops, init(app));
	}
}

static void stats_handler_all_free(void)
{
	if (stats_enabled) {
		IF_PROVIDER_REGISTERED(stats_handler1_ops, free());
		IF_PROVIDER_REGISTERED(stats_handler2_ops, free());
	}
}

static void stats_handler_all_update(void)
{
	if (stats_enabled) {
		IF_PROVIDER_REGISTERED(stats_handler1_ops, update());
		IF_PROVIDER_REGISTERED(stats_handler2_ops, update());
	}
}

static void stats_handler_all_print(enum stats_level level)
{
	if (stats_enabled) {
		IF_PROVIDER_REGISTERED(stats_handler1_ops, print(level));
		IF_PROVIDER_REGISTERED(stats_handler2_ops, print(level));
	}
}

int main(void)
{
	stats_handler_all_init("app1");
	stats_handler_all_update();
	stats_handler_all_print(STATS_LEVEL_INFO);
	stats_handler_all_free();

	return 0;
}
```
- stats_handler1.c
```c
#include <stdio.h>
#include "stats_level.h"

void stats_handler1_init(const char *app)
{
	printf("stats_handler1_init called (app=%s)\n", app);
}

void stats_handler1_free(void)
{
	printf("stats_handler1_free called\n");
}

void stats_handler1_update(void)
{
	printf("stats_handler1_update called\n");
}

void stats_handler1_print(enum stats_level level)
{
	printf("stats_handler1_print called (level=%d)\n", level);
}

const char *stats_handler1_data_provider_get(void)
{
	return "stats_handler1";
}
```
- stats_handler2.c
```c
#include <stdio.h>
#include "stats_level.h"

void stats_handler2_init(const char *app)
{
	printf("stats_handler2_init called (app=%s)\n", app);
}

void stats_handler2_free(void)
{
	printf("stats_handler2_free called\n");
}

void stats_handler2_update(void)
{
	printf("stats_handler2_update called\n");
}

void stats_handler2_print(enum stats_level level)
{
	printf("stats_handler2_print called (level=%d)\n", level);
}

const char *stats_handler2_data_provider_get(void)
{
	return "stats_handler2";
}
```

## ç®€åŒ–ç‰ˆæ’ä»¶æ¶æ„ç¤ºä¾‹
- æ–‡ä»¶ç»“æ„
```
plugin
â”œâ”€â”€ main.c            # ä¸»ç¨‹åº
â”œâ”€â”€ plugin.h           # æ’ä»¶æ¥å£å®šä¹‰
â”œâ”€â”€ plugin_a.c        # æ’ä»¶Aå®ç°
â”œâ”€â”€ plugin_b.c        # æ’ä»¶Bå®ç°
â””â”€â”€ Makefile          # ç¼–è¯‘è„šæœ¬
```
- plugin.h, plugin_a.c, plugin_b.c
```c
// plugin.h
#ifndef PLUGIN_H
#define PLUGIN_H

// æ’ä»¶æ¥å£ç»“æ„ä½“
typedef struct
{
	const char *name;
	void (*init)(void);
	void (*execute)(void);
	void (*cleanup)(void);
} Plugin;

// æ’ä»¶æ³¨å†Œå‡½æ•°ç±»å‹
typedef Plugin *(*RegisterPluginFunc)(void);

#endif // PLUGIN_H

// plugin_a.c
#include <stdio.h>
#include "plugin.h"

// æ’ä»¶Açš„åˆå§‹åŒ–å‡½æ•°
static void plugin_a_init(void)
{
	printf("Plugin A initialized\n");
}

// æ’ä»¶Açš„æ‰§è¡Œå‡½æ•°
static void plugin_a_execute(void)
{
	printf("Plugin A executing...\n");
}

// æ’ä»¶Açš„æ¸…ç†å‡½æ•°
static void plugin_a_cleanup(void)
{
	printf("Plugin A cleaned up\n");
}

// æ’ä»¶Açš„æ¥å£å®ä¾‹
static Plugin plugin_a = {
	.name = "PluginA",
	.init = plugin_a_init,
	.execute = plugin_a_execute,
	.cleanup = plugin_a_cleanup};

// æ’ä»¶æ³¨å†Œå‡½æ•°
__attribute__((visibility("default")))
Plugin *
register_plugin(void)
{
	return &plugin_a;
}

// plugin_b.c
#include <stdio.h>
#include "plugin.h"

// æ’ä»¶Bçš„åˆå§‹åŒ–å‡½æ•°
static void plugin_b_init(void)
{
	printf("Plugin B initialized\n");
}

// æ’ä»¶Bçš„æ‰§è¡Œå‡½æ•°
static void plugin_b_execute(void)
{
	printf("Plugin B executing...\n");
}

// æ’ä»¶Bçš„æ¸…ç†å‡½æ•°
static void plugin_b_cleanup(void)
{
	printf("Plugin B cleaned up\n");
}

// æ’ä»¶Bçš„æ¥å£å®ä¾‹
static Plugin plugin_b = {
	.name = "PluginB",
	.init = plugin_b_init,
	.execute = plugin_b_execute,
	.cleanup = plugin_b_cleanup};

// æ’ä»¶æ³¨å†Œå‡½æ•°
__attribute__((visibility("default")))
Plugin *
register_plugin(void)
{
	return &plugin_b;
}

// main.c
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <dirent.h>
#include "plugin.h"

#define PLUGIN_DIR "./plugins"

int main()
{
	DIR *dir;
	struct dirent *entry;

	// æ‰“å¼€æ’ä»¶ç›®å½•
	if ((dir = opendir(PLUGIN_DIR)) == NULL)
	{
		perror("opendir");
		return EXIT_FAILURE;
	}

	// éå†æ’ä»¶ç›®å½•
	while ((entry = readdir(dir)) != NULL)
	{
		// åªå¤„ç†.soæ–‡ä»¶
		if (entry->d_type != DT_REG)
			continue;
		char *ext = strrchr(entry->d_name, '.');
		if (!ext || strcmp(ext, ".so") != 0)
			continue;

		// æ„å»ºå®Œæ•´è·¯å¾„
		char path[PATH_MAX];
		snprintf(path, sizeof(path), "%s/%s", PLUGIN_DIR, entry->d_name);

		// åŠ è½½æ’ä»¶
		void *handle = dlopen(path, RTLD_LAZY);
		if (!handle)
		{
			fprintf(stderr, "Error loading %s: %s\n", path, dlerror());
			continue;
		}

		// è·å–æ³¨å†Œå‡½æ•°
		RegisterPluginFunc register_plugin = dlsym(handle, "register_plugin");
		if (!register_plugin)
		{
			fprintf(stderr, "Error finding register_plugin in %s: %s\n", path, dlerror());
			dlclose(handle);
			continue;
		}

		// æ³¨å†Œå¹¶è·å–æ’ä»¶æ¥å£
		Plugin *plugin = register_plugin();
		if (!plugin)
		{
			fprintf(stderr, "Plugin registration failed for %s\n", path);
			dlclose(handle);
			continue;
		}

		// ä½¿ç”¨æ’ä»¶
		printf("\n=== Using plugin: %s ===\n", plugin->name);
		plugin->init();
		plugin->execute();
		plugin->cleanup();

		// å…³é—­æ’ä»¶
		dlclose(handle);
	}

	closedir(dir);
	return EXIT_SUCCESS;
}
```

- Makefile
```makefile
CC = gcc
CFLAGS = -Wall -Wextra -fPIC
LDFLAGS = -ldl

# ä¸»ç¨‹åºç›®æ ‡
TARGET = plugin_demo

# æ’ä»¶ç›®å½•
PLUGIN_DIR = plugins

# æ’ä»¶ç›®æ ‡
PLUGINS = $(PLUGIN_DIR)/plugin_a.so $(PLUGIN_DIR)/plugin_b.so

all: $(TARGET) $(PLUGINS)

$(TARGET): main.c
	$(CC) $(CFLAGS) -o $@ $< $(LDFLAGS)

$(PLUGIN_DIR)/plugin_a.so: plugin_a.c plugin.h
	@mkdir -p $(PLUGIN_DIR)
	$(CC) $(CFLAGS) -shared -o $@ $<

$(PLUGIN_DIR)/plugin_b.so: plugin_b.c plugin.h
	@mkdir -p $(PLUGIN_DIR)
	$(CC) $(CFLAGS) -shared -o $@ $<

run: all
	./$(TARGET)

clean:
	rm -f $(TARGET) $(PLUGINS)
	rmdir $(PLUGIN_DIR) 2>/dev/null || true

.PHONY: all run clean

```

## string
[Library Functions](https://www.ibm.com/docs/en/i/7.4.0?topic=functions-library)  
[String and Array Utilities](https://www.gnu.org/software/libc/manual/html_node/String-and-Array-Utilities.html)  
[The String Span Functions](https://c-for-dummies.com/blog/?p=5068)  
[Parsing Words with the strspn() Function](https://c-for-dummies.com/blog/?p=5072)  
[Slicing Strings with strsep()](https://c-for-dummies.com/blog/?p=1769)  
[How to Use strtok and strtok_r in C](https://systems-encyclopedia.cs.illinois.edu/articles/c-strtok/)  
[strtok](https://icarus.cs.weber.edu/~dab/cs1410/textbook/8.Strings/more_cstring.html)  
[The Standard C Library for Linux, part 7: String Handling](https://linuxgazette.net/issue76/rogers.html)  
[C Programming/String manipulation](https://en.wikibooks.org/wiki/C_Programming/String_manipulation)  
[String Functions in C (Full List With Examples)](https://www.wscubetech.com/resources/c-programming/string-functions)  
[Standard C Library Functions Table, By Name](https://www.ibm.com/docs/en/i/7.5.0?topic=extensions-standard-c-library-functions-table-by-name)  
[]()  
[]()  

## socket
```c
//
#include <sys/types.h>
#include <sys/socket.h>

/*
 * domain: specifies an address family.
 * type: specifies communication semantics.
 * protocol: specifies a concrete protocol type
*/
int socket(int domain, int type, int protocol);

// domain
/*
| Macro                  | Description                     | Struct Used               | Typical Use                       |
| ---------------------- | ------------------------------- | ------------------------- | --------------------------------- |
| `AF_INET`              | IPv4 Internet protocols         | `struct sockaddr_in`      | IPv4 TCP/UDP communication        |
| `AF_INET6`             | IPv6 Internet protocols         | `struct sockaddr_in6`     | IPv6 TCP/UDP communication        |
| `AF_UNIX` / `AF_LOCAL` | Local communication (same host) | `struct sockaddr_un`      | UNIX domain sockets               |
| `AF_PACKET`            | Raw packet access (Layer 2)     | `struct sockaddr_ll`      | Network sniffers, raw Ethernet    |
| `AF_NETLINK`           | Kernel-user communication       | `struct sockaddr_nl`      | Routing, Netfilter, kernel events |
| `AF_BLUETOOTH`         | Bluetooth protocol              | `struct sockaddr_rc` etc. | Bluetooth communication           |

// type
| Macro            | Description                          | Semantics                          |
| ---------------- | ------------------------------------ | ---------------------------------- |
| `SOCK_STREAM`    | Stream-oriented (connection-based)   | Reliable byte stream (TCP)         |
| `SOCK_DGRAM`     | Datagram-oriented (connectionless)   | Unreliable message (UDP)           |
| `SOCK_RAW`       | Raw network protocol access          | Direct access to IP layer          |
| `SOCK_SEQPACKET` | Sequenced, reliable, record-oriented | Used with UNIX domain or Bluetooth |
| `SOCK_PACKET`    | (Deprecated) raw packets             | Legacy code only                   |

// protocol
| Domain      | Type          | Protocol           | Meaning                     |
| ----------- | ------------- | ------------------ | --------------------------- |
| `AF_INET`   | `SOCK_STREAM` | `IPPROTO_TCP`      | TCP                         |
| `AF_INET`   | `SOCK_DGRAM`  | `IPPROTO_UDP`      | UDP                         |
| `AF_INET`   | `SOCK_RAW`    | `IPPROTO_ICMP`     | Raw ICMP socket             |
| `AF_PACKET` | `SOCK_RAW`    | `htons(ETH_P_ALL)` | Capture all Ethernet frames |
| `AF_UNIX`   | `SOCK_STREAM` | `0`                | Local stream socket         |
*/

struct sockaddr {
    sa_family_t sa_family;
    char        sa_data[14];
}



// ipv4
struct sockaddr_in {
    sa_family_t    sin_family; // Address family (AF_INET)
    in_port_t      sin_port;   // Port number (network byte order)
    struct in_addr sin_addr;   // IP address
    unsigned char  sin_zero[8]; // Padding
};

struct in_addr {
  uint32_t       s_addr;     /* address in network byte order */
};

// ipv6
struct sockaddr_in6 {
    sa_family_t     sin6_family;   // AF_INET6
    in_port_t       sin6_port;     // Port number
    uint32_t        sin6_flowinfo; // Flow information
    struct in6_addr sin6_addr;     // IPv6 address
    uint32_t        sin6_scope_id; // Scope ID
};

struct in6_addr {
  unsigned char   s6_addr[16];   /* IPv6 address */
};

// unix domain socket
struct sockaddr_un {
    sa_family_t sun_family;              // AF_UNIX
    char        sun_path[108];           // Pathname
};

// tcp
// server.c
// tcp_server.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

int main() {
    int server_fd, client_fd;
    struct sockaddr_in addr;
    char buffer[1024];

    // 1. Create socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 2. Bind to a port
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8080);
    addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // 3. Listen
    listen(server_fd, 5);
    printf("Server listening on port 8080...\n");

    // 4. Accept
    client_fd = accept(server_fd, NULL, NULL);
    printf("Client connected!\n");

    // 5. Communicate
    recv(client_fd, buffer, sizeof(buffer), 0);
    printf("Received: %s\n", buffer);
    send(client_fd, "Hello Client!", 13, 0);

    close(client_fd);
    close(server_fd);
    return 0;
}

// client.c
// tcp_client.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

int main() {
    int sock;
    struct sockaddr_in server;
    char buffer[1024];

    // 1. Create socket
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 2. Set up server address
    server.sin_family = AF_INET;
    server.sin_port = htons(8080);
    inet_pton(AF_INET, "127.0.0.1", &server.sin_addr);

    // 3. Connect
    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {
        perror("connect");
        exit(EXIT_FAILURE);
    }

    // 4. Communicate
    send(sock, "Hello Server!", 13, 0);
    recv(sock, buffer, sizeof(buffer), 0);
    printf("Received: %s\n", buffer);

    close(sock);
    return 0;
}

// udp
// server.c
// udp_server.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

int main() {
    int sockfd;
    struct sockaddr_in server_addr, client_addr;
    char buffer[1024];
    socklen_t addr_len = sizeof(client_addr);

    // 1. Create socket
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 2. Bind to a port
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(9000);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    printf("UDP server listening on port 9000...\n");

    // 3. Receive datagram
    ssize_t n = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0,
                         (struct sockaddr*)&client_addr, &addr_len);
    buffer[n] = '\0';
    printf("Received from client: %s\n", buffer);

    // 4. Send response
    sendto(sockfd, "Hello from UDP server!", 23, 0,
           (struct sockaddr*)&client_addr, addr_len);

    close(sockfd);
    return 0;
}

// client.c
// udp_client.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

int main() {
    int sockfd;
    struct sockaddr_in server_addr;
    char buffer[1024];
    socklen_t addr_len = sizeof(server_addr);

    // 1. Create socket
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 2. Define server
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(9000);
    inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr);

    // 3. Send datagram
    sendto(sockfd, "Hello UDP Server!", 18, 0,
           (struct sockaddr*)&server_addr, addr_len);

    // 4. Receive response
    ssize_t n = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0,
                         (struct sockaddr*)&server_addr, &addr_len);
    buffer[n] = '\0';
    printf("Server reply: %s\n", buffer);

    close(sockfd);
    return 0;
}

// unix domain socket
// server.c
// unix_server.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define SOCKET_PATH "/tmp/demo_socket"

int main() {
    int server_fd, client_fd;
    struct sockaddr_un addr;
    char buffer[100];

    unlink(SOCKET_PATH); // Remove old socket file

    server_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);

    if (bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    listen(server_fd, 5);
    printf("UNIX server listening on %s...\n", SOCKET_PATH);

    client_fd = accept(server_fd, NULL, NULL);
    read(client_fd, buffer, sizeof(buffer));
    printf("Received: %s\n", buffer);
    write(client_fd, "Hi UNIX client!", 15);

    close(client_fd);
    close(server_fd);
    unlink(SOCKET_PATH);
    return 0;
}

// client.c
// unix_client.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define SOCKET_PATH "/tmp/demo_socket"

int main() {
    int sockfd;
    struct sockaddr_un addr;
    char buffer[100];

    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);

    if (connect(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("connect");
        exit(EXIT_FAILURE);
    }

    write(sockfd, "Hello UNIX server!", 19);
    read(sockfd, buffer, sizeof(buffer));
    printf("Server says: %s\n", buffer);

    close(sockfd);
    return 0;
}

// raw socket (requires root privileges)
/*
 * Raw sockets allow user-space programs to:
 * Capture or send raw Ethernet frames,
 * Bypass the TCP/UDP/IP stack,
 * Inspect headers for tools like tcpdump, Wireshark, or custom packet sniffers.
*/
// packet_sniffer.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>	// For ETH_P_ALL
#include <net/if.h>			// For if_nametoindex()

int main() {
    int sockfd;
    struct sockaddr_ll sll;
    unsigned char buffer[2048];

    // 1. Create a raw socket
    sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sockfd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 2. Bind to a specific network interface (e.g., eth0)
    memset(&sll, 0, sizeof(sll));
    sll.sll_family = AF_PACKET;
    sll.sll_protocol = htons(ETH_P_ALL);
    sll.sll_ifindex = if_nametoindex("eth0"); // replace with your NIC name
    if (sll.sll_ifindex == 0) {
        perror("if_nametoindex");
        exit(EXIT_FAILURE);
    }

    if (bind(sockfd, (struct sockaddr*)&sll, sizeof(sll)) < 0) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    printf("Listening on interface eth0 for raw Ethernet frames...\n");

    // 3. Receive packets
    while (1) {
        ssize_t n = recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);
        if (n < 0) {
            perror("recvfrom");
            break;
        }

        struct ethhdr *eth = (struct ethhdr *)buffer;

        printf("\n--- Ethernet Frame ---\n");
        printf("Destination MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
               eth->h_dest[0], eth->h_dest[1], eth->h_dest[2],
               eth->h_dest[3], eth->h_dest[4], eth->h_dest[5]);
        printf("Source MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
               eth->h_source[0], eth->h_source[1], eth->h_source[2],
               eth->h_source[3], eth->h_source[4], eth->h_source[5]);
        printf("EtherType: 0x%04x\n", ntohs(eth->h_proto));
        printf("Payload length: %zd bytes\n", n - sizeof(struct ethhdr));
    }

    close(sockfd);
    return 0;
}

// packet_sender.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <net/if.h>

int main() {
    int sockfd;
    struct sockaddr_ll sll;
    unsigned char frame[1500];

    // 1. Create raw socket
    sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sockfd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 2. Get interface index
    int ifindex = if_nametoindex("eth0"); // replace with your interface
    if (ifindex == 0) {
        perror("if_nametoindex");
        exit(EXIT_FAILURE);
    }

    // 3. Prepare destination
    memset(&sll, 0, sizeof(sll));
    sll.sll_family = AF_PACKET;
    sll.sll_ifindex = ifindex;
    sll.sll_halen = ETH_ALEN;
    sll.sll_addr[0] = 0xff; // Broadcast address
    sll.sll_addr[1] = 0xff;
    sll.sll_addr[2] = 0xff;
    sll.sll_addr[3] = 0xff;
    sll.sll_addr[4] = 0xff;
    sll.sll_addr[5] = 0xff;

    // 4. Build Ethernet frame
    struct ethhdr *eth = (struct ethhdr *)frame;
    memset(eth->h_dest, 0xff, ETH_ALEN);       // Destination: broadcast
    memset(eth->h_source, 0x11, ETH_ALEN);     // Fake source
    eth->h_proto = htons(0x88B5);              // Custom Ethertype
    strcpy((char *)(frame + sizeof(struct ethhdr)), "Hello Raw World!");

    // 5. Send
    ssize_t frame_len = sizeof(struct ethhdr) + strlen("Hello Raw World!");
    if (sendto(sockfd, frame, frame_len, 0, (struct sockaddr*)&sll, sizeof(sll)) < 0) {
        perror("sendto");
    } else {
        printf("Sent raw Ethernet frame (%zd bytes)\n", frame_len);
    }

    close(sockfd);
    return 0;
}

// socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)
// icmp_ping.c
// headers
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/ip_icmp.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <errno.h>

// ICMP Header (as defined in <netinet/ip_icmp.h>)
struct icmphdr {
    uint8_t  type;      // e.g., ICMP_ECHO
    uint8_t  code;
    uint16_t checksum;
    uint16_t id;
    uint16_t sequence;
};

// ICMP checksum function
unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    for (sum = 0; len > 1; len -= 2)
        sum += *buf++;
    if (len == 1)
        sum += *(unsigned char*)buf;

    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

// ping_raw.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/ip_icmp.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <errno.h>

unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;
    for (sum = 0; len > 1; len -= 2)
        sum += *buf++;
    if (len == 1)
        sum += *(unsigned char*)buf;
    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: sudo %s <destination IP>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int sockfd;
    struct sockaddr_in dest;
    char packet[64];
    struct icmphdr *icmp = (struct icmphdr*)packet;

    // 1. Create raw socket for ICMP
    sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sockfd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 2. Setup destination address
    memset(&dest, 0, sizeof(dest));
    dest.sin_family = AF_INET;
    inet_pton(AF_INET, argv[1], &dest.sin_addr);

    // 3. Build ICMP Echo Request
    memset(packet, 0, sizeof(packet));
    icmp->type = ICMP_ECHO;   // 8
    icmp->code = 0;
    icmp->un.echo.id = getpid() & 0xFFFF;
    icmp->un.echo.sequence = 1;
    icmp->checksum = 0;
    icmp->checksum = checksum(packet, sizeof(packet));

    // 4. Record time and send
    struct timeval start, end;
    gettimeofday(&start, NULL);

    if (sendto(sockfd, packet, sizeof(packet), 0,
               (struct sockaddr*)&dest, sizeof(dest)) <= 0) {
        perror("sendto");
        exit(EXIT_FAILURE);
    }

    // 5. Wait for reply
    char recvbuf[1024];
    struct sockaddr_in reply_addr;
    socklen_t addr_len = sizeof(reply_addr);

    ssize_t n = recvfrom(sockfd, recvbuf, sizeof(recvbuf), 0,
                         (struct sockaddr*)&reply_addr, &addr_len);
    if (n < 0) {
        perror("recvfrom");
        exit(EXIT_FAILURE);
    }

    gettimeofday(&end, NULL);

    double rtt = (end.tv_sec - start.tv_sec) * 1000.0 +
                 (end.tv_usec - start.tv_usec) / 1000.0;

    printf("Reply from %s: bytes=%zd time=%.3f ms\n",
           argv[1], n, rtt);

    close(sockfd);
    return 0;
}

// AF_UNIX (local IPC)
// server.c
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main(void) {
	int fd;
	struct sockaddr_un addr;
	const char *path = "/tmp/example.sock";
	char buf[256];
	ssize_t n;
	struct sockaddr_un peer;
	socklen_t peerlen = sizeof(peer);

	fd = socket(AF_UNIX, SOCK_DGRAM, 0);
	if (fd < 0) return 1;

	unlink(path); // ensure clean
	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);

	if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0) return 1;

	n = recvfrom(fd, buf, sizeof(buf) - 1, 0, (struct sockaddr *)&peer, &peerlen);
	if (n > 0) {
		buf[n] = '\0';
		printf("got: %s\n", buf);
	}
	close(fd);
	unlink(path);
	return 0;
}

// client.c
#include <sys/socket.h>
#include <sys/un.h>
#include <string.h>
#include <unistd.h>

int main(void) {
	int fd;
	struct sockaddr_un dst;
	const char *path = "/tmp/example.sock";
	const char *msg = "hello";

	fd = socket(AF_UNIX, SOCK_DGRAM, 0);
	if (fd < 0) return 1;

	memset(&dst, 0, sizeof(dst));
	dst.sun_family = AF_UNIX;
	strncpy(dst.sun_path, path, sizeof(dst.sun_path) - 1);

	sendto(fd, msg, strlen(msg), 0, (struct sockaddr *)&dst, sizeof(dst));
	close(fd);
	return 0;
}

// AF_INET (TCP)
// server.c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

int main(void) {
	int s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	struct sockaddr_in addr = {0};
	int c;
	if (s < 0) return 1;

	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
	addr.sin_port = htons(8080);

	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) return 1;
	if (listen(s, 16) < 0) return 1;

	c = accept(s, NULL, NULL);
	if (c >= 0) {
		const char *resp = "hi\n";
		send(c, resp, 3, 0);
		close(c);
	}
	close(s);
	return 0;
}

// client.c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>

int main(void) {
	int s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	struct sockaddr_in addr = {0};
	if (s < 0) return 1;

	addr.sin_family = AF_INET;
	addr.sin_port = htons(8080);
	inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);

	if (connect(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) return 1;
	send(s, "hello", 5, 0);
	close(s);
	return 0;
}

// AF_INET6 (IPv6 TCP)
// server.c
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <string.h>

int main(void) {
	int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
	struct sockaddr_in6 addr = {0};
	int v6only = 1;

	if (s < 0) return 1;
	setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));

	addr.sin6_family = AF_INET6;
	addr.sin6_addr = in6addr_any;
	addr.sin6_port = htons(8080);

	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) return 1;
	if (listen(s, 16) < 0) return 1;

	int c = accept(s, NULL, NULL);
	if (c >= 0) close(c);
	close(s);
	return 0;
}

// client.c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

int main(void) {
	int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
	struct sockaddr_in6 addr = {0};
	if (s < 0) return 1;

	addr.sin6_family = AF_INET6;
	addr.sin6_port = htons(8080);
	inet_pton(AF_INET6, "::1", &addr.sin6_addr);

	if (connect(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) return 1;
	close(s);
	return 0;
}

// AF_NETLINK  (kernel-user communication)
// receiver.c
#include <sys/socket.h>
#include <linux/netlink.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main(void) {
	int s = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
	struct sockaddr_nl addr = {0};
	char buf[8192];
	struct nlmsghdr *nlh;

	if (s < 0) return 1;

	addr.nl_family = AF_NETLINK;
	addr.nl_pid = getpid();      // unique user-space PID
	addr.nl_groups = RTMGRP_LINK; // subscribe to link events

	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) return 1;

	ssize_t n = recv(s, buf, sizeof(buf), 0);
	if (n > 0) {
		nlh = (struct nlmsghdr *)buf;
		printf("got netlink msg type=%d len=%d\n", nlh->nlmsg_type, nlh->nlmsg_len);
	}
	close(s);
	return 0;
}

// sender.c
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <unistd.h>
#include <string.h>

int main(void) {
	int s = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
	struct sockaddr_nl dst = {0};
	struct {
		struct nlmsghdr nlh;
		struct rtgenmsg gen;
	} req = {0};

	if (s < 0) return 1;

	dst.nl_family = AF_NETLINK;

	req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg));
	req.nlh.nlmsg_type = RTM_GETLINK;
	req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
	req.gen.rtgen_family = AF_UNSPEC;

	struct iovec iov = { &req, req.nlh.nlmsg_len };
	struct msghdr msg = {0};
	msg.msg_name = &dst;
	msg.msg_namelen = sizeof(dst);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	if (sendmsg(s, &msg, 0) < 0) return 1;
	close(s);
	return 0;
}

// AF_PACKET (link layer, raw Ethernet; requires root)
// receiver.c
#include <sys/socket.h>
#include <netpacket/packet.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>

int main(void) {
	int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	struct sockaddr_ll addr = {0};
	char buf[2048];
	ssize_t n;

	if (s < 0) return 1;

	addr.sll_family = AF_PACKET;
	addr.sll_protocol = htons(ETH_P_ALL);
	addr.sll_ifindex = if_nametoindex("eth0");

	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) return 1;

	n = recv(s, buf, sizeof(buf), 0);
	if (n > 0) printf("got %zd bytes\n", n);

	close(s);
	return 0;
}

// sender.c
#include <sys/socket.h>
#include <netpacket/packet.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <string.h>
#include <unistd.h>

int main(void) {
	int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_IP));
	struct sockaddr_ll dst = {0};
	unsigned char frame[64] = {0}; // fill with valid Ethernet frame

	if (s < 0) return 1;

	dst.sll_family = AF_PACKET;
	dst.sll_ifindex = if_nametoindex("eth0");
	dst.sll_halen = ETH_ALEN;
	// set dst.sll_addr[0..5] to target MAC

	sendto(s, frame, sizeof(frame), 0, (struct sockaddr *)&dst, sizeof(dst));
	close(s);
	return 0;
}

// function prototype for setsockopt
int setsockopt(int sockfd, int level, int optname,
               const void *optval, socklen_t optlen);

// SOL_SOCKET: socket level options
| Option                                |       Value type | Purpose / typical use                                                             |
| ------------------------------------- | ---------------: | --------------------------------------------------------------------------------- |
| `SO_REUSEADDR`                        |      `int` (0/1) | Allow binding to an address in `TIME_WAIT`. Common on servers to restart quickly. |
| `SO_REUSEPORT`                        |      `int` (0/1) | Allow multiple sockets bind same (addr,port) (load-sharing on some kernels).      |
| `SO_KEEPALIVE`                        |      `int` (0/1) | Enable TCP keepalive probes (basic on/off; details set via TCP_* options).        |
| `SO_BROADCAST`                        |      `int` (0/1) | Enable sending datagrams to broadcast addresses (UDP).                            |
| `SO_RCVBUF` / `SO_SNDBUF`             |    `int` (bytes) | Set kernel receive / send buffer sizes.                                           |
| `SO_RCVTIMEO` / `SO_SNDTIMEO`         | `struct timeval` | Set blocking I/O timeouts for `recv`/`send`.                                      |
| `SO_LINGER`                           |  `struct linger` | Control close behavior (block until sent or drop).                                |
| `SO_ERROR`                            |   `int` (output) | Query pending error on socket (use with `getsockopt`).                            |
| `SO_OOBINLINE`                        |      `int` (0/1) | Receive TCP OOB data inline with normal data.                                     |
| `SO_ACCEPTCONN`                       |   `int` (output) | Check if socket is listening (from `getsockopt`).                                 |
| `SO_DOMAIN`, `SO_TYPE`, `SO_PROTOCOL` |   `int` (output) | Query socket properties.                                                          |

// IPPROTO_TCP: TCP level options
| Option          |      Value type | Purpose                                                                         |
| --------------- | --------------: | ------------------------------------------------------------------------------- |
| `TCP_NODELAY`   |     `int` (0/1) | Disable Nagle (send small packets immediately). Useful for low-latency apps.    |
| `TCP_CORK`      |     `int` (0/1) | Linux: hold back partial frames until cork cleared (for packetization control). |
| `TCP_KEEPIDLE`  | `int` (seconds) | Idle time before first keepalive probe.                                         |
| `TCP_KEEPINTVL` | `int` (seconds) | Interval between keepalive probes.                                              |
| `TCP_KEEPCNT`   |           `int` | Number of probes before declaring connection dead.                              |
| `TCP_SYNCNT`    |           `int` | Number of SYN retransmits before aborting connect() (Linux).                    |
| `TCP_QUICKACK`  |           `int` | Control delayed ACK behavior (Linux).                                           |

// IPPROTO_IP / IP: IPv4 level options
| Option               | Value type / struct       | Purpose                                                  |
| -------------------- | ------------------------- | -------------------------------------------------------- |
| `IP_TTL`             | `int`                     | Set IP time-to-live for outgoing packets.                |
| `IP_MULTICAST_TTL`   | `unsigned char`           | TTL for IPv4 multicast packets.                          |
| `IP_MULTICAST_LOOP`  | `unsigned char`           | Loopback for multicast (0/1).                            |
| `IP_MULTICAST_IF`    | `struct in_addr` or `int` | Choose outgoing interface for multicast.                 |
| `IP_ADD_MEMBERSHIP`  | `struct ip_mreq`          | Join IPv4 multicast group.                               |
| `IP_DROP_MEMBERSHIP` | `struct ip_mreq`          | Leave multicast group.                                   |
| `IP_PKTINFO`         | `int`                     | Receive destination address and iface info in `recvmsg`. |
| `IP_HDRINCL`         | `int` (0/1)               | Include custom IP header when sending (raw sockets).     |

// IPPROTO_IPV6: IPv6 level options
| Option                |         Value type | Purpose                                                          |
| --------------------- | -----------------: | ---------------------------------------------------------------- |
| `IPV6_JOIN_GROUP`     | `struct ipv6_mreq` | Join IPv6 multicast group.                                       |
| `IPV6_LEAVE_GROUP`    | `struct ipv6_mreq` | Leave group.                                                     |
| `IPV6_MULTICAST_HOPS` |              `int` | Multicast hop limit (TTL).                                       |
| `IPV6_V6ONLY`         |              `int` | If set, socket will accept only IPv6 (no IPv4-mapped addresses). |
| `IPV6_PKTINFO`        |              `int` | Similar to `IP_PKTINFO` for IPv6.                                |

// SOL_SOCKET for advanced use
SO_ATTACH_FILTER / SO_DETACH_FILTER â€” attach BPF filter (raw capture) (Linux).
SO_PASSCRED â€” get sender credentials on Unix domain sockets.
SO_TIMESTAMP / SO_TIMESTAMPNS / SO_TIMESTAMPING â€” enable kernel packet timestamps.

// Typical application usage
TCP server that wants fast restart
	SO_REUSEADDR (and sometimes SO_REUSEPORT) before bind().
High-throughput network app
	Increase SO_RCVBUF / SO_SNDBUF and tune TCP window scaling.
Low-latency app (e.g., RPC, games)
	TCP_NODELAY (disable Nagle) + smaller send batching.
Long-lived idle connections (NAT/firewall keepalive)
	SO_KEEPALIVE + TCP_KEEPIDLE / TCP_KEEPINTVL / TCP_KEEPCNT.
UDP multicast receiver
	IP_ADD_MEMBERSHIP to join group, IP_MULTICAST_IF to pick interface.
Raw packet generation
	IP_HDRINCL if you want to provide the IP header.
Non-blocking I/O with timeout fallback
	SO_RCVTIMEO / SO_SNDTIMEO (or set non-blocking + select/poll/epoll).
Graceful close vs force close
	SO_LINGER with l_onoff controls whether close() blocks to send pending data.

```

## hash table
```c
/*
Hash Buckets
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚  0  â”‚  1  â”‚  2  â”‚  3  â”‚ ... â”‚ ... â”‚ ... â”‚ ... â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
   â”‚     â”‚     â”‚     â”‚           â”‚     â”‚     â”‚
   â”‚     â”‚     â”‚     â”‚           â”‚     â”‚     â””â”€â–º Node â†’ Node â†’ nil
   â”‚     â”‚     â”‚     â”‚           â”‚     â””â”€â–º nil
   â”‚     â”‚     â”‚     â”‚           â””â”€â–º Node â†’ nil
   â”‚     â”‚     â”‚     â””â”€â–º Node â†’ Node â†’ Node â†’ nil
   â”‚     â”‚     â””â”€â–º nil
   â”‚     â””â”€â–º Node â†’ nil
   â””â”€â–º Node â†’ Node â†’ nil
*/
/* -- 1 -- */
/*  hash.c  â€“  tiny educational hash table  */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- tunables ---------- */
#define NUM_BUCKETS 16          /* must be power of two for fast mod */

/* ---------- node in linked list ---------- */
typedef struct Node {
    char *key;
    char *val;
    struct Node *next;
} Node;

/* ---------- the table ---------- */
typedef struct HashTable {
    Node *buckets[NUM_BUCKETS]; /* array of list heads */
} HashTable;

/* ---------- djb2 hash (Kernighan/Pike) ---------- */
static unsigned long hash(const char *str)
{
    unsigned long h = 5381;
    int c;
    while ((c = *str++))
        h = ((h << 5) + h) + c;   /* h * 33 + c */
    return h;
}

/* ---------- create empty table ---------- */
HashTable *ht_create(void)
{
    HashTable *ht = malloc(sizeof *ht);
    for (int i = 0; i < NUM_BUCKETS; ++i)
        ht->buckets[i] = NULL;
    return ht;
}

/* ---------- insert or update ---------- */
void ht_insert(HashTable *ht, const char *key, const char *val)
{
    unsigned idx = hash(key) & (NUM_BUCKETS - 1); /* fast modulo */
    Node *n = ht->buckets[idx];

    /* update if key already present */
    for (; n; n = n->next) {
        if (strcmp(n->key, key) == 0) {
            free(n->val);
            n->val = strdup(val);
            return;
        }
    }

    /* create new node and push to front */
    n = malloc(sizeof *n);
    n->key   = strdup(key);
    n->val   = strdup(val);
    n->next  = ht->buckets[idx];
    ht->buckets[idx] = n;
}

/* ---------- search ---------- */
const char *ht_search(HashTable *ht, const char *key)
{
    unsigned idx = hash(key) & (NUM_BUCKETS - 1);
    for (Node *n = ht->buckets[idx]; n; n = n->next)
        if (strcmp(n->key, key) == 0)
            return n->val;
    return NULL;                /* not found */
}

/* ---------- delete ---------- */
void ht_delete(HashTable *ht, const char *key)
{
    unsigned idx = hash(key) & (NUM_BUCKETS - 1);
    Node **link = &ht->buckets[idx]; /* pointer to pointer trick */
    while (*link) {
        Node *n = *link;
        if (strcmp(n->key, key) == 0) {
            *link = n->next;    /* unlink */
            free(n->key);
            free(n->val);
            free(n);
            return;
        }
        link = &n->next;
    }
}

/* ---------- free everything ---------- */
void ht_destroy(HashTable *ht)
{
    for (int i = 0; i < NUM_BUCKETS; ++i) {
        Node *n = ht->buckets[i];
        while (n) {
            Node *next = n->next;
            free(n->key);
            free(n->val);
            free(n);
            n = next;
        }
    }
    free(ht);
}

/* ---------- demo ---------- */
int main(void)
{
    HashTable *ht = ht_create();

    ht_insert(ht, "apple", "red");
    ht_insert(ht, "banana", "yellow");
    ht_insert(ht, "lemon", "yellow");
    ht_insert(ht, "pear", "green");

    printf("banana â†’ %s\n", ht_search(ht, "banana"));
    printf("pear   â†’ %s\n", ht_search(ht, "pear"));
    printf("grape  â†’ %s\n", ht_search(ht, "grape")); /* not found */

    ht_delete(ht, "banana");
    printf("banana after delete â†’ %s\n", ht_search(ht, "banana"));

    ht_destroy(ht);
    return 0;
}

/* -- 2 -- */
/*  hash.c  â€“  tiny educational hash table  */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ---------- tunables ---------- */
#define NUM_BUCKETS 16          /* must be power of two for fast mod */

/* ---------- node in linked list ---------- */
typedef struct Node {
    char       *key;
    void       *value;
    struct Node *next;
} Node;

/* ---------- the table ---------- */
typedef struct {
    Node *buckets[NUM_BUCKETS];
    /* optional user-supplied helpers */
    void *(*value_copy)(const void *);   /* strdup for your type */
    void  (*value_free)(void *);         /* free for your type */
} HashTable;

/* ---------- djb2 hash (Kernighan/Pike) ---------- */
static unsigned long hash(const char *str)
{
    unsigned long h = 5381;
    int c;
    while ((c = *str++))
        h = ((h << 5) + h) + c;   /* h * 33 + c */
    return h;
}

/* ---------- create empty table ---------- */
HashTable *ht_create(void *(*vc)(const void *), void (*vf)(void *))
{
    HashTable *ht = calloc(1, sizeof *ht);
    ht->value_copy = vc;
    ht->value_free = vf;
    return ht;
}

/* ---------- insert or update ---------- */
void ht_insert(HashTable *ht, const char *key, const void *value)
{
    unsigned idx = hash(key) & (NUM_BUCKETS - 1);
    Node *n;

    /* update existing key */
    for (n = ht->buckets[idx]; n; n = n->next) {
        if (strcmp(n->key, key) == 0) {
            if (ht->value_free) ht->value_free(n->value);
            n->value = ht->value_copy ? ht->value_copy(value) : (void *)value;
            return;
        }
    }

    /* create new node */
    n = malloc(sizeof *n);
    n->key   = strdup(key);
    n->value = ht->value_copy ? ht->value_copy(value) : (void *)value;
    n->next  = ht->buckets[idx];
    ht->buckets[idx] = n;
}

/* ---------- search ---------- */
void *ht_search(HashTable *ht, const char *key)
{
    unsigned idx = hash(key) & (NUM_BUCKETS - 1);
    for (Node *n = ht->buckets[idx]; n; n = n->next)
        if (strcmp(n->key, key) == 0) return n->value;
    return NULL;
}

/* ---------- delete ---------- */
void ht_delete(HashTable *ht, const char *key)
{
    unsigned idx = hash(key) & (NUM_BUCKETS - 1);
    Node **link = &ht->buckets[idx];
    while (*link) {
        Node *n = *link;
        if (strcmp(n->key, key) == 0) {
            *link = n->next;
            free(n->key);
            if (ht->value_free) ht->value_free(n->value);
            free(n);
            return;
        }
        link = &n->next;
    }
}

/* ---------- free everything ---------- */
void ht_destroy(HashTable *ht)
{
    for (int i = 0; i < NUM_BUCKETS; ++i) {
        Node *n = ht->buckets[i];
        while (n) {
            Node *next = n->next;
            free(n->key);
            if (ht->value_free) ht->value_free(n->value);
            free(n);
            n = next;
        }
    }
    free(ht);
}

// 1
void *int_copy(const void *p) { return (void *)p; }

int main(void)
{
    HashTable *ht = ht_create(int_copy, NULL); /* no free needed */

    int k42 = 42, k7 = 7;
    ht_insert(ht, "forty-two", (void *)&k42);
    ht_insert(ht, "seven",     (void *)&k7);

    int v = *(int*)ht_search(ht, "forty-two");
    printf("forty-two = %d\n", v);   /* 42 */

    ht_destroy(ht);
}

// 2
typedef struct {
    double x, y;
} Point;

void *point_copy(const void *src)
{
    Point *p = malloc(sizeof *p);
    *p = *(Point *)src;
    return p;
}
void point_free(void *p) { free(p); }

int main(void)
{
    HashTable *ht = ht_create(point_copy, point_free);

    Point origin = {0.0, 0.0}, unit = {1.0, 1.0};
    ht_insert(ht, "origin", &origin);
    ht_insert(ht, "unit",   &unit);

    Point *u = ht_search(ht, "unit");
    printf("unit  = (%.1f, %.1f)\n", u->x, u->y);

    ht_destroy(ht);
}

// 3
int main(void)
{
    HashTable *ht = ht_create((void *(*)(const void *))strdup, free);

    ht_insert(ht, "apple", "red");
    ht_insert(ht, "banana", "yellow");
    ht_insert(ht, "lemon", "yellow");
    ht_insert(ht, "pear", "green");

    printf("banana â†’ %s\n", (const char *)ht_search(ht, "banana"));
    printf("pear   â†’ %s\n", (const char *)ht_search(ht, "pear"));
    printf("grape  â†’ %s\n", (const char *)ht_search(ht, "grape")); /* not found */

    ht_delete(ht, "banana");
    printf("banana after delete â†’ %s\n", (const char *)ht_search(ht, "banana"));

    ht_destroy(ht);
    return 0;
}

/* -- 3 -- */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Node structure for key-value pairs
typedef struct Node {
    char* key;      // e.g., "Alice"
    int value;      // e.g., 30
    struct Node* next;  // For chaining collisions
} Node;

// HashTable structure
typedef struct HashTable {
    Node** buckets;  // Array of pointers to Node
    int size;        // Number of buckets
} HashTable;

// Simple hash function for strings: sum of ASCII % size
int hash(const char* key, int size) {
    int sum = 0;
    for (int i = 0; key[i] != '\0'; i++) {
        sum += key[i];
    }
    return sum % size;
}

// Create a new node
Node* createNode(const char* key, int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->key = strdup(key);  // Copy string
    newNode->value = value;
    newNode->next = NULL;
    return newNode;
}

// Initialize hash table
HashTable* createHashTable(int size) {
    HashTable* ht = (HashTable*)malloc(sizeof(HashTable));
    ht->size = size;
    ht->buckets = (Node**)calloc(size, sizeof(Node*));  // Initialize to NULL
    return ht;
}

// Insert or update key-value
void insert(HashTable* ht, const char* key, int value) {
    int index = hash(key, ht->size);
    Node* current = ht->buckets[index];

    // Check if key exists (update value)
    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            current->value = value;
            return;
        }
        current = current->next;
    }

    // Key doesn't exist: insert new node at front
    Node* newNode = createNode(key, value);
    newNode->next = ht->buckets[index];
    ht->buckets[index] = newNode;
}

// Search for key and return value (or -1 if not found)
int search(HashTable* ht, const char* key) {
    int index = hash(key, ht->size);
    Node* current = ht->buckets[index];

    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            return current->value;
        }
        current = current->next;
    }
    return -1;  // Not found
}

// Delete key
void delete(HashTable* ht, const char* key) {
    int index = hash(key, ht->size);
    Node* current = ht->buckets[index];
    Node* prev = NULL;

    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            if (prev == NULL) {
                ht->buckets[index] = current->next;
            } else {
                prev->next = current->next;
            }
            free(current->key);  // Free duplicated string
            free(current);
            return;
        }
        prev = current;
        current = current->next;
    }
}

// Print the entire table (for demo)
void printTable(HashTable* ht) {
    for (int i = 0; i < ht->size; i++) {
        printf("Bucket %d: ", i);
        Node* current = ht->buckets[i];
        while (current != NULL) {
            printf("(%s=%d) -> ", current->key, current->value);
            current = current->next;
        }
        printf("NULL\n");
    }
}

// Free the hash table (cleanup)
void freeHashTable(HashTable* ht) {
    for (int i = 0; i < ht->size; i++) {
        Node* current = ht->buckets[i];
        while (current != NULL) {
            Node* temp = current;
            current = current->next;
            free(temp->key);
            free(temp);
        }
    }
    free(ht->buckets);
    free(ht);
}

int main() {
    HashTable* ht = createHashTable(10);

    // Insert some data
    insert(ht, "Alice", 30);
    insert(ht, "Bob", 25);
    insert(ht, "Charlie", 35);  // Might collide with Alice depending on hash
    insert(ht, "David", 28);

    // Print table
    printf("Hash Table Contents:\n");
    printTable(ht);

    // Search example
    int age = search(ht, "Bob");
    printf("\nBob's age: %d\n", age);

    // Delete example
    delete(ht, "Alice");
    printf("\nAfter deleting Alice:\n");
    printTable(ht);

    // Cleanup
    freeHashTable(ht);
    return 0;
}
```

```lua
-- 1
-- Simple hash function for ints: key % size (handle negative)
local function hash(key, size)
    return ((key % size) + size) % size
end

-- Create a new node table
local function createNode(key, value)
    return {key = key, value = value, next = nil}
end

-- Initialize hash table
local function createHashTable(size)
    local ht = {size = size, buckets = {}}
    for i = 1, size do
        ht.buckets[i] = nil  -- Empty buckets
    end
    return ht
end

-- Insert or update key-value
local function insert(ht, key, value)
    local index = hash(key, ht.size)
    local current = ht.buckets[index]

    -- Check if key exists (update value)
    while current ~= nil do
        if current.key == key then
            current.value = value
            return
        end
        current = current.next
    end

    -- Key doesn't exist: insert new node at front
    local newNode = createNode(key, value)
    newNode.next = ht.buckets[index]
    ht.buckets[index] = newNode
end

-- Search for key and return value (or -1 if not found)
local function search(ht, key)
    local index = hash(key, ht.size)
    local current = ht.buckets[index]

    while current ~= nil do
        if current.key == key then
            return current.value
        end
        current = current.next
    end
    return -1  -- Not found
end

-- Delete key
local function delete(ht, key)
    local index = hash(key, ht.size)
    local current = ht.buckets[index]
    local prev = nil

    while current ~= nil do
        if current.key == key then
            if prev == nil then
                ht.buckets[index] = current.next
            else
                prev.next = current.next
            end
            -- No explicit free; Lua GC handles it
            return
        end
        prev = current
        current = current.next
    end
end

-- Print the entire table (for demo)
local function printTable(ht)
    for i = 1, ht.size do
        io.write("Bucket " .. (i - 1) .. ": ")
        local current = ht.buckets[i]
        while current ~= nil do
            io.write("(" .. current.key .. "=" .. current.value .. ") -> ")
            current = current.next
        end
        print("nil")
    end
end

-- Main demo
local ht = createHashTable(10)

-- Insert some data (int keys: e.g., employee IDs)
insert(ht, 123, 30)   -- ID 123, age 30 (123 % 10 = 3)
insert(ht, 133, 25)   -- ID 133 hashes to 3
insert(ht, 143, 35)   -- ID 143 hashes to 3 (collision with 133!)
insert(ht, 100, 28)   -- ID 100 hashes to 0

-- Print table
print("Hash Table Contents:")
printTable(ht)

-- Search example
local age = search(ht, 133)
print("\nID 133's age: " .. age)

-- Delete example
delete(ht, 123)
print("\nAfter deleting ID 123:")
printTable(ht)

-- OOP style
-- HashTable prototype (methods)
local HashTable = {}
HashTable.__index = HashTable

-- Simple hash function for ints: key % size (handle negative)
local function hash(key, size)
    return ((key % size) + size) % size
end

-- Constructor: Create a new HashTable instance
function HashTable.new(size)
    local self = {
        size = size,
        buckets = {}
    }
    -- Initialize empty buckets
    for i = 1, size do
        self.buckets[i] = nil
    end
    -- Set metatable for method access
    setmetatable(self, HashTable)
    return self
end

-- Create a new node table
local function createNode(key, value)
    return {key = key, value = value, next = nil}
end

-- Insert or update key-value
function HashTable:insert(key, value)
    local index = hash(key, self.size)
    local current = self.buckets[index]

    -- Check if key exists (update value)
    while current ~= nil do
        if current.key == key then
            current.value = value
            return
        end
        current = current.next
    end

    -- Key doesn't exist: insert new node at front
    local newNode = createNode(key, value)
    newNode.next = self.buckets[index]
    self.buckets[index] = newNode
end

-- Search for key and return value (or -1 if not found)
function HashTable:search(key)
    local index = hash(key, self.size)
    local current = self.buckets[index]

    while current ~= nil do
        if current.key == key then
            return current.value
        end
        current = current.next
    end
    return -1  -- Not found
end

-- Delete key
function HashTable:delete(key)
    local index = hash(key, self.size)
    local current = self.buckets[index]
    local prev = nil

    while current ~= nil do
        if current.key == key then
            if prev == nil then
                self.buckets[index] = current.next
            else
                prev.next = current.next
            end
            -- No explicit free; Lua GC handles it
            return
        end
        prev = current
        current = current.next
    end
end

-- Print the entire table (for demo)
function HashTable:printTable()
    for i = 1, self.size do
        io.write("Bucket " .. (i - 1) .. ": ")
        local current = self.buckets[i]
        while current ~= nil do
            io.write("(" .. current.key .. "=" .. current.value .. ") -> ")
            current = current.next
        end
        print("nil")
    end
end

-- Main demo
local ht = HashTable.new(10)

-- Insert some data (int keys: e.g., employee IDs)
ht:insert(123, 30)   -- ID 123, age 30 (123 % 10 = 3)
ht:insert(133, 25)   -- ID 133 hashes to 3
ht:insert(143, 35)   -- ID 143 hashes to 3 (collision with 133!)
ht:insert(100, 28)   -- ID 100 hashes to 0

-- Print table
print("Hash Table Contents:")
ht:printTable()

-- Search example
local age = ht:search(133)
print("\nID 133's age: " .. age)

-- Delete example
ht:delete(123)
print("\nAfter deleting ID 123:")
ht:printTable()
```

## ring buffer
[Ring-Buffer](https://github.com/AndersKaloer/Ring-Buffer/tree/master)  
[c-ringbuf](https://github.com/dhess/c-ringbuf/tree/master)  
[]()  
[]()  
[]()  
[]()  
```c
# 1
#include <stdio.h>

#define BUFFER_SIZE 5

typedef struct {
    int data[BUFFER_SIZE];
    int count; // Number of elements in the buffer (0 to BUFFER_SIZE)
    int tail;  // Index where the next element will be inserted
} RingBuffer;

// Add a new integer to the ring buffer
void add(RingBuffer *buf, int value) {
    buf->data[buf->tail] = value;
    buf->tail = (buf->tail + 1) % BUFFER_SIZE;

    if (buf->count < BUFFER_SIZE) {
        buf->count++;
    }
}

// Print the buffer contents from oldest to newest
void print_buffer(const RingBuffer *buf) {
    int start = (buf->tail - buf->count + BUFFER_SIZE) % BUFFER_SIZE;
    for (int i = 0; i < buf->count; i++) {
        int idx = (start + i) % BUFFER_SIZE;
        printf("%d ", buf->data[idx]);
    }
    printf("\n");
}

// Main: test the ring buffer
int main() {
    RingBuffer buf = { .count = 0, .tail = 0 };

    for (int i = 1; i <= 8; ++i) {
        add(&buf, i);
        printf("After adding %d: ", i);
        print_buffer(&buf);
    }

    return 0;
}

# 2
#include <stdio.h>

#define BUFFER_SIZE 5

typedef struct {
    int data[BUFFER_SIZE];
    int count; // Number of elements in the buffer (0 to BUFFER_SIZE)
    int head;  // Index of the oldest element
} RingBuffer;

// Add a new integer to the ring buffer
void add(RingBuffer *buf, int value) {
    int insert_index = (buf->head + buf->count) % BUFFER_SIZE;

    buf->data[insert_index] = value;

    if (buf->count < BUFFER_SIZE) {
        buf->count++;
    } else {
        // Buffer full, move head to next oldest
        buf->head = (buf->head + 1) % BUFFER_SIZE;
    }
}

// Print the buffer contents from oldest to newest
void print_buffer(const RingBuffer *buf) {
    for (int i = 0; i < buf->count; i++) {
        int idx = (buf->head + i) % BUFFER_SIZE;
        printf("%d ", buf->data[idx]);
    }
    printf("\n");
}

// Main: test the ring buffer
int main() {
    RingBuffer buf = { .count = 0, .head = 0 };

    for (int i = 1; i <= 8; ++i) {
        add(&buf, i);
        printf("After adding %d: ", i);
        print_buffer(&buf);
    }

    return 0;
}

# 3
#include<stdio.h>
#include<malloc.h>
#include<memory.h>
#include<unistd.h>
#include<stdlib.h>

typedef struct cbuff_{
    int * buff;
    int start;
    int end;
    int size;
    int count;
} cbuff_t;

cbuff_t* cbuff_new(int size)
{
  cbuff_t *cb = (cbuff_t*)malloc(sizeof(cbuff_t));
  memset(cb, 0, sizeof(cbuff_t));
  cb->size = size;
    cb->buff = (int*)malloc(sizeof(int)*size);
  
  return cb;
}

void cbuff_add(cbuff_t *cb, int elem)
{
  int end = cb->end;
  if(cb->count && (end % cb->size) == cb->start) {
    printf("Overflow Elem[%d] %d lost\n", cb->start, cb->buff[cb->start]);
    cb->start = (cb->start + 1 ) %cb->size;
    cb->count --;
  }

  printf("Added Elem[%d] = %d\n",cb->end, elem);
  cb->buff[cb->end] = elem;
  cb->end = (cb->end+1) % cb->size;
  cb->count ++;
}

int cbuff_remove(cbuff_t *cb)
{
  int start = cb->start ;
  int ret = -1;
  if(cb->count <= 0) {
    printf("Buffer is empty\n");
    return ret;
  }

  if(cb->count || (start % cb->size) != cb->end) {
    printf("Removed Elem[%d] = %d\n",cb->start, cb->buff[cb->start]);
    ret = cb->buff[cb->start];
    cb->start = (cb->start + 1 ) % cb->size;
    cb->count--;
  } else {
    printf("Buffer is empty\n");
  }

  return ret;
}

void cbuff_print(cbuff_t *cb)
{
  int start = cb->start ;
  int end = cb->end ;
  int i, count = 0;
  for(i = start; count < cb->count; i = (i + 1) % cb->size) {
    printf("Elem[%d] = %d\n", i, cb->buff[i]);
    count++;
    if(i == (end - 1)) {
      break;
    }
  }
}

void cbuff_delete(cbuff_t *cb)
{
  free(cb->buff);
  free(cb);
}

int main(int argc, char *argv[])
{
  char key;
  int elem;
  cbuff_t *cb = cbuff_new(5);

  while(1) {
    printf("circular buffer add[a], remove[r], print[p] : ");
    fflush(stdin);

    key = getchar();
    switch(key) {
    case 'a':
      printf("Element to add : ");
      scanf("%d", &elem);
      cbuff_add(cb, elem);
      break;
    case 'r':
      cbuff_remove(cb);
      break;
    case 'p':
      cbuff_print(cb);
      break;
    case 'q':
      cbuff_delete(cb);
      exit(0);
    }

    continue;
  }

  return 0;
}

# 4
#include <stdio.h>
#include <string.h>

#define BUFFER_SIZE 5

typedef struct RingBuffer	RingBuffer;
struct RingBuffer
{
	int	count;	/* occupied size of data[]*/
	int	tail;	  /* index of last entry inserted + 1 */
	int data[BUFFER_SIZE];
};

void ringbuffer_add(RingBuffer *rb, int value)
{
    rb->data[rb->tail] = value;
    rb->tail = (rb->tail + 1) % BUFFER_SIZE;
    if (rb->count < BUFFER_SIZE) {
        rb->count++;
    }
}

void ringbuffer_print(RingBuffer *rb)
{
    if(rb->count == 0) {
        printf("RingBuffer is empty.\n");
        return;
    }
  
  int start = (rb->tail - rb->count + BUFFER_SIZE) % BUFFER_SIZE;
    for(int i = 0; i < rb->count; i++) {
        int idx = (start + i) % BUFFER_SIZE;
        printf("%d ", rb->data[idx]);
    }

    printf("\n");
}

int main(void)
{
    int i;
    RingBuffer rb;

    memset(&rb, 0, sizeof(rb));
    ringbuffer_print(&rb);

    for (i = 0; i < 10; i++) {
        ringbuffer_add(&rb, i);
        ringbuffer_print(&rb);
    }

    return 0;
}
```

## C library
[ctl](https://github.com/glouw/ctl)  
> C TEMPLATE LIBRARY (CTL) is a fast compiling, type safe, header only, template-like library for ISO C99/C11.
[C CONTAINER TEMPLATE LIBRARY (CTL)](https://rurban.github.io/ctl/)  
[]()  
[]()  
[]()  
[]()  

## pthread
[Multithreaded Programming (POSIX pthreads Tutorial)](https://randu.org/tutorials/threads/)  
[POSIX Threads API](https://www.cs.fsu.edu/~baker/opsys/notes/pthreads.html)  
[POSIX Threads API](https://www.cs.fsu.edu/~baker/realtime/restricted/notes/pthreads.html)  
[POSIX thread (pthread) libraries](https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html)  
[Pthreads Tutorial](https://www.eecs.umich.edu/courses/eecs570/discussions/w22/pthreads.html)  
[Parallel Programming with the PThread API](https://www.cs.emory.edu/~cheung/Courses/561/Syllabus/91-pthreads/create-threads.html)  
[Multithreaded Programming Guide](https://docs.oracle.com/cd/E19120-01/open.solaris/816-5137/index.html)  
[Multithreading for Beginners: Step-by-Step](https://hackernoon.com/multithreading-for-beginners-step-by-step)  
[Learning About Threads: An Essential Guide for Developers](https://hackernoon.com/learning-about-threads-an-essential-guide-for-developers)  
[What Every Gopher Should Know About the Go Memory Model](https://hackernoon.com/what-every-gopher-should-know-about-the-go-memory-model)  
[Threading Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html)  
[MasteringPthreads](https://github.com/ANSANJAY/MasteringPthreads)  
[]()  
[]()  
[]()  


## åŠ¨æ€é“¾æ¥ å’Œ é™æ€é“¾æ¥
[**Program Library HOWTO**](https://tldp.org/HOWTO/Program-Library-HOWTO/index.html)  
[C++ dlopen mini HOWTO](https://tldp.org/HOWTO/C++-dlopen/)  
[Shared libraries with GCC on Linux](https://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html)  
[]()  
[]()  
[How dynamic linking for modular libraries works on Linux](https://opensource.com/article/22/5/dynamic-linking-modular-libraries-linux)  
[How to handle dynamic and static libraries in Linux](https://opensource.com/article/20/6/linux-libraries)  
```c
When we link an application against a shared library, the linker leaves some stubs (unresolved symbols) which need to be filled by dynamic linker at run time or at application loading time.

Loading of a shared library is of two types::
1. Dynamically linked libraries
2. Dynamically loaded libraries

// Dynamically linked libraries
gcc -c -Wall -Werror -fpic foo.c		// Compiling with Position Independent Code
gcc -shared -o libfoo.so foo.o			// Creating a shared library from an object file
gcc -L/home/username/foo -Wall -o test main.c -lfoo				// Linking with a shared library

// 1 use LD_LIBRARY_PATH
export LD_LIBRARY_PATH=/home/username/foo:$LD_LIBRARY_PATH		// Making the library available at runtime
./test

// 2 use rpath
unset LD_LIBRARY_PATH
gcc -L/home/username/foo -Wl,-rpath=/home/username/foo -Wall -o test main.c -lfoo
./test

//  Dynamically loaded libraries
Useful for creating a "plug-in" architecture. 
The program takes full control by calling functions with the library. This is done using dlopen(), dlsym(), dlclose().


// åŠ¨æ€é“¾æ¥
// Locating a shared object during compilation
gcc -I ./include -c src/demo.c				// -I option: adds a directory to GCC's search path for header files

gcc -L`pwd`/lib -o myDemo demo.o -lexample	// -L option: adds an additional library path to GCC's search locations. 
											// -l: sets the name of the library you want to link against

ldd ./myDemo								// ldd: prints shared object dependencies
        linux-vdso.so.1 (0x00007ffe151df000)
        libexample.so => not found
        libc.so.6 => /lib64/libc.so.6 (0x00007f514b60a000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f514b839000)

LD_LIBRARY_PATH=`pwd`/lib ldd ./			// LD_LIBRARY_PATH: the environment variable which defines the path to libraries
   linux-vdso.so.1 (0x00007ffe515bb000)
   libexample.so => /tmp/Demo/lib/libexample.so (0x0000...
   libc.so.6 => /lib64/libc.so.6 (0x00007eff037ee000)
   /lib64/ld-linux-x86-64.so.2 (0x00007eff03a22000)

LD_LIBRARY_PATH=`pwd`/lib ./myDemo			// 

// When to use LD_LIBRARY_PATH
/*
	1. compiling software that needs to link against a library that itself has just been compiled and has not yet been installed
	2. bundling software that's designed to run out of a single directory, with no install script or an install script that places libraries in non-standard directories
*/

// é™æ€é“¾æ¥
A static library is an archive (ar) of object files

file libmy_static.a		// libmy_static.a: current ar archive

ar -t libmy_static.a 	// look into the archive

ar -x libmy_static.a	// extract the archive's files
```

## libraries
### ini parser
[iniparser](https://github.com/ndevilla/iniparser/tree/main)  
[inih](https://github.com/benhoyt/inih)  
[Notcurses: blingful TUIs and character graphics](https://github.com/dankamongmen/notcurses)  

## å‡½æ•°æŒ‡é’ˆçš„åº”ç”¨åœºæ™¯
```c
// 1 å›è°ƒæœºåˆ¶
#include <stdio.h>

typedef struct Button {
    void (*onClick)();  // å›è°ƒå‡½æ•°æŒ‡é’ˆ
} Button;

void buttonClicked() {
    printf("Button was clicked!\n");
}

int main() {
    Button btn;
    btn.onClick = buttonClicked;  // æ³¨å†Œå›è°ƒå‡½æ•°
    if (btn.onClick) {
        btn.onClick();  // è°ƒç”¨å›è°ƒå‡½æ•°
    }
    return 0;
}

// callback function
int compare(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

qsort(array, size, sizeof(int), compare);


// 2 ç­–ç•¥æ¨¡å¼
#include <stdio.h>

typedef struct Sorter {
    int (*compare)(int, int);  // å‡½æ•°æŒ‡é’ˆå®šä¹‰äº†æ¯”è¾ƒç­–ç•¥
} Sorter;

int ascending(int a, int b) {	// æ¯”è¾ƒç­–ç•¥ 1
    return a - b;
}

int descending(int a, int b) {	// æ¯”è¾ƒç­–ç•¥ 2
    return b - a;
}

void sort(int arr[], int n, Sorter sorter) {	// åŠ¨æ€æŒ‡å®šæ¯”è¾ƒç­–ç•¥
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (sorter.compare(arr[j], arr[j + 1]) > 0) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() {
    int arr[] = {5, 3, 7, 2, 8};
    Sorter ascSorter = {ascending};
    Sorter descSorter = {descending};
    
    sort(arr, 5, ascSorter);	// åŠ¨æ€æŒ‡å®šæ¯”è¾ƒç­–ç•¥ 1
    printf("Ascending: ");
    for (int i = 0; i < 5; i++) printf("%d ", arr[i]);
    printf("\n");
    
    sort(arr, 5, descSorter);	// åŠ¨æ€æŒ‡å®šæ¯”è¾ƒç­–ç•¥ 2
    printf("Descending: ");
    for (int i = 0; i < 5; i++) printf("%d ", arr[i]);
    printf("\n");
    
    return 0;
}

// 3 æ’ä»¶ç³»ç»Ÿ
#include <stdio.h>

typedef struct Filter {
    void (*apply)(int*, int);  // å‡½æ•°æŒ‡é’ˆæŒ‡å‘å…·ä½“çš„å¤„ç†å‡½æ•°
} Filter;

void grayscale(int* pixels, int size) {
    printf("Applying grayscale filter\n");
}

void sepia(int* pixels, int size) {
    printf("Applying sepia filter\n");
}

int main() {
    int pixels[100];
    Filter filters[] = {	// æ•°ç»„å­˜å‚¨å¤šä¸ªFilterå¯¹è±¡ï¼Œæ¯ä¸ªå¯¹è±¡å…³è”ä¸€ä¸ªFilterå‡½æ•°
        {grayscale},
        {sepia}
    };
    
    for (int i = 0; i < 2; i++) {		// éå†æ•°ç»„å¹¶è°ƒç”¨applyï¼Œå®ç°æ’ä»¶å¼çš„Filteråº”ç”¨
        filters[i].apply(pixels, 100);
    }
    return 0;
}

// 4 çŠ¶æ€æœº
#include <stdio.h>

typedef struct State {
    void (*handleInput)(char);  // å‡½æ•°æŒ‡é’ˆå¤„ç†ç‰¹å®šçŠ¶æ€ä¸‹çš„è¾“å…¥
} State;

void handleListen(char input) {
    if (input == 'S') printf("Received SYN, moving to SYN_RECEIVED\n");
}

void handleSynReceived(char input) {
    if (input == 'A') printf("Received ACK, moving to ESTABLISHED\n");
}

int main() {
    State states[] = {		  // æ¯ä¸ªStateï¼ˆå¦‚LISTENå’ŒSYN_RECEIVEDï¼‰æœ‰ç‹¬ç«‹çš„å¤„ç†é€»è¾‘
        {handleListen},
        {handleSynReceived}
    };
    
    states[0].handleInput('S');  // çŠ¶æ€æœºåœ¨ä¸åŒçŠ¶æ€é—´çš„è½¬æ¢
    states[1].handleInput('A');  // çŠ¶æ€æœºåœ¨ä¸åŒçŠ¶æ€é—´çš„è½¬æ¢
    return 0;
}

//
#include <stdio.h>

typedef enum {
    STATE_RED,
    STATE_GREEN,
    STATE_YELLOW,
    STATE_COUNT
} TrafficLightState;

typedef TrafficLightState (*StateFunction)();

TrafficLightState red_state() {
    printf("State: RED\n");
    return STATE_GREEN;
}

TrafficLightState green_state() {
    printf("State: GREEN\n");
    return STATE_YELLOW;
}

TrafficLightState yellow_state() {
    printf("State: YELLOW\n");
    return STATE_RED;
}

int main() {
    StateFunction state_table[STATE_COUNT] = {
        red_state,
        green_state,
        yellow_state
    };

    TrafficLightState current_state = STATE_RED;

    for (int i = 0; i < 10; ++i) {
        current_state = state_table[current_state]();
    }

    return 0;
}


// 5 å¯¹è±¡æ¨¡æ‹Ÿ
#include <stdio.h>

typedef struct Animal {
    void (*speak)();  // å‡½æ•°æŒ‡é’ˆæ¨¡æ‹Ÿç±»çš„â€œæ–¹æ³•â€
} Animal;

void dogSpeak() {		// ä¸åŒçš„å‡½æ•°æŒ‡é’ˆå®ç°å„è‡ªçš„è¡Œä¸º
    printf("Woof!\n");
}

void catSpeak() {		// ä¸åŒçš„å‡½æ•°æŒ‡é’ˆå®ç°å„è‡ªçš„è¡Œä¸º
    printf("Meow!\n");
}

int main() {
    Animal dog = {dogSpeak};
    Animal cat = {catSpeak};
    
    dog.speak();
    cat.speak();
    return 0;
}

// 6 äº‹ä»¶åˆ†å‘
#include <stdio.h>

typedef struct EventHandler {
    void (*handle)(int eventType);  // å‡½æ•°æŒ‡é’ˆç”¨äºäº‹ä»¶å¤„ç†
} EventHandler;

void handleEvent(int eventType) {	// æ ¹æ®eventTypeæ‰§è¡Œä¸åŒé€»è¾‘
    if (eventType == 1) {
        printf("Handling event type 1\n");
    } else if (eventType == 2) {
        printf("Handling event type 2\n");
    }
}

int main() {
    EventHandler handler = {handleEvent};
    
    handler.handle(1);	// åˆ†å‘äº‹ä»¶ï¼Œå®ç°é›†ä¸­å¼äº‹ä»¶å¤„ç†
    handler.handle(2);	// åˆ†å‘äº‹ä»¶ï¼Œå®ç°é›†ä¸­å¼äº‹ä»¶å¤„ç†
    return 0;
}

// 7 çº¿ç¨‹æ± 
#include <stdio.h>

typedef struct Task {			// ç»“æ„ä½“åŒ…å«executeå‡½æ•°æŒ‡é’ˆå’Œå‚æ•°arg
    void (*execute)(void* arg);
    void* arg;
} Task;

void printNumber(void* arg) {	// ä»»åŠ¡å‡½æ•°ï¼Œæ¥æ”¶å‚æ•°å¹¶æ‰§è¡Œ
    int num = *(int*)arg;
    printf("Number: %d\n", num);
}

int main() {
    int num = 42;
    Task task = {printNumber, &num};
    
    task.execute(task.arg);  // æ‰§è¡Œçº¿ç¨‹æ± ä¸­çš„ä»»åŠ¡
    return 0;
}

// 8 è™šæ‹Ÿå‡½æ•°è¡¨
#include <stdio.h>

typedef struct VTable {		// è™šå‡½æ•°è¡¨å®šä¹‰(åŒ…å«å‡½æ•°æŒ‡é’ˆ)
    void (*speak)();
} VTable;

typedef struct Animal {		// ç»“æ„ä½“é€šè¿‡å‡½æ•°è¡¨æŒ‡é’ˆå…³è”å…·ä½“çš„å®ç°
    VTable* vtable;
} Animal;

void dogSpeak() {
    printf("Woof!\n");
}

void catSpeak() {
    printf("Meow!\n");
}

VTable dogVTable = {dogSpeak};
VTable catVTable = {catSpeak};

int main() {
    Animal dog = {&dogVTable};	// é€šè¿‡ä¸åŒçš„è™šå‡½æ•°è¡¨å®ç°å¤šæ€è°ƒç”¨
    Animal cat = {&catVTable};	// é€šè¿‡ä¸åŒçš„è™šå‡½æ•°è¡¨å®ç°å¤šæ€è°ƒç”¨
    
    dog.vtable->speak();
    cat.vtable->speak();
    return 0;
}

// 9 é’©å­å‡½æ•°
#include <stdio.h>

typedef struct Monitor {				// ç»“æ„ä½“ä¸­çš„å‡½æ•°æŒ‡é’ˆæ³¨å†Œé’©å­å‡½æ•°
    void (*onChange)(const char* file);
} Monitor;

void logChange(const char* file) {		// é’©å­å‡½æ•°å®ç°
    printf("File changed: %s\n", file);
}

int main() {
    Monitor monitor = {logChange};
    
    if (monitor.onChange) {
        monitor.onChange("example.txt");  // è§¦å‘é’©å­å‡½æ•°é€»è¾‘
    }
    return 0;
}

// 10 ä»åŠ¨æ€åº“åŠ è½½å‡½æ•°
#include <stdio.h>
#include <dlfcn.h>

typedef struct Plugin {
    void (*init)();
    void (*cleanup)();
} Plugin;

int main() {
    void* handle = dlopen("./libplugin.so", RTLD_LAZY);
    if (!handle) {
        fprintf(stderr, "%s\n", dlerror());
        return 1;
    }
    
    Plugin plugin;
    plugin.init = dlsym(handle, "plugin_init");			// dlsymè·å–å‡½æ•°åœ°å€
    plugin.cleanup = dlsym(handle, "plugin_cleanup");	// dlsymè·å–å‡½æ•°åœ°å€
    
    if (plugin.init)
		plugin.init();

    if (plugin.cleanup)
		plugin.cleanup();
    
    dlclose(handle);
    return 0;
}

// jump tables
void add() { printf("Add\n"); }
void subtract() { printf("Subtract\n"); }

void (*operation_table[2])() = { add, subtract };
operation_table[op_index]();  // Dynamically invoke the correct operation

// Plugin-like Architecture / Dynamic Behavior
typedef struct {
    void (*init)();
    void (*process)();
} Module;

void mod1_init() { printf("Mod1 Init\n"); }
void mod1_process() { printf("Mod1 Process\n"); }

Module mod1 = { mod1_init, mod1_process };
mod1.init();
mod1.process();

// Encapsulating Behavior in Data Structures
typedef struct {
    void (*draw)(void*);
} Shape;

void draw_circle(void* s) { printf("Drawing Circle\n"); }

Shape circle = { draw_circle };
circle.draw(&circle);

```

## å¸¸ç”¨å‡½æ•°
```c
ioctl, fcntl
mmap, munmap
fopen, fread, fwrite, fclose, ferror
popen, pclose, fdopen
open, read, write, close
fprintf,  sprintf, snprintf
fscanf, scanf
strchr, strrchr, strstr, strtok, strtok_r
strdup
strlen
access
strncmp, strcasecmp
fgets
system
isalpha, isxdigit
atoi, strtoul, strtol
toupper, tolower
malloc, free
getenv
regcomp, regexec, regfree
fork, execve
waitpid
raise
memset, memmove, memcpy
kill
reboot
select, poll, epoll
socket, getsockopt, setsockopt
pthread_mutex_init, pthread_mutex_destroy
pthread_mutex_lockï¼Œ pthread_mutex_unlock
pthread_mutexattr_init, pthread_mutexattr_setpshared
shm_open, shm_unlink
truncate, ftruncate
pthread_self, pthread_setaffinity_np, pthread_getaffinity_np
strerror

void *memcpy(void *dest, const void *src, size_t n);
The memcpy() function copies n bytes from memory area src to memory area dest. The memory areas must not overlap.  Use memmove(3) if the memory areas do overlap.

void *memmove(void *dest, const void *src, size_t n);
The  memmove()  function  copies n bytes from memory area src to memory area dest. The memory areas may overlap: copying takes place as though the bytes in src are first copied into a temporary array that does not overlap src or dest, and the bytes are then copied from the temporary array to dest.

int poll(struct pollfd *fds, nfds_t nfds, int timeout);
	struct pollfd {
		int   fd;         /* file descriptor */
		short events;     /* requested events */
		short revents;    /* returned events */
	};
The caller should specify the number of items in the fds array in nfds.
The field fd contains a file descriptor for an open file.
The field events is an input parameter, a bit mask specifying the events the application is interested in for the file descriptor fd.
The field revents is an output parameter, filled by the kernel with the events that actually occurred. 

// strerror
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main(void)
{
		FILE *fp;
		char filename[128];

		snprintf(filename, sizeof(filename), "test.txt");
		fp = fopen(filename, "r");
		if(fp == NULL) {
						printf("fopen %s failed: %s\n", filename, strerror(errno));
						//printf("fopen %s failed: %m\n", filename);
		}

		return 0;
}

// waitpid
// return immediately if no child has exited
pid = waitpid(0, &status, WNOHANG);
if(pid <= 0)
	return;

// raise (å‘é€ä¿¡å·ç»™å½“å‰è¿›ç¨‹è‡ªå·±)
#include <signal.h>

void sig_handler(int signo, siginfo_t *info, void *ucontext)
{
	struct sigaction act;

	memset(&act, 0, sizeof(act));
	// inside first-level signal handler, set signal handler to default action
	act.sa_handler = SIG_DFL;

	sigaction(signo, &act, NULL);

	/* Take appropriate actions according to needs */
	......

	// send a signal to the caller, åœ¨æœ¬ä¾‹ä¸­ä¼šè§¦å‘ç³»ç»Ÿçš„é»˜è®¤çš„ä¿¡å·å¤„ç†
	raise(signo);
}

int set_sighandler()
{
	int r;
	struct sigaction sa;

	memset(&sa, 0, sizeof(sa));
	sa.sa_sigaction = sig_handler;
	sa.sa_flags = SA_SIGINFO;

	// assume signo is SIGUSR1
	r = sigaction(SIGUSR1, &sa, NULL);
	if(r < 0) {
		printf("sigaction failed: %s", strerror(errno));
		return -1;
	}
	/* Further code */

		return 0;
}

// statvfs (è·å–æ–‡ä»¶ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯)
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sys/statvfs.h>

#define SWM_TMP_SPACE 200

int
chk_tmp_space(void)
{
	int r;
	int free;
	struct statvfs vfs;

	memset(&vfs, 0, sizeof(vfs));
	r = statvfs("/", &vfs);
	if(r) {
		printf("statvfs failed: %s", strerror(errno));
		return -1;
	}

	free = (vfs.f_bsize * vfs.f_bfree) / (1024 * 1024);

	printf("tmp space required %dMB free %dMB\n",SWM_TMP_SPACE, free);

	if(free < SWM_TMP_SPACE) {
		printf("Not enough space, required %dMB, available %dMB\n", SWM_TMP_SPACE, free);
		return -1;
	}

	return 0;
}

// popen è§£æshellå‘½ä»¤æ‰§è¡Œç»“æœï¼Œå¹¶åœ¨ç¨‹åºä¸­è¿›è¡Œä½¿ç”¨
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

enum {
	/* lacp churn machine states */
	CHURN_MONITOR	= 0,	/* monitoring for churn */
	CHURNED		= 1,	/* churn detected (error) */
	NO_CHURN	= 2,	/* no churn (no error) */

	BLK_AGGR	= 0,	/* parsing aggregator info */
	BLK_S1		= 1,	/* parsing slave 1 (fm1-mac1.p1) info */
	BLK_S1_ACTOR	= 2,	/* parsing slave 1 actor lacp pdu */
	BLK_S1_PARTNER	= 3,	/* parsing slave 1 partner lacp pdu */
	BLK_S2		= 4,	/* parsing slave 2 (fm1-mac1.p1) info */
	BLK_S2_ACTOR	= 5,	/* parsing slave 2 actor lacp pdu */
	BLK_S2_PARTNER	= 6,	/* parsing slave 2 partner lacp pdu */
	};

typedef struct slave_status_t slave_status_t;
struct slave_status_t
{
	int	actor_system_prio;
	int	actor_port_key;
	int	actor_port_prio;
	int	actor_port_number;
	int	actor_port_state;
	int	actor_churn_state;
	int	actor_churn_count;
	int	partner_system_prio;
	int	partner_oper_key;
	int	partner_port_prio;
	int	partner_port_number;
	int	partner_port_state;
	int	partner_churn_state;
	int	partner_churn_count;
};

void print_slave_status(slave_status_t *slave)
{
	printf("actor_system_prio:%d\n", slave->actor_system_prio);
	printf("actor_port_key:%d\n", slave->actor_port_key);
	printf("actor_port_prio:%d\n", slave->actor_port_prio);
	printf("actor_port_number:%d\n", slave->actor_port_number);
	printf("actor_port_state:%d\n", slave->actor_port_state);
	printf("actor_churn_state:%d\n", slave->actor_churn_state);
	printf("actor_churn_count:%d\n", slave->actor_churn_count);
	printf("partner_system_prio:%d\n", slave->partner_system_prio);
	printf("partner_oper_key:%d\n", slave->partner_oper_key);
	printf("partner_port_prio:%d\n", slave->partner_port_prio);
	printf("partner_port_number:%d\n", slave->partner_port_number);
	printf("partner_port_state:%d\n", slave->partner_port_state);
	printf("partner_churn_state:%d\n", slave->partner_churn_state);
	printf("partner_churn_count:%d\n", slave->partner_churn_count);
}

int main(void)
{
	FILE *fp;
	int blk, val;
	const char delim[] = ":";
	slave_status_t	slaves[2], *s1, *s2;
	char cmd[128], line[256], *fstr, *vstr;

	s1 = &slaves[0];
	s2 = &slaves[1];

	snprintf(cmd, sizeof(cmd), "cat bond0.txt");

	fp = popen(cmd, "r");
	if(fp == NULL) {
		printf("popen failed: %s\n", strerror(errno));
		return -1;
	}

	blk = BLK_AGGR;
	while(fgets(line, sizeof(line), fp) != NULL) {
		if(strstr(line, delim) == NULL)
			continue;
		
		fstr = strtok(line, delim);
		vstr = strtok(NULL, "");

		if((fstr == NULL) ||
			((vstr == NULL) &&
			(strcasestr(fstr, "details actor lacp pdu") == NULL) &&
			(strcasestr(fstr, "details partner lacp pdu") == NULL)))
			continue;
		
		if(strcasestr(fstr, "Slave Interface") &&
			strcasestr(vstr, "fm1-mac1.p1")) {
				blk = BLK_S1;
			}
		else if(strcasestr(fstr, "Slave Interface") &&
			strcasestr(vstr, "fm1-mac1.p2")) {
			blk = BLK_S2;
		}
		else if(strcasestr(fstr, "details actor lacp pdu")) {
			if(blk == BLK_S1)
				blk = BLK_S1_ACTOR;
			else if(blk == BLK_S2)
				blk = BLK_S2_ACTOR;
		}
		else if(strcasestr(fstr, "details partner lacp pdu")) {
			if(blk == BLK_S1_ACTOR)
				blk = BLK_S1_PARTNER;
			else if(blk == BLK_S2_ACTOR)
				blk = BLK_S2_PARTNER;
		}
		else if(strcasestr(fstr, "Actor Churn State")) {
			if(strcasestr(vstr, "monitoring"))
				val = CHURN_MONITOR;
			else if(strcasestr(vstr, "churned"))
				val = CHURNED;
			else
				val = NO_CHURN;

			if(blk == BLK_S1)
				s1->actor_churn_state = val;
			else if(blk == BLK_S2)
				s2->actor_churn_state = val;
		}
		else if(strcasestr(fstr, "Partner Churn State")) {
			if(strcasestr(vstr, "monitoring"))
				val = CHURN_MONITOR;
			else if(strcasestr(vstr, "churned"))
				val = CHURNED;
			else
				val = NO_CHURN;

			if(blk == BLK_S1)
				s1->partner_churn_state = val;
			else if(blk == BLK_S2)
				s2->partner_churn_state = val;
		}
		else if(strcasestr(fstr, "Actor Churned Count")) {
			if(blk == BLK_S1)
				s1->actor_churn_count = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2)
				s2->actor_churn_count = strtoul(vstr, NULL, 0);
		}
		else if(strcasestr(fstr, "Partner Churned Count")) {
			if(blk == BLK_S1)
				s1->partner_churn_count = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2)
				s2->partner_churn_count = strtoul(vstr, NULL, 0);
		}
		else if(strcasestr(fstr, "system priority")) {
			if(blk == BLK_S1_ACTOR)
				s1->actor_system_prio = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S1_PARTNER)
				s1->partner_system_prio = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2_ACTOR)
				s2->actor_system_prio = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2_PARTNER)
				s2->partner_system_prio = strtoul(vstr, NULL, 0);
		}
		else if(strcasestr(fstr, "port key")) {
			if(blk == BLK_S1_ACTOR)
				s1->actor_port_key = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2_ACTOR)
				s2->actor_port_key = strtoul(vstr, NULL, 0);
		}
		else if(strcasestr(fstr, "oper key")) {
			if(blk == BLK_S1_PARTNER)
				s1->partner_oper_key = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2_PARTNER)
				s2->partner_oper_key = strtoul(vstr, NULL, 0);
		}
		else if(strcasestr(fstr, "port priority")) {
			if(blk == BLK_S1_ACTOR)
				s1->actor_port_prio = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S1_PARTNER)
				s1->partner_port_prio = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2_ACTOR)
				s2->actor_port_prio = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2_PARTNER)
				s2->partner_port_prio = strtoul(vstr, NULL, 0);
		}
		else if(strcasestr(fstr, "port number")) {
			if(blk == BLK_S1_ACTOR)
				s1->actor_port_number = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S1_PARTNER)
				s1->partner_port_number = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2_ACTOR)
				s2->actor_port_number = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2_PARTNER)
				s2->partner_port_number = strtoul(vstr, NULL, 0);
		}
		else if(strcasestr(fstr, "port state")) {
			if(blk == BLK_S1_ACTOR)
				s1->actor_port_state = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S1_PARTNER)
				s1->partner_port_state = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2_ACTOR)
				s2->actor_port_state = strtoul(vstr, NULL, 0);
			else if(blk == BLK_S2_PARTNER)
				s2->partner_port_state = strtoul(vstr, NULL, 0);
		}
	}

	print_slave_status(s1);
	printf("----------------------------\n");
	print_slave_status(s2);

	pclose(fp);

	return 0;
}

// strtok å¯ä»¥æŒ‡å®šå¤šä¸ªåˆ†éš”ç¬¦, strtok å†…éƒ¨ç»´æŠ¤ last token çš„ä½ç½®ï¼Œå› æ­¤ strtok æ“ä½œçš„å­—ç¬¦ä¸²å¿…é¡»ä¿å­˜åœ¨ buffer æ•°ç»„é‡Œï¼Œå› ä¸º strtok ä¼šåŸåœ°ä¿®æ”¹æ•°ç»„å†…å®¹
// ä»¥ `char buf[] = "this,is,a,string";`ä¸ºä¾‹ï¼Œè¿ç»­è°ƒç”¨ strtok ä¹‹å buffer æ•°ç»„çš„å†…å®¹å¦‚ä¸‹
	t  h  i  s  ,  i  s  ,  a  ,  s  t  r  i  n  g \0         this,is,a,string
	
	t  h  i  s  \0 i  s  ,  a  ,  s  t  r  i  n  g \0         this
	^
	t  h  i  s  \0 i  s  \0 a  ,  s  t  r  i  n  g \0         is
					^
	t  h  i  s  \0 i  s  \0 a  \0 s  t  r  i  n  g \0         a
							^
	t  h  i  s  \0 i  s  \0 a  \0 s  t  r  i  n  g \0         string

// scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf
// scanfä½¿ç”¨ç©ºç™½ç¬¦(newlines, tabs, and spaces)å°†è¾“å…¥åˆ†å‰²æˆå„ä¸ªä¸åŒçš„åŸŸ(scanf matches up consecutive conversion specifications to consecutive fields, skipping over the whitespace in between)
[C scanf format specifier](https://www.demo2s.com/c/c-scanf-format-specifier.html)  
[å¸¦è¿‡æ»¤å™¨çš„scanfè¯»å–å­—ç¬¦å’Œå­—ç¬¦ä¸²](https://www.demo2s.com/c/c-reading-characters-and-string-using-scanf-with-filter.html)  

// kill
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <signal.h>
#include <sys/wait.h>
#include <errno.h>

int check_process_stop(int pid)
{
	int r, status;

	r = waitpid(pid, &status, WNOHANG);
	if(r == 0)
		return 1;

	if(r < 0) {
		printf("waitpid failed: %s\n", strerror(errno));
		return 1;
	}

	printf("process %d exited: r = %d\n", pid, r);

	return 0;
}

int main(void)
{
	int n, i, r, ai, my_pid;
	const char *av[10];
	char cmd[256];

	av[0] = "/mnt/c/Users/morrism/Downloads/test.sh";
	av[1] = "param1";
	ai = 2;
	av[ai++] = "param2";
	av[ai] = NULL;

	n = 0;
	for(i = 0; i < ai; i++)
		n += snprintf(cmd + n, sizeof(cmd) - n, " %s", av[i]);
	printf("cmd:%s\n", cmd);

	my_pid = fork();
	switch(my_pid) {
	default:
		// in parent process, doSomething such as monitoring
		printf("This is parent process\n");
		break;
	case -1:
		printf("fork failed: %s\n", strerror(errno));
		my_pid = 0;
		break;
	case 0:
		setpgid(0, 0);
		execv(av[0], (char*const*)av);
		exit(-1);
	}

		// sleep 5 secs for test purpose
	sleep(5);

	// tear down child process
	r = kill(my_pid, SIGTERM);
	if(r < 0)
		printf("kill failed: %s\n", strerror(errno));

	for(i = 0; i < 100; i++) {
		r = check_process_stop(my_pid);
		if(r == 0) {
			my_pid = 0;
			break;
		}
		usleep(100);
	}

	if(my_pid != 0) {
		printf("waitpid did not succeed: r = %d\n, pocess %d is now a zombie process", r, my_pid);
		my_pid = 0;
	}

	return 0;
}

// sysconf
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>

int main()
{
	int ncore;
	errno = 0;

	if ((ncore = sysconf(_SC_NPROCESSORS_ONLN)) == -1)
		if (errno == 0)
			printf("_SC_NPROCESSORS_ONLN not supported by this implementation.\n");
		else
			perror("sysconf error.");
	else
		printf("ncore = %d\n", ncore);
}

// sysinfo
#include <sys/sysinfo.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

#define MB (1024 * 1024)

int main(void)
{
	int r;
	struct sysinfo si;
	int totalram, freeram, percent_inuse;

	r = sysinfo(&si);
	if(r < 0) {
		printf("sysinfo failed: %s", strerror(errno));
		return -1;
	}

	totalram = si.totalram/MB;
	freeram = si.freeram/MB;
	percent_inuse = (int)((float)(totalram - freeram) / (float)totalram * 100.0);

	printf("totalram: %d(MB), freeram:%d(MB), percent_inuse:%d\%\n",
		totalram, freeram, percent_inuse);

	return 0;
}

// readlink
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <stdio.h>

int main(void)
{
	int r;
	char *tz_path;
	char lpath[256], cmd[128];
	const char *symlink = "/etc/localtime";

	r = readlink(symlink, lpath, sizeof(lpath));
	if(r < 0) {
		printf("readlink failed\n");
		return -1;
	}

	printf("The value for symbol link %s is %s\n", symlink, lpath);

	tz_path = "/usr/share/zoneinfo/Asia/Shanghai";
	snprintf(cmd, sizeof(cmd), "ln -sf %s /etc/localtime", tz_path);

	r = system(cmd);
	if(r != 0) {
		printf("system failed\n");
		return -1;
	}
	printf("symlink %s to target %s succeed\n", symlink, tz_path);

	return 0;
}

// stat, fstat
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

int main(void)
{
	struct stat st;
	int r, n, fd;
	char *buf;

	fd = open("file.txt", O_RDONLY);
	if(fd < 0) {
		printf("open failed\n");
		return -1;
	}

	r = fstat(fd, &st);
	if(r < 0 || st.st_size == 0)
		n = 1024;
	else
		n = st.st_size;

	buf = malloc(n);

	n = read(fd, buf, n);
	if(n > 0)
		printf("buf:%s", buf);

	free(buf);
	close(fd);

	return 0;
}

// uname
#include <sys/types.h>
#include <sys/utsname.h>
#include <stdio.h>

int main()
{
	struct utsname sysInfo;
	if (uname(&sysInfo) != -1) {
		puts(sysInfo.sysname);
		puts(sysInfo.nodename);
		puts(sysInfo.release);
		puts(sysInfo.version);
		puts(sysInfo.machine);
	}
	else
		perror("uname() error");
}
```

[**Extensions to the C Language Family**](https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/C-Extensions.html)  
[GNU C Language Manual](https://www.gnu.org/software/c-intro-and-ref/manual/html_node/index.html#SEC_Contents)  
[Online Python to C Converter](https://www.codeconvert.ai/python-to-c-converter)  
[The GNU C Reference Manual](https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html)  
[C Operator Precedence](https://en.cppreference.com/w/c/language/operator_precedence)  
[**The GNU C Library**](https://www.gnu.org/software/libc/manual/html_node/index.html#SEC_Contents) #online  
[**The GNU C Library**](http://herbert.the-little-red-haired-girl.org/html/glibc/libc_toc.html)  
[**The GNU C Library (glibc) manual**](https://sourceware.org/glibc/manual/)  
[cå‡½æ•°ä½¿ç”¨å‚è€ƒå®ä¾‹](https://bytefreaks.net/category/programming-2/c-programming-2)  
[POXIS Function Reference Example](https://support.sas.com/documentation/onlinedoc/sasc/doc/lr2/lrv2ch20.htm#lr2posix)  
[C standard](https://www.open-std.org/jtc1/sc22/wg14/www/standards.html)  
[**glibc source code**](https://elixir.bootlin.com/glibc/latest/source) #sourcecode  
[The GNU C Library](https://www.gnu.org/software/libc/manual/html_mono/libc.html)  
[Memory Layout Of A C Program](https://hackthedeveloper.com/memory-layout-c-program/)  
[C Program Compilation Process](https://hackthedeveloper.com/c-program-compilation-process/)  
[CÂ è¯­è¨€å¸¸è§é—®é¢˜é›†](https://c-faq-chn.sourceforge.net/ccfaq/ccfaq.html)  
[Notes for C and C++ Programming](https://www.codeinsideout.com/blog/c-cpp/notes/)  
[c for dummies](https://c-for-dummies.com/)  
[C and C++ Projects](https://www.codewithc.com/c-projects-with-source-code/)  
[How to split/tokenize a string? (strtok() string tokenizer)](https://www.equestionanswers.com/c/c-strtok.php)  
[declaring a flexible array member](https://wiki.sei.cmu.edu/confluence/display/c/DCL38-C.+Use+the+correct+syntax+when+declaring+a+flexible+array+member)  
[How to interpret complex C/C++ declarations](https://www.codeproject.com/Articles/7042/How-to-interpret-complex-C-C-declarations)  
[Reading C type declarations](http://unixwiz.net/techtips/reading-cdecl.html)  
[cdecl.org](https://cdecl.org/)  

[Awesome C](https://github.com/oz123/awesome-c?tab=readme-ov-file#awesome-c) #github  
[C](https://github.com/marcotrosi/C)  
[**Programming in C**](https://users.cs.cf.ac.uk/dave/C/)  
[HOWTO: Use Address Sanitizer](https://www.osc.edu/resources/getting_started/howto/howto_use_address_sanitizer)  
[Clang 19.0.0git documentation](https://clang.llvm.org/docs/index.html)  
[Signal Handling](https://www.gnu.org/software/libc/manual/html_node/Signal-Handling.html)  
[Introduction To Unix Signals Programming](https://www.cs.kent.edu/~ruttan/sysprog/lectures/signals.html)  
[CS 43203 : System Programming](https://www.cs.kent.edu/~ruttan/sysprog/)  
[Unix Pthreads tutorial](https://www.cs.kent.edu/~ruttan/sysprog/)  
[C program to implement linked list](https://www.programmingsimplified.com/c/data-structures)  
[Using Templates and Generics in C](https://levelup.gitconnected.com/using-templates-and-generics-in-c-968da223154d)  
[Tutorial: Generics in C](https://itnext.io/tutorial-generics-in-c-b3362b3376a3)  
[Generic Programming in C](https://cs.boisestate.edu/~amit/teaching/253/handouts/07-c-generic-coding-handout.pdf)  
[void * and Function Pointers](https://web.stanford.edu/class/archive/cs/cs107/cs107.1202/lab4/)  
[Functional Pointer and Callback in C++](https://primerpy.medium.com/functional-pointer-and-callback-in-c-86c208df6b2f)  
[C and C++ Language Syntax Reference](https://www.cprogramming.com/reference/)  
[Understanding the LD_LIBRARY_PATH Environment Variable](https://tecadmin.net/understanding-the-ld_library_path-environment-variable/)  
[Arrays of Length Zero](https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html)  
[Bounded Flexible Arrays in C](https://people.kernel.org/kees/bounded-flexible-arrays-in-c)  
[Flexible Array Members for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1039r0.html)  
[Zero-length arrays in C have to go at the end of the struct](https://shivankaul.com/blog/zero-length-arrays)  
[How to Use typeof, Statement Expressions and Block-Scope Label Names](https://www.oracle.com/solaris/technologies/c-type.html)  
[The Unofficial C For Dummies Website](https://c-for-dummies.com/)  
