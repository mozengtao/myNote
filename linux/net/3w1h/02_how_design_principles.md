# HOW｜设计思想与抽象方法（如何解决）

## 1. 核心设计原则

```
CORE DESIGN PRINCIPLES OF LINUX NETWORK SUBSYSTEM
+=============================================================================+
|                                                                              |
|  PRINCIPLE 1: LAYERED DESIGN (分层设计)                                      |
|  ──────────────────────────────────────                                      |
|                                                                              |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  Application Layer (User Space)                                          │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  socket(), connect(), send(), recv(), close()                     │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                           │ System Call                                  │ |
|  │  ─────────────────────────┼──────────────────────────────────────────── │ |
|  │                           ▼                                              │ |
|  │  Socket Layer (BSD Socket API)                                           │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  struct socket → struct sock                                      │  │ |
|  │  │  tcp_sendmsg(), tcp_recvmsg(), tcp_poll()                         │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                           │ Protocol-specific ops                        │ |
|  │                           ▼                                              │ |
|  │  Transport Layer (TCP/UDP)                                               │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  tcp_v4_connect(), tcp_transmit_skb()                             │  │ |
|  │  │  tcp_rcv_established(), tcp_rcv_state_process()                   │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                           │ IP layer ops                                 │ |
|  │                           ▼                                              │ |
|  │  Network Layer (IP)                                                      │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  ip_queue_xmit(), ip_local_deliver()                              │  │ |
|  │  │  routing table, fragmentation                                     │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                           │ net_device ops                               │ |
|  │                           ▼                                              │ |
|  │  Device Layer (net_device abstraction)                                   │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  dev_queue_xmit(), netif_receive_skb()                            │  │ |
|  │  │  qdisc (traffic control), NAPI                                    │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                           │ Hardware ops                                 │ |
|  │                           ▼                                              │ |
|  │  Driver Layer                                                            │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  ndo_start_xmit(), napi_poll()                                    │  │ |
|  │  │  DMA, ring buffers, interrupts                                    │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  每层只依赖下层接口，不依赖具体实现                                          |
|  每层可以独立演进和优化                                                      |
|                                                                              |
+=============================================================================+
```

**中文说明：**

分层设计是网络子系统的核心架构原则：
- 每层通过明确定义的接口与下层交互
- 上层不关心下层的实现细节
- 新协议或新驱动可以在对应层独立添加
- 每层可以独立优化（如 NAPI 在设备层，拥塞控制在传输层）

---

```
PRINCIPLE 2: ABSTRACT DRIVER INTERFACE (抽象驱动接口)
+=============================================================================+
|                                                                              |
|  struct net_device_ops - 驱动必须实现的操作集                                 |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  const struct net_device_ops = {                                         │ |
|  │      .ndo_open           = driver_open,      // 打开设备                 │ |
|  │      .ndo_stop           = driver_stop,      // 关闭设备                 │ |
|  │      .ndo_start_xmit     = driver_xmit,      // 发送数据包               │ |
|  │      .ndo_get_stats      = driver_stats,     // 获取统计                 │ |
|  │      .ndo_set_mac_address= driver_set_mac,   // 设置 MAC                 │ |
|  │      .ndo_change_mtu     = driver_mtu,       // 修改 MTU                 │ |
|  │      // ... more operations                                              │ |
|  │  };                                                                      │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  Protocol Stack                        Driver A        Driver B              |
|  ┌──────────────┐                   ┌───────────┐   ┌───────────┐           |
|  │              │                   │  e1000e   │   │   ixgbe   │           |
|  │ dev_queue_xmit                   │           │   │           │           |
|  │      │       │                   │ ops = {   │   │ ops = {   │           |
|  │      ▼       │                   │  .xmit=   │   │  .xmit=   │           |
|  │ ndo_start_xmit ─────────────────►│  e1000_xmit   │   │  ixgbe_xmit           |
|  │              │                   │  ...      │   │  ...      │           |
|  │              │                   │ }         │   │ }         │           |
|  └──────────────┘                   └───────────┘   └───────────┘           |
|                                                                              |
|  协议栈调用统一接口，驱动通过 ops 表提供具体实现                              |
|  类似面向对象的多态                                                          |
|                                                                              |
+=============================================================================+
```

**中文说明：**

`net_device_ops` 是驱动抽象的核心：
- 定义了驱动必须/可选实现的所有操作
- 协议栈通过函数指针调用，不关心具体驱动
- 新驱动只需填充 ops 表并注册
- 这是 C 语言实现"接口-实现分离"的标准模式

---

```
PRINCIPLE 3: EVENT-DRIVEN AND CALLBACK (事件驱动与回调)
+=============================================================================+
|                                                                              |
|  RECEIVE PATH (接收路径)                                                     |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  NIC Hardware                                                            │ |
|  │      │                                                                   │ |
|  │      │ ① IRQ (hardware interrupt)                                       │ |
|  │      ▼                                                                   │ |
|  │  Interrupt Handler                                                       │ |
|  │      │                                                                   │ |
|  │      │ ② Schedule NAPI poll                                             │ |
|  │      │    napi_schedule(&napi)                                          │ |
|  │      ▼                                                                   │ |
|  │  Softirq (NET_RX_SOFTIRQ)                                                │ |
|  │      │                                                                   │ |
|  │      │ ③ Call driver's poll callback                                    │ |
|  │      │    napi->poll(napi, budget)                                      │ |
|  │      ▼                                                                   │ |
|  │  Driver Poll (e.g., e1000_clean_rx_irq)                                  │ |
|  │      │                                                                   │ |
|  │      │ ④ For each received packet:                                      │ |
|  │      │    netif_receive_skb(skb)                                        │ |
|  │      ▼                                                                   │ |
|  │  Core Network (netif_receive_skb)                                        │ |
|  │      │                                                                   │ |
|  │      │ ⑤ Dispatch to protocol handler                                   │ |
|  │      │    pt->func(skb, dev, pt, orig_dev)                              │ |
|  │      ▼                                                                   │ |
|  │  Protocol Handler (ip_rcv)                                               │ |
|  │      │                                                                   │ |
|  │      │ ⑥ Process through protocol stack                                 │ |
|  │      ▼                                                                   │ |
|  │  Transport Handler (tcp_v4_rcv)                                          │ |
|  │      │                                                                   │ |
|  │      │ ⑦ Deliver to socket                                              │ |
|  │      ▼                                                                   │ |
|  │  Socket Receive Queue                                                    │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  每一步都是回调驱动，没有轮询等待                                            |
|  异步处理提高系统响应性                                                      |
|                                                                              |
+=============================================================================+
```

**中文说明：**

接收路径完全由事件和回调驱动：
1. 硬件中断触发处理流程
2. NAPI 调度器批量处理减少中断开销
3. 驱动的 poll 回调获取数据包
4. 协议处理函数通过 `packet_type` 注册和分发
5. 最终通过 socket 回调通知应用层

---

```
PRINCIPLE 4: DEFERRED PROCESSING - NAPI (延迟处理 - NAPI)
+=============================================================================+
|                                                                              |
|  PROBLEM: INTERRUPT STORM (中断风暴)                                         |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  Without NAPI (高速网络下):                                              │ |
|  │                                                                          │ |
|  │  Packet1 → IRQ → process → return                                       │ |
|  │  Packet2 → IRQ → process → return                                       │ |
|  │  Packet3 → IRQ → process → return                                       │ |
|  │  ...                                                                     │ |
|  │  10Gbps ≈ 14.8 million packets/sec                                      │ |
|  │  = CPU 100% in interrupt context!                                       │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  SOLUTION: NAPI (New API)                                                    |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  With NAPI:                                                              │ |
|  │                                                                          │ |
|  │  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐     │ |
|  │  │ Interrupt Mode  │    │  Polling Mode   │    │ Interrupt Mode  │     │ |
|  │  │                 │    │                 │    │                 │     │ |
|  │  │  First packet   │    │ Poll up to      │    │  Low traffic    │     │ |
|  │  │  triggers IRQ   │ ─► │ 'budget' pkts   │ ─► │  re-enable IRQ  │     │ |
|  │  │                 │    │ (e.g., 64)      │    │                 │     │ |
|  │  │  Disable IRQ    │    │                 │    │  Wait for IRQ   │     │ |
|  │  └─────────────────┘    └─────────────────┘    └─────────────────┘     │ |
|  │                                                                          │ |
|  │  Key operations:                                                         │ |
|  │  • napi_schedule()     - 调度 NAPI poll                                 │ |
|  │  • napi_poll()         - 轮询处理数据包                                 │ |
|  │  • napi_complete()     - 完成轮询，重新启用中断                         │ |
|  │                                                                          │ |
|  │  Adaptive behavior:                                                      │ |
|  │  • 低流量：传统中断模式，低延迟                                          │ |
|  │  • 高流量：轮询模式，高吞吐                                              │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

NAPI 是解决高速网络中断风暴的关键机制：
- 首个数据包触发中断，然后禁用中断
- 切换到轮询模式，批量处理数据包
- 处理完成或达到预算后，重新启用中断
- 自适应调整：低流量时低延迟，高流量时高吞吐

---

```
PRINCIPLE 5: CONCURRENCY PROTECTION (并发保护)
+=============================================================================+
|                                                                              |
|  LOCKING HIERARCHY (锁层次)                                                  |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  USER CONTEXT                    SOFTIRQ CONTEXT                         │ |
|  │  ────────────                    ───────────────                         │ |
|  │                                                                          │ |
|  │  lock_sock(sk)                   local_bh_disable()                      │ |
|  │      │                               │                                   │ |
|  │      │  可睡眠                       │  不可睡眠                         │ |
|  │      │  阻塞等待                     │  禁用软中断                       │ |
|  │      ▼                               ▼                                   │ |
|  │  release_sock(sk)                bh_lock_sock(sk)                        │ |
|  │                                      │                                   │ |
|  │                                      │  自旋锁                           │ |
|  │                                      ▼                                   │ |
|  │                                  bh_unlock_sock(sk)                      │ |
|  │                                      │                                   │ |
|  │                                      ▼                                   │ |
|  │                                  local_bh_enable()                       │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  RCU (Read-Copy-Update)                                                      |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  读操作 (无锁):                                                          │ |
|  │  rcu_read_lock();                                                        │ |
|  │  ptr = rcu_dereference(global_ptr);                                      │ |
|  │  // use ptr                                                              │ |
|  │  rcu_read_unlock();                                                      │ |
|  │                                                                          │ |
|  │  写操作 (需要同步):                                                      │ |
|  │  new_ptr = kmalloc(...);                                                 │ |
|  │  // initialize new_ptr                                                   │ |
|  │  rcu_assign_pointer(global_ptr, new_ptr);                                │ |
|  │  synchronize_rcu();  // 等待所有读者完成                                 │ |
|  │  kfree(old_ptr);                                                         │ |
|  │                                                                          │ |
|  │  用于: 路由表、协议处理器表、网络命名空间                                │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  Reference Counting (引用计数)                                               |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  From tcp.c:                                                             │ |
|  │                                                                          │ |
|  │  sock_hold(sk);      // 增加引用计数                                     │ |
|  │  // ... 使用 sk ...                                                      │ |
|  │  sock_put(sk);       // 减少引用计数，可能释放                           │ |
|  │                                                                          │ |
|  │  sk_buff:                                                                │ |
|  │  skb_get(skb);       // 增加 skb 引用                                    │ |
|  │  kfree_skb(skb);     // 减少引用，可能释放                               │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

并发保护采用多层机制：
1. **Socket 锁**：`lock_sock()`/`release_sock()` 保护用户上下文操作
2. **BH 锁**：`bh_lock_sock()` 保护软中断上下文操作
3. **RCU**：无锁读优化，用于读多写少的数据结构（路由表等）
4. **引用计数**：`sock_hold()`/`sock_put()` 管理对象生命周期

---

## 2. 抽象和分层

```
ABSTRACTION LAYERS AND BOUNDARIES
+=============================================================================+
|                                                                              |
|  LAYER BOUNDARIES (层边界)                                                   |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │                     SOCKET LAYER                                         │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │                                                                    │  │ |
|  │  │  Abstraction: struct socket / struct sock                         │  │ |
|  │  │                                                                    │  │ |
|  │  │  • 统一的 socket 系统调用接口                                      │  │ |
|  │  │  • 协议无关的连接管理                                              │  │ |
|  │  │  • 通用的缓冲区管理                                                │  │ |
|  │  │                                                                    │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                          │                                               │ |
|  │                          ▼ proto_ops / proto                              │ |
|  │                     PROTOCOL LAYER                                       │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │                                                                    │  │ |
|  │  │  Abstraction: struct proto / struct inet_connection_sock_af_ops   │  │ |
|  │  │                                                                    │  │ |
|  │  │  TCP implementation:                                               │  │ |
|  │  │  • tcp_prot (协议操作表)                                           │  │ |
|  │  │  • tcp_sock (TCP 特有数据)                                         │  │ |
|  │  │  • tcp_v4_connect(), tcp_sendmsg(), tcp_recvmsg()                  │  │ |
|  │  │                                                                    │  │ |
|  │  │  UDP implementation:                                               │  │ |
|  │  │  • udp_prot                                                        │  │ |
|  │  │  • udp_sock                                                        │  │ |
|  │  │  • udp_sendmsg(), udp_recvmsg()                                    │  │ |
|  │  │                                                                    │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                          │                                               │ |
|  │                          ▼ inet_connection_sock_af_ops                   │ |
|  │                       IP LAYER                                           │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │                                                                    │  │ |
|  │  │  Abstraction: Address family operations                            │  │ |
|  │  │                                                                    │  │ |
|  │  │  • ipv4_specific (IPv4 操作)                                       │  │ |
|  │  │  • ipv6_specific (IPv6 操作)                                       │  │ |
|  │  │  • 路由查找、分片、校验和                                          │  │ |
|  │  │                                                                    │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                          │                                               │ |
|  │                          ▼ net_device_ops                                │ |
|  │                     DEVICE LAYER                                         │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │                                                                    │  │ |
|  │  │  Abstraction: struct net_device / net_device_ops                  │  │ |
|  │  │                                                                    │  │ |
|  │  │  • 统一的设备操作接口                                              │  │ |
|  │  │  • 流量控制（qdisc）                                               │  │ |
|  │  │  • 多队列支持                                                      │  │ |
|  │  │                                                                    │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

每层通过特定的抽象接口与其他层交互：
- **Socket 层**：`struct proto_ops` 定义 socket 操作
- **协议层**：`struct proto` 定义协议特定操作（TCP/UDP）
- **IP 层**：`inet_connection_sock_af_ops` 定义地址族操作
- **设备层**：`net_device_ops` 定义驱动操作

---

## 3. 变化隔离与扩展点

```
CHANGE ISOLATION AND EXTENSION POINTS
+=============================================================================+
|                                                                              |
|  ISOLATED CHANGES (被隔离的变化)                                             |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐   │ |
|  │  │ NIC HARDWARE OPERATIONS                                          │   │ |
|  │  │ ─────────────────────────                                        │   │ |
|  │  │ • DMA 配置                                                       │   │ |
|  │  │ • Ring buffer 管理                                               │   │ |
|  │  │ • 中断处理                                                       │   │ |
|  │  │ • 硬件校验和                                                     │   │ |
|  │  │                                                                  │   │ |
|  │  │ 隔离方式: net_device_ops                                         │   │ |
|  │  │ 协议栈完全不知道硬件细节                                         │   │ |
|  │  └─────────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐   │ |
|  │  │ PROTOCOL-SPECIFIC PROCESSING                                     │   │ |
|  │  │ ─────────────────────────────                                    │   │ |
|  │  │ • TCP 状态机                                                     │   │ |
|  │  │ • UDP 无连接处理                                                 │   │ |
|  │  │ • SCTP 多流处理                                                  │   │ |
|  │  │                                                                  │   │ |
|  │  │ 隔离方式: struct proto                                           │   │ |
|  │  │ 每个协议独立实现，通过统一接口被调用                             │   │ |
|  │  └─────────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐   │ |
|  │  │ CONGESTION CONTROL ALGORITHMS                                    │   │ |
|  │  │ ───────────────────────────────                                  │   │ |
|  │  │ • Reno (默认)                                                    │   │ |
|  │  │ • Cubic (高延迟网络)                                             │   │ |
|  │  │ • BBR (带宽估算)                                                 │   │ |
|  │  │                                                                  │   │ |
|  │  │ 隔离方式: struct tcp_congestion_ops                              │   │ |
|  │  │ 从 tcp.c: tcp_register_congestion_control(&tcp_reno)             │   │ |
|  │  └─────────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  EXTENSION POINTS (扩展点)                                                   |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  1. PROTOCOL REGISTRATION (协议注册)                                    │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │ inet_add_protocol(&tcp_protocol, IPPROTO_TCP);                │   │ |
|  │     │ inet_add_protocol(&udp_protocol, IPPROTO_UDP);                │   │ |
|  │     │                                                                │   │ |
|  │     │ 新协议只需:                                                    │   │ |
|  │     │ • 实现 struct net_protocol                                    │   │ |
|  │     │ • 调用 inet_add_protocol() 注册                               │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  2. DRIVER REGISTRATION (驱动注册)                                      │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │ register_netdev(netdev);                                      │   │ |
|  │     │                                                                │   │ |
|  │     │ 新驱动只需:                                                    │   │ |
|  │     │ • 分配并初始化 struct net_device                              │   │ |
|  │     │ • 填充 net_device_ops                                         │   │ |
|  │     │ • 调用 register_netdev() 注册                                 │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  3. PACKET TYPE REGISTRATION (数据包类型注册)                           │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │ dev_add_pack(&ip_packet_type);   // ETH_P_IP                  │   │ |
|  │     │ dev_add_pack(&ipv6_packet_type); // ETH_P_IPV6                │   │ |
|  │     │ dev_add_pack(&arp_packet_type);  // ETH_P_ARP                 │   │ |
|  │     │                                                                │   │ |
|  │     │ 新以太网类型只需注册 packet_type                               │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  4. NETFILTER HOOKS (Netfilter 钩子)                                    │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │ nf_register_hook(&my_hook);                                   │   │ |
|  │     │                                                                │   │ |
|  │     │ 可在以下点挂钩:                                                │   │ |
|  │     │ • NF_INET_PRE_ROUTING   (路由前)                              │   │ |
|  │     │ • NF_INET_LOCAL_IN      (本地输入)                            │   │ |
|  │     │ • NF_INET_FORWARD       (转发)                                │   │ |
|  │     │ • NF_INET_LOCAL_OUT     (本地输出)                            │   │ |
|  │     │ • NF_INET_POST_ROUTING  (路由后)                              │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  5. SOCKET OPTIONS (Socket 选项) - from tcp.c                           │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │ tcp_setsockopt() / tcp_getsockopt()                           │   │ |
|  │     │                                                                │   │ |
|  │     │ 可配置:                                                        │   │ |
|  │     │ • TCP_NODELAY     (禁用 Nagle 算法)                           │   │ |
|  │     │ • TCP_CORK        (累积小包)                                  │   │ |
|  │     │ • TCP_CONGESTION  (选择拥塞控制算法)                          │   │ |
|  │     │ • TCP_MAXSEG      (最大段大小)                                │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

**被隔离的变化：**
- NIC 硬件操作被 `net_device_ops` 隔离
- 协议特定处理被 `struct proto` 隔离
- 拥塞控制算法被 `tcp_congestion_ops` 隔离

**扩展点：**
- 协议注册：`inet_add_protocol()`
- 驱动注册：`register_netdev()`
- 数据包类型注册：`dev_add_pack()`
- Netfilter 钩子：5 个标准挂载点
- Socket 选项：可配置的行为参数

---

## 4. 控制流、状态与资源生命周期管理

```
CONTROL FLOW MANAGEMENT
+=============================================================================+
|                                                                              |
|  SEND PATH CONTROL FLOW (发送路径)                                           |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  User calls send()                                                       │ |
|  │      │                                                                   │ |
|  │      ▼                                                                   │ |
|  │  tcp_sendmsg()  [net/ipv4/tcp.c]                                        │ |
|  │      │                                                                   │ |
|  │      │ lock_sock(sk)                                                    │ |
|  │      │ copy data to sk_buff                                             │ |
|  │      │ tcp_push()                                                       │ |
|  │      │ release_sock(sk)                                                 │ |
|  │      ▼                                                                   │ |
|  │  tcp_write_xmit()  [net/ipv4/tcp_output.c]                              │ |
|  │      │                                                                   │ |
|  │      │ segment data                                                     │ |
|  │      │ add TCP header                                                   │ |
|  │      ▼                                                                   │ |
|  │  ip_queue_xmit()  [net/ipv4/ip_output.c]                                │ |
|  │      │                                                                   │ |
|  │      │ route lookup                                                     │ |
|  │      │ add IP header                                                    │ |
|  │      ▼                                                                   │ |
|  │  dev_queue_xmit()  [net/core/dev.c]                                     │ |
|  │      │                                                                   │ |
|  │      │ traffic control (qdisc)                                          │ |
|  │      │ queue to device                                                  │ |
|  │      ▼                                                                   │ |
|  │  ndo_start_xmit()  [driver]                                             │ |
|  │      │                                                                   │ |
|  │      │ DMA to hardware                                                  │ |
|  │      ▼                                                                   │ |
|  │  Hardware transmits packet                                               │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

```
STATE MANAGEMENT
+=============================================================================+
|                                                                              |
|  TCP STATE MACHINE (from tcp.c)                                              |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  void tcp_set_state(struct sock *sk, int state)                         │ |
|  │  {                                                                       │ |
|  │      int oldstate = sk->sk_state;                                       │ |
|  │                                                                          │ |
|  │      // State transition table (new_state array)                        │ |
|  │      // ensures only valid transitions occur                            │ |
|  │                                                                          │ |
|  │      switch (state) {                                                   │ |
|  │      case TCP_ESTABLISHED:                                              │ |
|  │          if (oldstate != TCP_ESTABLISHED)                               │ |
|  │              TCP_INC_STATS(sock_net(sk), TCP_MIB_CURRESTAB);            │ |
|  │          break;                                                         │ |
|  │      case TCP_CLOSE:                                                    │ |
|  │          sk->sk_prot->unhash(sk);  // 从哈希表移除                      │ |
|  │          // ... cleanup ...                                             │ |
|  │          break;                                                         │ |
|  │      }                                                                   │ |
|  │                                                                          │ |
|  │      sk->sk_state = state;                                              │ |
|  │                                                                          │ |
|  │      #ifdef STATE_TRACE                                                 │ |
|  │      SOCK_DEBUG(sk, "TCP sk=%p, State %s -> %s\n", ...);                │ |
|  │      #endif                                                              │ |
|  │  }                                                                       │ |
|  │                                                                          │ |
|  │  State is centralized in sk->sk_state                                   │ |
|  │  All transitions go through tcp_set_state()                              │ |
|  │  Statistics are updated atomically                                       │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  SK_BUFF STATE                                                               |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  sk_buff 在网络栈中的状态演变:                                           │ |
|  │                                                                          │ |
|  │  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐              │ |
|  │  │ Alloc   │ ─► │ Add TCP │ ─► │ Add IP  │ ─► │ Queue   │              │ |
|  │  │ skb     │    │ header  │    │ header  │    │ to dev  │              │ |
|  │  └─────────┘    └─────────┘    └─────────┘    └─────────┘              │ |
|  │                                                                          │ |
|  │  skb->data 指针随着处理向前移动                                          │ |
|  │  skb->protocol 标识协议类型                                              │ |
|  │  skb->sk 关联到 socket                                                   │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

```
RESOURCE LIFECYCLE MANAGEMENT
+=============================================================================+
|                                                                              |
|  SOCKET LIFECYCLE (from tcp.c)                                               |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  CREATE                                                                  │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  tcp_v4_init_sock()                                               │  │ |
|  │  │  • 分配 tcp_sock 结构                                             │  │ |
|  │  │  • 初始化 TCP 选项                                                │  │ |
|  │  │  • 设置初始状态 TCP_CLOSE                                         │  │ |
|  │  │  • refcount = 1                                                   │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                          │                                               │ |
|  │                          ▼                                               │ |
|  │  USE (引用计数保护)                                                      │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  sock_hold(sk);     // 增加引用                                   │  │ |
|  │  │  // ... 使用 socket ...                                           │  │ |
|  │  │  sock_put(sk);      // 减少引用                                   │  │ |
|  │  │                                                                    │  │ |
|  │  │  多个上下文可能同时持有引用:                                       │  │ |
|  │  │  • 用户进程 (通过 fd)                                             │  │ |
|  │  │  • 定时器 (重传、keepalive)                                       │  │ |
|  │  │  • 软中断 (接收处理)                                              │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                          │                                               │ |
|  │                          ▼                                               │ |
|  │  CLOSE (tcp_close)                                                       │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  tcp_close(sk, timeout)                                           │  │ |
|  │  │  {                                                                 │  │ |
|  │  │      lock_sock(sk);                                                │  │ |
|  │  │                                                                    │  │ |
|  │  │      if (sk->sk_state == TCP_LISTEN) {                             │  │ |
|  │  │          tcp_set_state(sk, TCP_CLOSE);                             │  │ |
|  │  │          // 清理 accept 队列                                       │  │ |
|  │  │      } else if (/* data to send */) {                              │  │ |
|  │  │          tcp_set_state(sk, TCP_FIN_WAIT1);                         │  │ |
|  │  │          // 发送 FIN                                               │  │ |
|  │  │      } else {                                                      │  │ |
|  │  │          // 直接关闭或 RST                                         │  │ |
|  │  │      }                                                             │  │ |
|  │  │                                                                    │  │ |
|  │  │      release_sock(sk);                                             │  │ |
|  │  │      sock_put(sk);  // 减少用户持有的引用                          │  │ |
|  │  │  }                                                                 │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                          │                                               │ |
|  │                          ▼                                               │ |
|  │  DESTROY (引用计数归零时)                                                │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  sk_free()                                                         │  │ |
|  │  │  • 释放接收/发送缓冲区                                             │  │ |
|  │  │  • 释放 socket 结构                                                │  │ |
|  │  │  • 释放关联的 sk_buff                                              │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  SK_BUFF LIFECYCLE                                                           |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  alloc_skb()          // 分配 skb                                       │ |
|  │      │                                                                   │ |
|  │      ▼                                                                   │ |
|  │  skb_reserve()        // 预留头部空间                                   │ |
|  │      │                                                                   │ |
|  │      ▼                                                                   │ |
|  │  skb_put() / skb_push() / skb_pull()  // 操作数据                       │ |
|  │      │                                                                   │ |
|  │      ▼                                                                   │ |
|  │  skb_clone() / skb_copy()  // 复制（共享或完全复制）                    │ |
|  │      │                                                                   │ |
|  │      ▼                                                                   │ |
|  │  kfree_skb() / consume_skb()  // 释放                                   │ |
|  │                                                                          │ |
|  │  引用计数: skb->users                                                   │ |
|  │  克隆时共享数据区，减少拷贝                                              │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

**控制流管理：**
- 发送路径清晰地从 socket 层穿过协议层、IP 层到设备层
- 每层通过回调函数传递控制

**状态管理：**
- TCP 状态集中在 `sk->sk_state`
- 所有状态转换通过 `tcp_set_state()` 函数
- 统计信息原子更新

**资源生命周期：**
- Socket 使用引用计数管理生命周期
- `sock_hold()`/`sock_put()` 确保安全的多上下文访问
- sk_buff 使用类似机制，支持零拷贝克隆
