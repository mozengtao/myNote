# WHAT｜架构模式与具体形态（长什么样）

## 1. 主要架构模式

```
ARCHITECTURE PATTERNS IN LINUX NETWORK SUBSYSTEM
+=============================================================================+
|                                                                              |
|  PATTERN 1: LAYERED ARCHITECTURE (分层架构)                                  |
|  ──────────────────────────────────────────                                  |
|                                                                              |
|  ┌─────────────────────────────────────────────────────────────────────────┐|
|  │                                                                          ||
|  │  Layer 5: Application                                                    ||
|  │  ┌────────────────────────────────────────────────────────────────────┐ ||
|  │  │  User processes (via system calls)                                  │ ||
|  │  └────────────────────────────────────────────────────────────────────┘ ||
|  │                              │                                           ||
|  │  ────────────────────────────┼─────── syscall boundary ────────────────  ||
|  │                              ▼                                           ||
|  │  Layer 4: Socket Interface                                               ||
|  │  ┌────────────────────────────────────────────────────────────────────┐ ||
|  │  │  struct socket, socket_file_ops, sock_sendmsg, sock_recvmsg        │ ||
|  │  └────────────────────────────────────────────────────────────────────┘ ||
|  │                              │ proto_ops                                 ||
|  │                              ▼                                           ||
|  │  Layer 3: Transport (TCP/UDP)                                            ||
|  │  ┌────────────────────────────────────────────────────────────────────┐ ||
|  │  │  tcp_prot, udp_prot, tcp_sendmsg, tcp_recvmsg                       │ ||
|  │  └────────────────────────────────────────────────────────────────────┘ ||
|  │                              │ inet_connection_sock_af_ops               ||
|  │                              ▼                                           ||
|  │  Layer 2: Network (IP)                                                   ||
|  │  ┌────────────────────────────────────────────────────────────────────┐ ||
|  │  │  ip_rcv, ip_queue_xmit, routing, fragmentation                      │ ||
|  │  └────────────────────────────────────────────────────────────────────┘ ||
|  │                              │ net_device interface                      ||
|  │                              ▼                                           ||
|  │  Layer 1: Link (Device)                                                  ||
|  │  ┌────────────────────────────────────────────────────────────────────┐ ||
|  │  │  net_device, dev_queue_xmit, netif_receive_skb, qdisc               │ ||
|  │  └────────────────────────────────────────────────────────────────────┘ ||
|  │                              │ net_device_ops                            ||
|  │                              ▼                                           ||
|  │  Layer 0: Physical (Driver)                                              ||
|  │  ┌────────────────────────────────────────────────────────────────────┐ ||
|  │  │  ndo_start_xmit, napi_poll, hardware DMA                            │ ||
|  │  └────────────────────────────────────────────────────────────────────┘ ||
|  │                                                                          ||
|  └─────────────────────────────────────────────────────────────────────────┘|
|                                                                              |
|  特点：每层只与相邻层交互，通过定义良好的接口                                |
|                                                                              |
+=============================================================================+
```

**中文说明：**

Linux 网络子系统的分层架构类似 OSI 模型：
- **应用层**：用户进程通过系统调用访问
- **Socket 接口层**：提供 BSD socket API
- **传输层**：TCP/UDP 协议实现
- **网络层**：IP 路由和分片
- **链路层**：设备抽象和流量控制
- **物理层**：驱动程序与硬件交互

---

```
PATTERN 2: EVENT-DRIVEN / CALLBACK (事件驱动/回调)
+=============================================================================+
|                                                                              |
|  CALLBACK CHAIN IN RECEIVE PATH                                              |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  Hardware Interrupt                                                      │ |
|  │      │                                                                   │ |
|  │      │ ┌─────────────────────────────────────────────┐                   │ |
|  │      └►│ Interrupt Handler                           │                   │ |
|  │        │ napi_schedule(&adapter->napi)               │                   │ |
|  │        └─────────────────────────────────────────────┘                   │ |
|  │                    │                                                     │ |
|  │                    ▼                                                     │ |
|  │        ┌─────────────────────────────────────────────┐                   │ |
|  │        │ NAPI Poll Callback                          │                   │ |
|  │        │ driver->napi.poll(napi, budget)             │                   │ |
|  │        │   → e1000_clean_rx_irq()                    │                   │ |
|  │        └─────────────────────────────────────────────┘                   │ |
|  │                    │                                                     │ |
|  │                    ▼                                                     │ |
|  │        ┌─────────────────────────────────────────────┐                   │ |
|  │        │ Protocol Handler Callback                   │                   │ |
|  │        │ ptype->func(skb, dev, ptype, orig_dev)      │                   │ |
|  │        │   → ip_rcv()                                │                   │ |
|  │        └─────────────────────────────────────────────┘                   │ |
|  │                    │                                                     │ |
|  │                    ▼                                                     │ |
|  │        ┌─────────────────────────────────────────────┐                   │ |
|  │        │ Transport Handler Callback                  │                   │ |
|  │        │ ipprot->handler(skb)                        │                   │ |
|  │        │   → tcp_v4_rcv()                            │                   │ |
|  │        └─────────────────────────────────────────────┘                   │ |
|  │                    │                                                     │ |
|  │                    ▼                                                     │ |
|  │        ┌─────────────────────────────────────────────┐                   │ |
|  │        │ Socket Data Ready Callback                  │                   │ |
|  │        │ sk->sk_data_ready(sk, len)                  │                   │ |
|  │        │   → sock_def_readable()                     │                   │ |
|  │        └─────────────────────────────────────────────┘                   │ |
|  │                    │                                                     │ |
|  │                    ▼                                                     │ |
|  │        ┌─────────────────────────────────────────────┐                   │ |
|  │        │ Wake up waiting process                     │                   │ |
|  │        │ wake_up_interruptible(sk->sk_sleep)         │                   │ |
|  │        └─────────────────────────────────────────────┘                   │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  每一步都是通过函数指针回调，实现解耦                                        |
|                                                                              |
+=============================================================================+
```

**中文说明：**

接收路径完全由回调驱动：
1. 硬件中断 → NAPI 调度
2. NAPI poll 回调 → 驱动处理
3. 协议处理器回调 → IP 层处理
4. 传输层回调 → TCP/UDP 处理
5. Socket 数据就绪回调 → 唤醒进程

---

```
PATTERN 3: FINITE STATE MACHINE (有限状态机)
+=============================================================================+
|                                                                              |
|  TCP STATE MACHINE (from tcp.c)                                              |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │                         ┌───────────────┐                                │ |
|  │                         │   TCP_CLOSE   │                                │ |
|  │                         │   (Initial)   │                                │ |
|  │                         └───────┬───────┘                                │ |
|  │                                 │                                        │ |
|  │          ┌──────────────────────┼──────────────────────┐                 │ |
|  │          │ Active Open          │ Passive Open         │                 │ |
|  │          │ connect()            │ listen()             │                 │ |
|  │          ▼                      ▼                      │                 │ |
|  │  ┌───────────────┐      ┌───────────────┐              │                 │ |
|  │  │ TCP_SYN_SENT  │      │  TCP_LISTEN   │              │                 │ |
|  │  └───────┬───────┘      └───────┬───────┘              │                 │ |
|  │          │                      │ rcv SYN              │                 │ |
|  │          │ rcv SYN+ACK          ▼                      │                 │ |
|  │          │              ┌───────────────┐              │                 │ |
|  │          │              │ TCP_SYN_RECV  │              │                 │ |
|  │          │              └───────┬───────┘              │                 │ |
|  │          │                      │ rcv ACK              │                 │ |
|  │          ▼                      ▼                      │                 │ |
|  │          └──────────────►┌───────────────┐◄────────────┘                 │ |
|  │                          │TCP_ESTABLISHED│                               │ |
|  │                          │ (Data Flow)   │                               │ |
|  │                          └───────┬───────┘                               │ |
|  │                                  │                                       │ |
|  │           ┌──────────────────────┴──────────────────────┐                │ |
|  │           │ Active Close                Passive Close   │                │ |
|  │           │ close()                     rcv FIN         │                │ |
|  │           ▼                             ▼               │                │ |
|  │   ┌───────────────┐             ┌───────────────┐       │                │ |
|  │   │TCP_FIN_WAIT1  │             │TCP_CLOSE_WAIT │       │                │ |
|  │   └───────┬───────┘             └───────┬───────┘       │                │ |
|  │           │ rcv ACK                     │ close()       │                │ |
|  │           ▼                             ▼               │                │ |
|  │   ┌───────────────┐             ┌───────────────┐       │                │ |
|  │   │TCP_FIN_WAIT2  │             │ TCP_LAST_ACK  │       │                │ |
|  │   └───────┬───────┘             └───────┬───────┘       │                │ |
|  │           │ rcv FIN                     │ rcv ACK       │                │ |
|  │           ▼                             ▼               │                │ |
|  │   ┌───────────────┐                     │               │                │ |
|  │   │TCP_TIME_WAIT  │◄────────────────────┘               │                │ |
|  │   │ (2MSL wait)   │                                     │                │ |
|  │   └───────┬───────┘                                     │                │ |
|  │           │ timeout                                     │                │ |
|  │           ▼                                             │                │ |
|  │   ┌───────────────┐                                     │                │ |
|  │   │   TCP_CLOSE   │◄────────────────────────────────────┘                │ |
|  │   └───────────────┘                                                      │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  Implementation in tcp.c:                                                    |
|  • tcp_set_state(sk, new_state)  - 状态转换函数                              |
|  • new_state[16] array           - 状态转换表                                |
|  • sk->sk_state                  - 当前状态存储                              |
|                                                                              |
+=============================================================================+
```

**中文说明：**

TCP 状态机是网络子系统最经典的 FSM 实现：
- 11 个状态，严格按 RFC 793 定义
- 状态转换由网络事件和用户操作触发
- `tcp_set_state()` 是唯一的状态修改入口
- `new_state[]` 数组编码了有效的状态转换

---

```
PATTERN 4: PLUGIN / REGISTRY (插件/注册)
+=============================================================================+
|                                                                              |
|  PROTOCOL REGISTRATION                                                       |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  Registry (Protocol Handler Table)                                       │ |
|  │  ┌────────────────────────────────────────────────────────────────┐    │ |
|  │  │  inet_protos[]                                                  │    │ |
|  │  │  ┌─────────┬─────────┬─────────┬─────────┐                      │    │ |
|  │  │  │ [6]=TCP │ [17]=UDP│ [1]=ICMP│ [132]=..│                      │    │ |
|  │  │  └─────────┴─────────┴─────────┴─────────┘                      │    │ |
|  │  └────────────────────────────────────────────────────────────────┘    │ |
|  │                  ▲                                                      │ |
|  │                  │ inet_add_protocol()                                  │ |
|  │                  │                                                      │ |
|  │  ┌───────────────┴───────────────┐                                      │ |
|  │  │                               │                                      │ |
|  │  ▼                               ▼                                      │ |
|  │  ┌─────────────────┐     ┌─────────────────┐                            │ |
|  │  │ tcp_protocol    │     │ udp_protocol    │                            │ |
|  │  │ .handler=       │     │ .handler=       │                            │ |
|  │  │   tcp_v4_rcv    │     │   udp_rcv       │                            │ |
|  │  └─────────────────┘     └─────────────────┘                            │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  CONGESTION CONTROL REGISTRATION (from tcp.c)                                |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  tcp_init():                                                             │ |
|  │      tcp_register_congestion_control(&tcp_reno);                        │ |
|  │                                                                          │ |
|  │  Registry (Congestion Control List)                                      │ |
|  │  ┌────────────────────────────────────────────────────────────────┐    │ |
|  │  │  tcp_cong_list (linked list)                                    │    │ |
|  │  │  ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐         │    │ |
|  │  │  │  reno   │──►│  cubic  │──►│  bbr    │──►│  ...    │         │    │ |
|  │  │  └─────────┘   └─────────┘   └─────────┘   └─────────┘         │    │ |
|  │  └────────────────────────────────────────────────────────────────┘    │ |
|  │                                                                          │ |
|  │  用户可以通过 socket 选项选择:                                           │ |
|  │  setsockopt(fd, IPPROTO_TCP, TCP_CONGESTION, "cubic", 5);               │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  DRIVER REGISTRATION                                                         |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  Driver init:                                                            │ |
|  │      alloc_etherdev()           // 分配网络设备                          │ |
|  │      dev->netdev_ops = &e1000_netdev_ops;                               │ |
|  │      register_netdev(dev);      // 注册到系统                            │ |
|  │                                                                          │ |
|  │  Registry (Device List)                                                  │ |
|  │  ┌────────────────────────────────────────────────────────────────┐    │ |
|  │  │  net->dev_base_head (per-namespace device list)                 │    │ |
|  │  │  ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐         │    │ |
|  │  │  │   lo    │──►│  eth0   │──►│  eth1   │──►│  ...    │         │    │ |
|  │  │  └─────────┘   └─────────┘   └─────────┘   └─────────┘         │    │ |
|  │  └────────────────────────────────────────────────────────────────┘    │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

插件/注册模式贯穿整个网络子系统：
- **协议注册**：`inet_add_protocol()` 注册 TCP/UDP/ICMP 处理器
- **拥塞控制注册**：`tcp_register_congestion_control()` 注册算法
- **驱动注册**：`register_netdev()` 注册网络设备

这种模式实现了开闭原则：对扩展开放，对修改封闭。

---

## 2. 核心数据结构

```
CORE DATA STRUCTURES
+=============================================================================+
|                                                                              |
|  STRUCT NET_DEVICE - 网络设备抽象                                            |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  struct net_device {                                                     │ |
|  │      char name[IFNAMSIZ];          // 设备名 "eth0"                      │ |
|  │      unsigned int flags;           // IFF_UP, IFF_RUNNING, ...          │ |
|  │      unsigned int mtu;             // Maximum Transfer Unit              │ |
|  │      unsigned char dev_addr[MAX_ADDR_LEN];  // MAC address              │ |
|  │                                                                          │ |
|  │      // 操作函数表                                                       │ |
|  │      const struct net_device_ops *netdev_ops;                           │ |
|  │                                                                          │ |
|  │      // NAPI 支持                                                        │ |
|  │      struct napi_struct *napi;                                          │ |
|  │                                                                          │ |
|  │      // 流量控制                                                         │ |
|  │      struct Qdisc *qdisc;          // 队列调度器                         │ |
|  │                                                                          │ |
|  │      // 统计信息                                                         │ |
|  │      struct net_device_stats stats;                                     │ |
|  │                                                                          │ |
|  │      // 网络命名空间                                                     │ |
|  │      struct net *nd_net;                                                │ |
|  │  };                                                                      │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  STRUCT SK_BUFF - 网络数据包缓冲                                             |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  struct sk_buff {                                                        │ |
|  │      // 链表指针                                                         │ |
|  │      struct sk_buff *next, *prev;                                       │ |
|  │      struct sk_buff_head *list;                                         │ |
|  │                                                                          │ |
|  │      // 关联的 socket                                                    │ |
|  │      struct sock *sk;                                                   │ |
|  │                                                                          │ |
|  │      // 时间戳                                                           │ |
|  │      ktime_t tstamp;                                                    │ |
|  │                                                                          │ |
|  │      // 网络设备                                                         │ |
|  │      struct net_device *dev;                                            │ |
|  │                                                                          │ |
|  │      // 数据指针                                                         │ |
|  │      unsigned char *head;          // 缓冲区起始                         │ |
|  │      unsigned char *data;          // 数据起始                           │ |
|  │      unsigned char *tail;          // 数据结束                           │ |
|  │      unsigned char *end;           // 缓冲区结束                         │ |
|  │                                                                          │ |
|  │      // 传输层头部                                                       │ |
|  │      union {                                                             │ |
|  │          struct tcphdr *th;                                             │ |
|  │          struct udphdr *uh;                                             │ |
|  │      } transport_header;                                                │ |
|  │                                                                          │ |
|  │      // 网络层头部                                                       │ |
|  │      union {                                                             │ |
|  │          struct iphdr *iph;                                             │ |
|  │          struct ipv6hdr *ipv6h;                                         │ |
|  │      } network_header;                                                  │ |
|  │                                                                          │ |
|  │      // 引用计数                                                         │ |
|  │      atomic_t users;                                                    │ |
|  │  };                                                                      │ |
|  │                                                                          │ |
|  │  SK_BUFF MEMORY LAYOUT:                                                  │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐    │ |
|  │  │ head                                                             │    │ |
|  │  │  │  headroom (for header prepending)                             │    │ |
|  │  │  ▼                                                               │    │ |
|  │  │ data ──────────────────────────────────────────────────────────  │    │ |
|  │  │  │  [Ethernet Header]                                            │    │ |
|  │  │  │  [IP Header]                                                  │    │ |
|  │  │  │  [TCP/UDP Header]                                             │    │ |
|  │  │  │  [Payload]                                                    │    │ |
|  │  │  ▼                                                               │    │ |
|  │  │ tail ──────────────────────────────────────────────────────────  │    │ |
|  │  │  │  tailroom (for trailer appending)                             │    │ |
|  │  │  ▼                                                               │    │ |
|  │  │ end                                                              │    │ |
|  │  └─────────────────────────────────────────────────────────────────┘    │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

```
STRUCT SOCK / TCP_SOCK - Socket 核心结构
+=============================================================================+
|                                                                              |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  SOCKET STRUCTURE HIERARCHY:                                             │ |
|  │                                                                          │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐    │ |
|  │  │  struct tcp_sock {              // TCP-specific                  │    │ |
|  │  │      struct inet_connection_sock {  // Connection-oriented      │    │ |
|  │  │          struct inet_sock {         // IPv4/IPv6                │    │ |
|  │  │              struct sock {          // Generic socket           │    │ |
|  │  │                  // ... base socket fields ...                  │    │ |
|  │  │              };                                                 │    │ |
|  │  │              // ... inet fields ...                             │    │ |
|  │  │          };                                                     │    │ |
|  │  │          // ... connection fields ...                           │    │ |
|  │  │      };                                                         │    │ |
|  │  │      // ... TCP-specific fields ...                             │    │ |
|  │  │  };                                                              │    │ |
|  │  └─────────────────────────────────────────────────────────────────┘    │ |
|  │                                                                          │ |
|  │  STRUCT SOCK (base):                                                     │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐   │ |
|  │  │  struct sock {                                                    │   │ |
|  │  │      unsigned short sk_family;      // AF_INET, AF_INET6         │   │ |
|  │  │      unsigned char sk_state;        // TCP_ESTABLISHED, ...      │   │ |
|  │  │      unsigned char sk_protocol;     // IPPROTO_TCP, ...          │   │ |
|  │  │                                                                   │   │ |
|  │  │      struct sk_buff_head sk_receive_queue;  // 接收队列          │   │ |
|  │  │      struct sk_buff_head sk_write_queue;    // 发送队列          │   │ |
|  │  │                                                                   │   │ |
|  │  │      int sk_sndbuf;                 // 发送缓冲区大小            │   │ |
|  │  │      int sk_rcvbuf;                 // 接收缓冲区大小            │   │ |
|  │  │                                                                   │   │ |
|  │  │      socket_lock_t sk_lock;         // socket 锁                 │   │ |
|  │  │      atomic_t sk_refcnt;            // 引用计数                  │   │ |
|  │  │                                                                   │   │ |
|  │  │      void (*sk_data_ready)(struct sock *sk, int len);            │   │ |
|  │  │      void (*sk_state_change)(struct sock *sk);                   │   │ |
|  │  │                                                                   │   │ |
|  │  │      struct proto *sk_prot;         // 协议操作表                │   │ |
|  │  │  };                                                               │   │ |
|  │  └──────────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  STRUCT TCP_SOCK (TCP-specific):                                         │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐   │ |
|  │  │  struct tcp_sock {                                                │   │ |
|  │  │      // 序列号                                                    │   │ |
|  │  │      u32 snd_una;               // 最小未确认序列号              │   │ |
|  │  │      u32 snd_nxt;               // 下一个发送序列号              │   │ |
|  │  │      u32 rcv_nxt;               // 期望接收的下一个序列号        │   │ |
|  │  │      u32 copied_seq;            // 已拷贝到用户空间的序列号      │   │ |
|  │  │                                                                   │   │ |
|  │  │      // 窗口管理                                                  │   │ |
|  │  │      u32 snd_wnd;               // 发送窗口                      │   │ |
|  │  │      u32 rcv_wnd;               // 接收窗口                      │   │ |
|  │  │                                                                   │   │ |
|  │  │      // 拥塞控制                                                  │   │ |
|  │  │      u32 snd_cwnd;              // 拥塞窗口                      │   │ |
|  │  │      u32 snd_ssthresh;          // 慢启动阈值                    │   │ |
|  │  │                                                                   │   │ |
|  │  │      // RTT 测量                                                  │   │ |
|  │  │      u32 srtt;                  // 平滑 RTT                      │   │ |
|  │  │      u32 mdev;                  // RTT 偏差                      │   │ |
|  │  │                                                                   │   │ |
|  │  │      // 重传                                                      │   │ |
|  │  │      struct timer_list retransmit_timer;                         │   │ |
|  │  │      u8 retransmits;            // 重传次数                      │   │ |
|  │  │  };                                                               │   │ |
|  │  └──────────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

核心数据结构采用嵌套继承模式：
- **`net_device`**：抽象网络设备，包含操作函数表和状态
- **`sk_buff`**：网络数据包的容器，包含数据指针和元信息
- **`sock` 层次结构**：
  - `sock`：通用 socket 基类
  - `inet_sock`：Internet 协议扩展
  - `inet_connection_sock`：面向连接的扩展
  - `tcp_sock`：TCP 特有字段（序列号、窗口、拥塞控制）

---

## 3. 控制流组织

```
CONTROL FLOW ORGANIZATION
+=============================================================================+
|                                                                              |
|  RECEIVE PATH (接收路径)                                                     |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  HARDWARE                                                                │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  NIC receives packet → DMA to ring buffer → raise IRQ            │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                              │                                           │ |
|  │                              ▼                                           │ |
|  │  INTERRUPT HANDLER                                                       │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  e1000_intr() {                                                   │  │ |
|  │  │      if (rx_interrupt)                                            │  │ |
|  │  │          napi_schedule(&adapter->napi);  // 调度 NAPI            │  │ |
|  │  │  }                                                                │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                              │                                           │ |
|  │                              ▼                                           │ |
|  │  NAPI POLL (Softirq context)                                             │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  e1000_clean_rx_irq() {                                           │  │ |
|  │  │      while (budget-- && packets_available) {                      │  │ |
|  │  │          skb = fetch_from_ring_buffer();                          │  │ |
|  │  │          skb->protocol = eth_type_trans(skb, dev);               │  │ |
|  │  │          netif_receive_skb(skb);  // 传递给网络核心              │  │ |
|  │  │      }                                                            │  │ |
|  │  │  }                                                                │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                              │                                           │ |
|  │                              ▼                                           │ |
|  │  NETWORK CORE                                                            │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  netif_receive_skb() {                                            │  │ |
|  │  │      // Deliver to packet type handlers                           │  │ |
|  │  │      list_for_each_entry(ptype, &ptype_all, list) {               │  │ |
|  │  │          ptype->func(skb, dev, ptype, orig_dev);                  │  │ |
|  │  │      }                                                            │  │ |
|  │  │      // Find protocol handler (e.g., ip_rcv)                      │  │ |
|  │  │      pt = ptype_base[skb->protocol];                              │  │ |
|  │  │      pt->func(skb, dev, pt, orig_dev);                            │  │ |
|  │  │  }                                                                │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                              │                                           │ |
|  │                              ▼                                           │ |
|  │  IP LAYER                                                                │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  ip_rcv() → ip_rcv_finish() {                                     │  │ |
|  │  │      // Route lookup                                              │  │ |
|  │  │      ip_route_input(skb, ...);                                    │  │ |
|  │  │      // Deliver to transport layer                                │  │ |
|  │  │      dst_input(skb);  // → ip_local_deliver()                    │  │ |
|  │  │  }                                                                │  │ |
|  │  │                                                                   │  │ |
|  │  │  ip_local_deliver_finish() {                                      │  │ |
|  │  │      ipprot = inet_protos[protocol];                              │  │ |
|  │  │      ipprot->handler(skb);  // → tcp_v4_rcv() or udp_rcv()       │  │ |
|  │  │  }                                                                │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                              │                                           │ |
|  │                              ▼                                           │ |
|  │  TCP LAYER                                                               │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  tcp_v4_rcv() {                                                   │  │ |
|  │  │      // Find socket                                               │  │ |
|  │  │      sk = __inet_lookup(skb->hash);                               │  │ |
|  │  │      // Process based on state                                    │  │ |
|  │  │      if (sk->sk_state == TCP_ESTABLISHED)                         │  │ |
|  │  │          tcp_rcv_established(sk, skb, ...);                       │  │ |
|  │  │      else                                                         │  │ |
|  │  │          tcp_rcv_state_process(sk, skb, ...);                     │  │ |
|  │  │  }                                                                │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                              │                                           │ |
|  │                              ▼                                           │ |
|  │  SOCKET LAYER                                                            │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  // Add to receive queue                                          │  │ |
|  │  │  skb_queue_tail(&sk->sk_receive_queue, skb);                      │  │ |
|  │  │  // Notify waiting process                                        │  │ |
|  │  │  sk->sk_data_ready(sk, len);                                      │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

```
SEND PATH (发送路径)
+=============================================================================+
|                                                                              |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  USER SPACE                                                              │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  write(fd, data, len)  or  send(fd, data, len, flags)            │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                              │ system call                               │ |
|  │                              ▼                                           │ |
|  │  SOCKET LAYER                                                            │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  tcp_sendmsg(sk, msg, size) {                                     │  │ |
|  │  │      lock_sock(sk);                                               │  │ |
|  │  │      while (size > 0) {                                           │  │ |
|  │  │          skb = sk_stream_alloc_skb(...);                          │  │ |
|  │  │          skb_entail(sk, skb);  // 添加到发送队列                  │  │ |
|  │  │          copy_from_user(skb, msg, copy);                          │  │ |
|  │  │      }                                                            │  │ |
|  │  │      tcp_push(sk, flags, ...);                                    │  │ |
|  │  │      release_sock(sk);                                            │  │ |
|  │  │  }                                                                │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                              │                                           │ |
|  │                              ▼                                           │ |
|  │  TCP OUTPUT                                                              │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  tcp_write_xmit() {                                               │  │ |
|  │  │      while ((skb = tcp_send_head(sk))) {                          │  │ |
|  │  │          // 检查窗口和拥塞                                        │  │ |
|  │  │          if (!tcp_snd_wnd_test(tp, skb, mss_now))                 │  │ |
|  │  │              break;                                               │  │ |
|  │  │          tcp_transmit_skb(sk, skb, 1, ...);                       │  │ |
|  │  │      }                                                            │  │ |
|  │  │  }                                                                │  │ |
|  │  │                                                                   │  │ |
|  │  │  tcp_transmit_skb() {                                             │  │ |
|  │  │      // Build TCP header                                          │  │ |
|  │  │      th = tcp_hdr(skb);                                           │  │ |
|  │  │      th->seq = htonl(tcb->seq);                                   │  │ |
|  │  │      // ...                                                       │  │ |
|  │  │      icsk->icsk_af_ops->queue_xmit(skb);  // → ip_queue_xmit()   │  │ |
|  │  │  }                                                                │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                              │                                           │ |
|  │                              ▼                                           │ |
|  │  IP LAYER                                                                │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  ip_queue_xmit(skb) {                                             │  │ |
|  │  │      // Route lookup                                              │  │ |
|  │  │      rt = ip_route_output(...);                                   │  │ |
|  │  │      // Build IP header                                           │  │ |
|  │  │      iph = ip_hdr(skb);                                           │  │ |
|  │  │      iph->saddr = rt->rt_src;                                     │  │ |
|  │  │      iph->daddr = rt->rt_dst;                                     │  │ |
|  │  │      // Send to device                                            │  │ |
|  │  │      ip_local_out(skb);  // → dst_output() → dev_queue_xmit()    │  │ |
|  │  │  }                                                                │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                              │                                           │ |
|  │                              ▼                                           │ |
|  │  DEVICE LAYER                                                            │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  dev_queue_xmit(skb) {                                            │  │ |
|  │  │      // Traffic control (qdisc)                                   │  │ |
|  │  │      q = dev->qdisc;                                              │  │ |
|  │  │      q->enqueue(skb, q);                                          │  │ |
|  │  │      // Trigger transmit                                          │  │ |
|  │  │      __qdisc_run(q);                                              │  │ |
|  │  │  }                                                                │  │ |
|  │  │                                                                   │  │ |
|  │  │  dev_hard_start_xmit(skb, dev) {                                  │  │ |
|  │  │      dev->netdev_ops->ndo_start_xmit(skb, dev);                   │  │ |
|  │  │  }                                                                │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                              │                                           │ |
|  │                              ▼                                           │ |
|  │  DRIVER                                                                  │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  e1000_xmit_frame(skb, dev) {                                     │  │ |
|  │  │      // DMA mapping                                               │  │ |
|  │  │      dma_addr = dma_map_single(...);                              │  │ |
|  │  │      // Write to TX ring                                          │  │ |
|  │  │      tx_ring->buffer[i].dma = dma_addr;                           │  │ |
|  │  │      // Notify hardware                                           │  │ |
|  │  │      writel(i, adapter->hw.hw_addr + E1000_TDT);                  │  │ |
|  │  │  }                                                                │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

**接收路径：**
1. 硬件中断 → NAPI 调度
2. 驱动 poll 获取 skb
3. `netif_receive_skb()` 分发到协议处理器
4. `ip_rcv()` 处理 IP 层
5. `tcp_v4_rcv()` 处理 TCP 层
6. 添加到 socket 接收队列，唤醒进程

**发送路径：**
1. `tcp_sendmsg()` 拷贝数据到 skb
2. `tcp_write_xmit()` 添加 TCP 头
3. `ip_queue_xmit()` 添加 IP 头
4. `dev_queue_xmit()` 流量控制
5. 驱动 `ndo_start_xmit()` DMA 发送

---

## 4. 扩展点与约束点

```
EXTENSION POINTS AND CONSTRAINTS
+=============================================================================+
|                                                                              |
|  EXTENSION POINTS (扩展点)                                                   |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  1. PROTOCOL MODULE REGISTRATION                                        │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  // 注册新的传输层协议                                        │   │ |
|  │     │  inet_add_protocol(&my_protocol, IPPROTO_MY);                 │   │ |
|  │     │                                                                │   │ |
|  │     │  // 注册新的 socket 类型                                      │   │ |
|  │     │  sock_register(&my_family_ops);                               │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  2. NIC DRIVER REGISTRATION                                             │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  // 注册新的网络设备                                          │   │ |
|  │     │  struct net_device *dev = alloc_etherdev(sizeof(priv));       │   │ |
|  │     │  dev->netdev_ops = &my_driver_ops;                            │   │ |
|  │     │  register_netdev(dev);                                        │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  3. CONGESTION CONTROL ALGORITHMS                                       │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  // 注册新的拥塞控制算法                                      │   │ |
|  │     │  tcp_register_congestion_control(&my_cong_ops);               │   │ |
|  │     │                                                                │   │ |
|  │     │  // 用户选择算法                                              │   │ |
|  │     │  setsockopt(fd, IPPROTO_TCP, TCP_CONGESTION, "myalg", 5);     │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  4. NETFILTER HOOKS                                                     │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  // 在数据包处理路径上注册钩子                                │   │ |
|  │     │  static struct nf_hook_ops my_hook = {                        │   │ |
|  │     │      .hook     = my_hook_func,                                │   │ |
|  │     │      .hooknum  = NF_INET_PRE_ROUTING,                         │   │ |
|  │     │      .priority = NF_IP_PRI_FIRST,                             │   │ |
|  │     │  };                                                           │   │ |
|  │     │  nf_register_hook(&my_hook);                                  │   │ |
|  │     │                                                                │   │ |
|  │     │  Hook points:                                                  │   │ |
|  │     │  ┌─────────────────────────────────────────────────────────┐  │   │ |
|  │     │  │  PRE_ROUTING → LOCAL_IN  → user process                 │  │   │ |
|  │     │  │       │                                                  │  │   │ |
|  │     │  │       ▼                                                  │  │   │ |
|  │     │  │   FORWARD ───────────────────────►                       │  │   │ |
|  │     │  │                                                          │  │   │ |
|  │     │  │  user process → LOCAL_OUT → POST_ROUTING                 │  │   │ |
|  │     │  └─────────────────────────────────────────────────────────┘  │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  5. TRAFFIC CONTROL (QDISC)                                             │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  // 注册新的队列调度器                                        │   │ |
|  │     │  register_qdisc(&my_qdisc_ops);                               │   │ |
|  │     │                                                                │   │ |
|  │     │  Built-in qdiscs: pfifo_fast, htb, tbf, sfq, fq_codel        │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  CONSTRAINTS (约束点)                                                        |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  1. CORE SK_BUFF DATA FLOW                                              │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  sk_buff 是数据流的核心，不能随意修改其格式                    │   │ |
|  │     │                                                                │   │ |
|  │     │  必须遵守的约定:                                               │   │ |
|  │     │  • head/data/tail/end 指针的语义                              │   │ |
|  │     │  • 引用计数 (skb->users)                                      │   │ |
|  │     │  • 协议头部的位置约定                                         │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  2. PROTOCOL STATE MACHINE CONSISTENCY                                  │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  TCP 状态机必须严格遵循 RFC 793                                │   │ |
|  │     │                                                                │   │ |
|  │     │  约束:                                                         │   │ |
|  │     │  • 状态只能通过 tcp_set_state() 修改                          │   │ |
|  │     │  • 转换必须符合 new_state[] 表                                │   │ |
|  │     │  • 每个状态有对应的超时和清理逻辑                             │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  3. CONCURRENT ACCESS PROTECTION                                        │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  所有共享资源必须有适当的锁保护                                │   │ |
|  │     │                                                                │   │ |
|  │     │  约束:                                                         │   │ |
|  │     │  • Socket 操作必须在 lock_sock() 下进行                       │   │ |
|  │     │  • 软中断上下文使用 bh_lock_sock()                            │   │ |
|  │     │  • RCU 保护的数据必须用 rcu_dereference() 访问                │   │ |
|  │     │  • 引用计数操作必须原子化                                     │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  4. LAYER INTERFACE STABILITY                                           │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  层间接口是稳定的，不能随意修改                                │   │ |
|  │     │                                                                │   │ |
|  │     │  稳定接口:                                                     │   │ |
|  │     │  • net_device_ops 结构                                        │   │ |
|  │     │  • proto 结构                                                 │   │ |
|  │     │  • netif_receive_skb() / dev_queue_xmit()                     │   │ |
|  │     │  • System call interface                                      │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

**扩展点：**
- 协议模块可通过 `inet_add_protocol()` 注册
- 驱动可通过 `register_netdev()` 注册
- 拥塞控制可通过 `tcp_register_congestion_control()` 注册
- Netfilter 提供 5 个标准钩子点
- 流量控制通过 qdisc 框架扩展

**约束点：**
- sk_buff 格式是固定的，必须遵守指针语义
- TCP 状态机必须严格遵循 RFC
- 并发访问必须有锁保护
- 层间接口必须稳定

---

## 5. 模式的代价和边界

```
COSTS AND BOUNDARIES OF PATTERNS
+=============================================================================+
|                                                                              |
|  PATTERN COSTS (模式代价)                                                    |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  LAYERED ARCHITECTURE                                                    │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  Benefit: Clean separation, maintainability                       │  │ |
|  │  │  Cost:    Each layer adds function call overhead                  │  │ |
|  │  │                                                                    │  │ |
|  │  │  Per-packet overhead:                                              │  │ |
|  │  │  tcp_sendmsg → tcp_transmit_skb → ip_queue_xmit → dev_queue_xmit  │  │ |
|  │  │        ↓              ↓               ↓               ↓           │  │ |
|  │  │   ~100 cycles   ~200 cycles    ~150 cycles    ~100 cycles         │  │ |
|  │  │                                                                    │  │ |
|  │  │  Total: ~500-1000 CPU cycles per packet through full stack        │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                                                                          │ |
|  │  CALLBACK/EVENT-DRIVEN                                                   │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  Benefit: Decoupling, extensibility                               │  │ |
|  │  │  Cost:    Indirect function calls (cache miss potential)          │  │ |
|  │  │                                                                    │  │ |
|  │  │  Each callback:                                                    │  │ |
|  │  │  • Function pointer dereference                                   │  │ |
|  │  │  • Potential instruction cache miss                               │  │ |
|  │  │  • Return prediction may fail                                     │  │ |
|  │  │                                                                    │  │ |
|  │  │  Mitigations in kernel:                                            │  │ |
|  │  │  • __builtin_expect() hints                                       │  │ |
|  │  │  • Inline common paths                                            │  │ |
|  │  │  • Branch prediction optimization                                 │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                                                                          │ |
|  │  CONCURRENCY PROTECTION                                                  │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  Benefit: Correctness, safety                                     │  │ |
|  │  │  Cost:    Lock contention, latency                                │  │ |
|  │  │                                                                    │  │ |
|  │  │  Socket lock (lock_sock):                                          │  │ |
|  │  │  • Blocks concurrent operations on same socket                    │  │ |
|  │  │  • Can cause priority inversion                                   │  │ |
|  │  │                                                                    │  │ |
|  │  │  RCU:                                                              │  │ |
|  │  │  • Read-side is cheap (几乎免费)                                  │  │ |
|  │  │  • Write-side is expensive (synchronize_rcu waits)                │  │ |
|  │  │                                                                    │  │ |
|  │  │  Per-CPU data:                                                     │  │ |
|  │  │  • Great scalability                                              │  │ |
|  │  │  • Memory overhead (N copies of data)                             │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                                                                          │ |
|  │  SK_BUFF MEMORY MANAGEMENT                                               │ |
|  │  ┌──────────────────────────────────────────────────────────────────┐  │ |
|  │  │  Benefit: Flexibility, zero-copy potential                        │  │ |
|  │  │  Cost:    Memory overhead per packet                              │  │ |
|  │  │                                                                    │  │ |
|  │  │  sizeof(struct sk_buff) ≈ 200+ bytes                              │  │ |
|  │  │  Plus: data buffer, shared info, fragments                        │  │ |
|  │  │                                                                    │  │ |
|  │  │  Small packets (e.g., TCP ACK 40 bytes):                          │  │ |
|  │  │  Metadata overhead > payload size                                  │  │ |
|  │  │                                                                    │  │ |
|  │  │  Mitigations:                                                      │  │ |
|  │  │  • sk_buff slab cache                                             │  │ |
|  │  │  • Clone instead of copy                                          │  │ |
|  │  │  • Segment offload (GSO/GRO)                                      │  │ |
|  │  └──────────────────────────────────────────────────────────────────┘  │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  PATTERN BOUNDARIES (模式边界)                                               |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  WHERE PATTERNS BREAK DOWN:                                              │ |
|  │                                                                          │ |
|  │  1. ULTRA-LOW LATENCY                                                   │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  Requirements: < 1μs per packet                               │   │ |
|  │     │  Problem: Kernel stack overhead too high                      │   │ |
|  │     │  Solution: Kernel bypass (DPDK, netmap, io_uring)             │   │ |
|  │     │                                                                │   │ |
|  │     │  Kernel stack: ~5-10μs per packet                             │   │ |
|  │     │  DPDK:         ~0.5-1μs per packet                            │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  2. EXTREME THROUGHPUT                                                   │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  Requirements: 100+ Gbps                                       │   │ |
|  │     │  Problem: CPU can't keep up with per-packet processing        │   │ |
|  │     │  Solution: Hardware offload, XDP, eBPF                        │   │ |
|  │     │                                                                │   │ |
|  │     │  100Gbps ≈ 148 million pps (min size packets)                 │   │ |
|  │     │  Per-packet budget: ~7ns (not achievable with full stack)     │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  3. SPECIALIZED PROTOCOLS                                                │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  Requirements: Non-IP protocols, custom framing               │   │ |
|  │     │  Problem: General stack may not fit                           │   │ |
|  │     │  Solution: Raw sockets, custom drivers                        │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  │  4. REAL-TIME GUARANTEES                                                │ |
|  │     ┌──────────────────────────────────────────────────────────────┐   │ |
|  │     │  Requirements: Bounded worst-case latency                     │   │ |
|  │     │  Problem: Locks and softirqs can cause unbounded delays       │   │ |
|  │     │  Solution: PREEMPT_RT patches, dedicated network cores        │   │ |
|  │     └──────────────────────────────────────────────────────────────┘   │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

**模式代价：**
- **分层架构**：每层调用增加 CPU 周期开销
- **回调/事件驱动**：间接调用可能导致缓存未命中
- **并发保护**：锁竞争增加延迟
- **sk_buff 内存管理**：元数据开销可能超过小包的数据量

**模式边界：**
- **超低延迟**（<1μs）：需要 DPDK 等内核旁路方案
- **极高吞吐**（100+Gbps）：需要硬件卸载和 XDP
- **特殊协议**：可能需要原始套接字或自定义驱动
- **实时保证**：需要 PREEMPT_RT 补丁
