# HOW｜架构策略

## 1. 动态检测

```
DYNAMIC INSTRUMENTATION
+=============================================================================+
|                                                                              |
|  THE CORE IDEA                                                               |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐    │ |
|  │  │                                                                  │    │ |
|  │  │  Static Instrumentation:                                         │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  1. Modify source code                                      │ │    │ |
|  │  │  │  2. Recompile kernel                                        │ │    │ |
|  │  │  │  3. Reboot server                                           │ │    │ |
|  │  │  │  4. Reproduce issue                                         │ │    │ |
|  │  │  │  5. Find more logging needed → goto 1                       │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Time: hours to days                                        │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  │  Dynamic Instrumentation:                                        │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  1. Attach probe (one command)                              │ │    │ |
|  │  │  │  2. See data immediately                                    │ │    │ |
|  │  │  │  3. Adjust probe → see new data                             │ │    │ |
|  │  │  │  4. No reboot, no rebuild                                   │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Time: seconds to minutes                                   │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  └─────────────────────────────────────────────────────────────────┘    │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  KPROBES: DYNAMIC KERNEL PROBES                                              |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐    │ |
|  │  │                                                                  │    │ |
|  │  │  HOW IT WORKS:                                                   │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Original function:                                         │ │    │ |
|  │  │  │  ┌──────────────────────────────────────────────────────┐  │ │    │ |
|  │  │  │  │  vfs_read:                                            │  │ │    │ |
|  │  │  │  │      0x1000:  push rbp         ◄── original first     │  │ │    │ |
|  │  │  │  │      0x1001:  mov rbp, rsp         instruction        │  │ │    │ |
|  │  │  │  │      0x1004:  ...                                     │  │ │    │ |
|  │  │  │  │                                                       │  │ │    │ |
|  │  │  │  └──────────────────────────────────────────────────────┘  │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  After kprobe registered:                                   │ │    │ |
|  │  │  │  ┌──────────────────────────────────────────────────────┐  │ │    │ |
|  │  │  │  │  vfs_read:                                            │  │ │    │ |
|  │  │  │  │      0x1000:  int3             ◄── breakpoint!        │  │ │    │ |
|  │  │  │  │      0x1001:  mov rbp, rsp         (triggers trap)    │  │ │    │ |
|  │  │  │  │      0x1004:  ...                                     │  │ │    │ |
|  │  │  │  │                                                       │  │ │    │ |
|  │  │  │  └──────────────────────────────────────────────────────┘  │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Execution flow:                                            │ │    │ |
|  │  │  │  ┌──────────────────────────────────────────────────────┐  │ │    │ |
|  │  │  │  │                                                       │  │ │    │ |
|  │  │  │  │  1. Code calls vfs_read()                             │  │ │    │ |
|  │  │  │  │  2. int3 triggers debug trap                          │  │ │    │ |
|  │  │  │  │  3. Kprobe handler called                             │  │ │    │ |
|  │  │  │  │     → Your probe function runs                        │  │ │    │ |
|  │  │  │  │     → Can access arguments, registers                 │  │ │    │ |
|  │  │  │  │  4. Original instruction executed                     │  │ │    │ |
|  │  │  │  │  5. Continue normal execution                         │  │ │    │ |
|  │  │  │  │                                                       │  │ │    │ |
|  │  │  │  └──────────────────────────────────────────────────────┘  │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  │  EXAMPLE: Trace all calls to do_sys_open                         │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  # Using trace-cmd                                          │ │    │ |
|  │  │  │  trace-cmd record -p function -l do_sys_open                │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  # Using bpftrace                                           │ │    │ |
|  │  │  │  bpftrace -e 'kprobe:do_sys_open { printf("%s\n", comm); }'│ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  └─────────────────────────────────────────────────────────────────┘    │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  UPROBES: USER-SPACE PROBES                                                  |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐    │ |
|  │  │                                                                  │    │ |
|  │  │  Same concept, applied to user-space:                            │    │ |
|  │  │                                                                  │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  # Trace malloc calls in any process                        │ │    │ |
|  │  │  │  bpftrace -e 'uprobe:/lib/x86_64-linux-gnu/libc.so.6:malloc │ │    │ |
|  │  │  │               { printf("%s malloc(%d)\n", comm, arg0); }'   │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  # Trace function in your app                               │ │    │ |
|  │  │  │  bpftrace -e 'uprobe:/path/to/myapp:process_request         │ │    │ |
|  │  │  │               { printf("Request processed\n"); }'           │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  │  Works by:                                                       │    │ |
|  │  │  • Modifying the executable's memory pages                       │    │ |
|  │  │  • Inserting breakpoint at function entry                        │    │ |
|  │  │  • Trap handled by kernel, runs your code                        │    │ |
|  │  │                                                                  │    │ |
|  │  └─────────────────────────────────────────────────────────────────┘    │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

**动态检测**：

**核心思想**：

**静态检测**：
1. 修改源代码
2. 重新编译内核
3. 重启服务器
4. 重现问题
5. 发现需要更多日志 → 重复
- 时间：数小时到数天

**动态检测**：
1. 附加探针（一条命令）
2. 立即看到数据
3. 调整探针 → 看到新数据
4. 无需重启，无需重建
- 时间：数秒到数分钟

**Kprobes：动态内核探针**

工作原理：
1. 原始函数第一条指令被替换为 int3（断点）
2. 代码调用 vfs_read()
3. int3 触发调试陷阱
4. Kprobe 处理器被调用 → 你的探针函数运行
5. 原始指令执行
6. 继续正常执行

**Uprobes：用户空间探针**
- 相同概念，应用于用户空间
- 修改可执行文件的内存页
- 在函数入口插入断点

---

## 2. 低侵入设计

```
LOW-INTRUSION DESIGN
+=============================================================================+
|                                                                              |
|  DESIGN PRINCIPLES                                                           |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐    │ |
|  │  │                                                                  │    │ |
|  │  │  1. ZERO OVERHEAD WHEN DISABLED                                  │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Goal: Production code shouldn't pay for tracing it        │ │    │ |
|  │  │  │        doesn't use                                          │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Techniques:                                                │ │    │ |
|  │  │  │  • Static keys/jump labels (NOP when disabled)              │ │    │ |
|  │  │  │  • No function calls when not tracing                       │ │    │ |
|  │  │  │  • No memory allocation for trace data                      │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  │  2. MINIMAL LOCKING                                              │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Problem: Locks cause contention under load                 │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Bad design:                                                │ │    │ |
|  │  │  │  ┌────────────────────────────────────────────────────────┐│ │    │ |
|  │  │  │  │  spin_lock(&global_trace_lock);                         ││ │    │ |
|  │  │  │  │  write_trace_event(...);                                ││ │    │ |
|  │  │  │  │  spin_unlock(&global_trace_lock);                       ││ │    │ |
|  │  │  │  │                                                         ││ │    │ |
|  │  │  │  │  → All CPUs contend for one lock!                       ││ │    │ |
|  │  │  │  └────────────────────────────────────────────────────────┘│ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Good design (Linux ring buffer):                           │ │    │ |
|  │  │  │  ┌────────────────────────────────────────────────────────┐│ │    │ |
|  │  │  │  │  buffer = per_cpu_ptr(trace_buffer, cpu);               ││ │    │ |
|  │  │  │  │  // No lock needed - only this CPU writes here          ││ │    │ |
|  │  │  │  │  ring_buffer_write(buffer, event);                      ││ │    │ |
|  │  │  │  │                                                         ││ │    │ |
|  │  │  │  │  → Lockless for writes (99% of operations)              ││ │    │ |
|  │  │  │  └────────────────────────────────────────────────────────┘│ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  │  3. FIXED MEMORY                                                 │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Problem: Allocation can:                                   │ │    │ |
|  │  │  │  • Fail under memory pressure                               │ │    │ |
|  │  │  │  • Cause more memory pressure                               │ │    │ |
|  │  │  │  • Introduce latency                                        │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Solution: Pre-allocated ring buffer                        │ │    │ |
|  │  │  │  ┌────────────────────────────────────────────────────────┐│ │    │ |
|  │  │  │  │                                                         ││ │    │ |
|  │  │  │  │  ┌─────────────────────────────────────────────────┐   ││ │    │ |
|  │  │  │  │  │ event │ event │ event │ ... │ event │ (write) │   ││ │    │ |
|  │  │  │  │  └─────────────────────────────────────────────────┘   ││ │    │ |
|  │  │  │  │                         ▲                     │         ││ │    │ |
|  │  │  │  │                         └─────────────────────┘         ││ │    │ |
|  │  │  │  │                         wraps around                    ││ │    │ |
|  │  │  │  │                                                         ││ │    │ |
|  │  │  │  │  • Fixed size (configurable, e.g., 1MB per CPU)         ││ │    │ |
|  │  │  │  │  • Old events overwritten when full                     ││ │    │ |
|  │  │  │  │  • Never fails, never allocates                         ││ │    │ |
|  │  │  │  │                                                         ││ │    │ |
|  │  │  │  └────────────────────────────────────────────────────────┘│ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  │  4. SAFE FAILURE                                                 │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Tracing NEVER crashes the system:                          │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  • Buffer full → overwrite oldest (never block)             │ │    │ |
|  │  │  │  • Probe error → disable probe, log warning                 │ │    │ |
|  │  │  │  • BPF program invalid → rejected at load time              │ │    │ |
|  │  │  │  • User-space consumer slow → drop events                   │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Priority: System stability > trace completeness            │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  └─────────────────────────────────────────────────────────────────┘    │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  TRACEPOINT DESIGN                                                           |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐    │ |
|  │  │                                                                  │    │ |
|  │  │  Static tracepoints = planned instrumentation points             │    │ |
|  │  │                                                                  │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  // Definition (in header)                                  │ │    │ |
|  │  │  │  TRACE_EVENT(sched_switch,                                  │ │    │ |
|  │  │  │      TP_PROTO(struct task_struct *prev,                     │ │    │ |
|  │  │  │               struct task_struct *next),                    │ │    │ |
|  │  │  │      TP_ARGS(prev, next),                                   │ │    │ |
|  │  │  │      TP_STRUCT__entry(                                      │ │    │ |
|  │  │  │          __field(pid_t, prev_pid)                           │ │    │ |
|  │  │  │          __field(pid_t, next_pid)                           │ │    │ |
|  │  │  │      ),                                                     │ │    │ |
|  │  │  │      TP_fast_assign(                                        │ │    │ |
|  │  │  │          __entry->prev_pid = prev->pid;                     │ │    │ |
|  │  │  │          __entry->next_pid = next->pid;                     │ │    │ |
|  │  │  │      ),                                                     │ │    │ |
|  │  │  │      TP_printk("prev=%d next=%d",                           │ │    │ |
|  │  │  │                __entry->prev_pid, __entry->next_pid)        │ │    │ |
|  │  │  │  );                                                         │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  // Usage (in scheduler code)                               │ │    │ |
|  │  │  │  trace_sched_switch(prev, next);                            │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  │  Benefits:                                                       │    │ |
|  │  │  • Stable API (won't change between kernel versions)             │    │ |
|  │  │  • Self-documenting (format known at compile time)               │    │ |
|  │  │  • Lower overhead than kprobes                                   │    │ |
|  │  │  • Can be used by ftrace, perf, BPF                              │    │ |
|  │  │                                                                  │    │ |
|  │  └─────────────────────────────────────────────────────────────────┘    │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

**低侵入设计**：

**设计原则**：

1. **禁用时零开销**
   - 目标：生产代码不应为不使用的追踪付出代价
   - 技术：静态键/跳转标签（禁用时为 NOP）

2. **最小锁定**
   - 问题：锁在负载下导致争用
   - 坏设计：全局追踪锁，所有 CPU 争用一个锁
   - 好设计：Per-CPU 缓冲区，写入无锁

3. **固定内存**
   - 问题：分配可能失败、导致内存压力、引入延迟
   - 解决方案：预分配环形缓冲区
   - 固定大小，旧事件被覆盖，从不失败，从不分配

4. **安全失败**
   - 追踪永远不会崩溃系统
   - 缓冲区满 → 覆盖最旧的
   - 探针错误 → 禁用探针
   - BPF 程序无效 → 加载时拒绝
   - 优先级：系统稳定性 > 追踪完整性

**Tracepoint 设计**：
- 静态 tracepoints = 计划的检测点
- 稳定 API（内核版本之间不会改变）
- 自文档化（格式在编译时已知）
- 比 kprobes 开销更低

---

## 3. 事件生命周期

```
EVENT LIFECYCLE
+=============================================================================+
|                                                                              |
|  FROM EVENT TO USER-SPACE                                                    |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐    │ |
|  │  │                                                                  │    │ |
|  │  │  1. EVENT OCCURS                                                 │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Kernel code executes:                                      │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  void schedule(void) {                                      │ │    │ |
|  │  │  │      ...                                                    │ │    │ |
|  │  │  │      // Event happens here                                  │ │    │ |
|  │  │  │      trace_sched_switch(prev, next);  ◄── trigger point     │ │    │ |
|  │  │  │      ...                                                    │ │    │ |
|  │  │  │  }                                                          │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                              │                                   │    │ |
|  │  │                              ▼                                   │    │ |
|  │  │  2. CHECK IF ENABLED                                             │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  // Expands to static branch                                │ │    │ |
|  │  │  │  if (static_branch_unlikely(&__tracepoint_sched_switch)) {  │ │    │ |
|  │  │  │      // Only executed if tracepoint enabled                 │ │    │ |
|  │  │  │      __tracepoint_iter_sched_switch(...);                   │ │    │ |
|  │  │  │  }                                                          │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  If disabled: just a NOP, ~0 overhead                       │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                              │                                   │    │ |
|  │  │                              ▼ (if enabled)                      │    │ |
|  │  │  3. CALL REGISTERED PROBES                                       │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Multiple consumers can attach:                             │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  ┌─────────────────────────────────────────────────────┐   │ │    │ |
|  │  │  │  │  tracepoint: sched_switch                            │   │ │    │ |
|  │  │  │  │       │                                              │   │ │    │ |
|  │  │  │  │       ├──► ftrace probe (function tracer)            │   │ │    │ |
|  │  │  │  │       ├──► perf probe (sampling)                     │   │ │    │ |
|  │  │  │  │       └──► BPF program                               │   │ │    │ |
|  │  │  │  │                                                      │   │ │    │ |
|  │  │  │  └─────────────────────────────────────────────────────┘   │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                              │                                   │    │ |
|  │  │                              ▼                                   │    │ |
|  │  │  4. WRITE TO RING BUFFER                                         │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  For ftrace:                                                │ │    │ |
|  │  │  │  ┌─────────────────────────────────────────────────────┐   │ │    │ |
|  │  │  │  │                                                      │   │ │    │ |
|  │  │  │  │  ring_buffer_lock_reserve(buffer, size);             │   │ │    │ |
|  │  │  │  │  event = ring_buffer_event_data(event);              │   │ │    │ |
|  │  │  │  │  // Fill in event fields                             │   │ │    │ |
|  │  │  │  │  event->timestamp = local_clock();                   │   │ │    │ |
|  │  │  │  │  event->prev_pid = prev->pid;                        │   │ │    │ |
|  │  │  │  │  event->next_pid = next->pid;                        │   │ │    │ |
|  │  │  │  │  ring_buffer_unlock_commit(buffer, event);           │   │ │    │ |
|  │  │  │  │                                                      │   │ │    │ |
|  │  │  │  └─────────────────────────────────────────────────────┘   │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  For BPF:                                                   │ │    │ |
|  │  │  │  ┌─────────────────────────────────────────────────────┐   │ │    │ |
|  │  │  │  │                                                      │   │ │    │ |
|  │  │  │  │  // BPF program runs, can:                           │   │ │    │ |
|  │  │  │  │  bpf_perf_event_output(...);  // send to user        │   │ │    │ |
|  │  │  │  │  map_update_elem(...);        // aggregate in map    │   │ │    │ |
|  │  │  │  │                                                      │   │ │    │ |
|  │  │  │  └─────────────────────────────────────────────────────┘   │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                              │                                   │    │ |
|  │  │                              ▼                                   │    │ |
|  │  │  5. USER-SPACE READS                                             │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Multiple methods:                                          │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  ftrace:                                                    │ │    │ |
|  │  │  │  cat /sys/kernel/debug/tracing/trace_pipe                   │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  perf:                                                      │ │    │ |
|  │  │  │  perf record -e sched:sched_switch                          │ │    │ |
|  │  │  │  perf script                                                │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  BPF:                                                       │ │    │ |
|  │  │  │  bpf_map_lookup()    // read aggregated data                │ │    │ |
|  │  │  │  perf_buffer_poll()  // read events                         │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  └─────────────────────────────────────────────────────────────────┘    │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
|  PROBE REGISTRATION                                                          |
|  ┌────────────────────────────────────────────────────────────────────────┐ |
|  │                                                                          │ |
|  │  ┌─────────────────────────────────────────────────────────────────┐    │ |
|  │  │                                                                  │    │ |
|  │  │  User enables tracepoint:                                        │    │ |
|  │  │                                                                  │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  # Via tracefs                                              │ │    │ |
|  │  │  │  echo 1 > /sys/kernel/debug/tracing/events/sched/           │ │    │ |
|  │  │  │            sched_switch/enable                              │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Kernel does:                                               │ │    │ |
|  │  │  │  1. tracepoint_probe_register(&sched_switch, handler)       │ │    │ |
|  │  │  │  2. static_branch_enable(&__tracepoint_sched_switch)        │ │    │ |
|  │  │  │  3. NOP instruction patched to JMP                          │ │    │ |
|  │  │  │  4. All CPUs now execute probe code                         │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  │  User disables tracepoint:                                       │    │ |
|  │  │                                                                  │    │ |
|  │  │  ┌────────────────────────────────────────────────────────────┐ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  echo 0 > .../enable                                        │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  │  Kernel does:                                               │ │    │ |
|  │  │  │  1. tracepoint_probe_unregister(&sched_switch, handler)     │ │    │ |
|  │  │  │  2. If no more probes, static_branch_disable()              │ │    │ |
|  │  │  │  3. JMP patched back to NOP                                 │ │    │ |
|  │  │  │  4. synchronize_rcu() - wait for all CPUs                   │ │    │ |
|  │  │  │  5. Zero overhead again                                     │ │    │ |
|  │  │  │                                                             │ │    │ |
|  │  │  └────────────────────────────────────────────────────────────┘ │    │ |
|  │  │                                                                  │    │ |
|  │  └─────────────────────────────────────────────────────────────────┘    │ |
|  │                                                                          │ |
|  └────────────────────────────────────────────────────────────────────────┘ |
|                                                                              |
+=============================================================================+
```

**中文说明：**

**事件生命周期**：

**从事件到用户空间**：

1. **事件发生**
   - 内核代码执行 `trace_sched_switch(prev, next)`

2. **检查是否启用**
   - 展开为静态分支
   - 如果禁用：只是 NOP，~0 开销

3. **调用注册的探针**
   - 多个消费者可以附加：ftrace、perf、BPF

4. **写入环形缓冲区**
   - ftrace：ring_buffer_lock_reserve，填充字段，commit
   - BPF：bpf_perf_event_output 或 map_update_elem

5. **用户空间读取**
   - ftrace：`cat /sys/kernel/debug/tracing/trace_pipe`
   - perf：`perf record/script`
   - BPF：bpf_map_lookup 或 perf_buffer_poll

**探针注册**：

**启用**：
1. tracepoint_probe_register()
2. static_branch_enable()
3. NOP 被修补为 JMP
4. 所有 CPU 现在执行探针代码

**禁用**：
1. tracepoint_probe_unregister()
2. 如果没有更多探针，static_branch_disable()
3. JMP 修补回 NOP
4. synchronize_rcu() - 等待所有 CPU
5. 再次零开销
