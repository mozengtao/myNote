# 四、为什么 C/C++ 特别"需要"架构意识

## 1. C/C++ 比 Java/Python 更容易出现架构腐化

### 语言特性对比

```
LANGUAGE FEATURES AND ARCHITECTURE EROSION (语言特性与架构腐化)
+===========================================================================+
|                                                                            |
|  JAVA / PYTHON                         C / C++                             |
|  ─────────────                         ──────                              |
|                                                                            |
|  ┌─────────────────────────────┐      ┌─────────────────────────────┐     |
|  │  Package/Module system       │      │  No module system (pre-C++20)│     |
|  │  强制模块边界               │      │  只靠 .h/.c 约定             │     |
|  │                              │      │                              │     |
|  │  import X only imports X     │      │  #include pulls EVERYTHING   │     |
|  │  只导入需要的               │      │  把整个头文件拉进来          │     |
|  └─────────────────────────────┘      └─────────────────────────────┘     |
|                                                                            |
|  ┌─────────────────────────────┐      ┌─────────────────────────────┐     |
|  │  private/protected/public   │      │  No access control           │     |
|  │  语言级访问控制             │      │  只靠 static 和命名约定       │     |
|  │                              │      │                              │     |
|  │  Compiler enforces encap.   │      │  Nothing stops bad access    │     |
|  │  编译器强制封装             │      │  没人阻止你访问内部          │     |
|  └─────────────────────────────┘      └─────────────────────────────┘     |
|                                                                            |
|  ┌─────────────────────────────┐      ┌─────────────────────────────┐     |
|  │  Garbage collection         │      │  Manual memory management    │     |
|  │  自动内存管理               │      │  手动内存管理                │     |
|  │                              │      │                              │     |
|  │  Ownership often implicit   │      │  Ownership must be explicit  │     |
|  │  所有权常常隐式             │      │  所有权必须显式定义          │     |
|  └─────────────────────────────┘      └─────────────────────────────┘     |
|                                                                            |
|  ┌─────────────────────────────┐      ┌─────────────────────────────┐     |
|  │  No pointers (references)   │      │  Raw pointers everywhere     │     |
|  │  没有原始指针               │      │  到处都是原始指针            │     |
|  │                              │      │                              │     |
|  │  Can't bypass abstractions  │      │  Can cast to anything        │     |
|  │  无法绕过抽象               │      │  可以强转成任何东西          │     |
|  └─────────────────────────────┘      └─────────────────────────────┘     |
|                                                                            |
+============================================================================+
```

### 头文件问题

```
HEADER FILE ARCHITECTURE EROSION (头文件架构腐化)
+===========================================================================+
|                                                                            |
|  PROBLEM 1: TRANSITIVE INCLUSION (传递性包含)                              |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │                                                                      │   |
|  │  // a.h                                                              │   |
|  │  #include "b.h"  // A depends on B                                   │   |
|  │                                                                      │   |
|  │  // c.c                                                              │   |
|  │  #include "a.h"  // C includes A, but ALSO gets B!                   │   |
|  │                  // 想要 A，却得到了 B 的所有符号                    │   |
|  │                                                                      │   |
|  │  // 后果：C 可以"意外"使用 B 的函数，建立了隐式依赖                 │   |
|  │  // 某天 A 不再需要 B，移除 #include "b.h" → C 编译失败！           │   |
|  │                                                                      │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  PROBLEM 2: NO INTERFACE/IMPLEMENTATION SEPARATION (接口实现不分离)        |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │                                                                      │   |
|  │  // BAD: 把实现细节放进头文件                                        │   |
|  │  // nfsd_internal.h                                                  │   |
|  │  struct raparms {                // 内部缓存结构                     │   |
|  │      struct raparms *p_next;                                         │   |
|  │      unsigned int p_count;                                           │   |
|  │      ino_t p_ino;                                                    │   |
|  │      ...                                                             │   |
|  │  };                                                                  │   |
|  │                                                                      │   |
|  │  // 任何包含这个头文件的代码都可以直接操作 p_next, p_count           │   |
|  │  // 改变结构 = 破坏所有使用者                                        │   |
|  │                                                                      │   |
|  │  // GOOD: 隐藏实现细节                                               │   |
|  │  // vfs.c (不是 .h!)                                                 │   |
|  │  static struct raparms { ... };  // static = 文件私有                │   |
|  │                                                                      │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  PROBLEM 3: MACRO POLLUTION (宏污染)                                       |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │                                                                      │   |
|  │  // 某个头文件                                                       │   |
|  │  #define ERROR -1                                                    │   |
|  │  #define SUCCESS 0                                                   │   |
|  │                                                                      │   |
|  │  // 包含这个头文件后，ERROR 和 SUCCESS 变成全局的                    │   |
|  │  // 如果另一个头文件也定义了 ERROR...                                │   |
|  │                                                                      │   |
|  │  // Linux 内核的做法：加前缀                                         │   |
|  │  #define NFS_OK        0                                             │   |
|  │  #define NFSERR_PERM   1                                             │   |
|  │                                                                      │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
+============================================================================+
```

### 指针问题

```c
// POINTER ARCHITECTURE EROSION (指针架构腐化)

// PROBLEM: Pointer allows bypassing abstractions (指针可以绕过抽象)

// 架构设计：通过 svc_fh 访问文件，确保权限检查
__be32 nfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, ...);

// 但是 C 语言没有任何机制阻止这样做：
struct svc_fh *fhp = ...;
struct dentry *dentry = fhp->fh_dentry;  // 直接访问内部字段
struct inode *inode = dentry->d_inode;   // 继续深入
inode->i_mode = 0777;                    // 绕过所有权限检查，直接修改！

// 在 Java 中：
// private Dentry dentry;  // 编译器会拒绝访问

// 在 C 中：
// 只能靠「约定」和「代码审查」来防止
// 一旦项目变大，必然有人会违反约定
```

### 全局状态问题

```c
// GLOBAL STATE ARCHITECTURE EROSION (全局状态架构腐化)

// fs/nfsd/vfs.c 中的例子
static struct raparm_hbucket raparm_hash[RAPARM_HASH_SIZE];  // 全局缓存

// 问题 1: 测试困难
// 想测试 nfsd_get_raparms() 需要先初始化全局数组
// 无法并行运行测试（共享全局状态）

// 问题 2: 隐式依赖
static ino_t last_ino;  // wait_for_concurrent_writes() 中的全局变量
static dev_t last_dev;

// 函数行为依赖全局状态，但从函数签名看不出来
// int wait_for_concurrent_writes(struct file *file);
// 看签名以为只依赖 file，实际还依赖 last_ino, last_dev

// 问题 3: 初始化顺序
// 如果有多个全局变量，初始化顺序可能影响正确性
// C 语言不保证不同 .c 文件中全局变量的初始化顺序
```

### 内存管理问题

```c
// MEMORY MANAGEMENT ARCHITECTURE EROSION (内存管理架构腐化)

// fs/nfsd/vfs.c 中的所有权规则（注释定义的架构）
/*
 * N.B. After this call fhp needs an fh_put
 */
__be32 nfsd_read(struct svc_rqst *rqstp, struct svc_fh *fhp, ...);

// 问题：这只是注释，编译器不检查！

// 正确用法：
err = nfsd_read(rqstp, fhp, ...);
fh_put(fhp);  // 必须调用

// 错误用法（编译通过，运行时资源泄漏）：
err = nfsd_read(rqstp, fhp, ...);
if (err)
    return err;  // 忘了 fh_put！

// 另一个例子：dget/dput 配对
dentry = dget(some_dentry);  // 增加引用计数
...
// 必须调用 dput(dentry);

// 资源所有权是架构级决策，但 C 语言无法强制执行
// 只能靠：
// 1. 注释
// 2. 命名约定 (xxx_get/xxx_put)
// 3. 静态分析工具
// 4. 代码审查
```

---

## 2. C 语言项目中最常见的架构灾难

```
TOP 5 ARCHITECTURAL DISASTERS IN C PROJECTS (C 项目常见架构灾难)
+===========================================================================+
|                                                                            |
|  DISASTER 1: SPAGHETTI HEADERS (意面头文件)                                |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  真实案例：早期 X Window System                                      │   |
|  │                                                                      │   |
|  │  • 头文件之间循环依赖                                                │   |
|  │  • #include 顺序影响编译结果                                         │   |
|  │  • 改一个头文件 → 重新编译整个项目                                   │   |
|  │  • 无法知道哪些符号来自哪个头文件                                    │   |
|  │                                                                      │   |
|  │  后果：编译时间长，重构几乎不可能                                    │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  DISASTER 2: GOD OBJECT / GOD FILE (上帝对象/上帝文件)                     |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  真实案例：某些嵌入式项目的 main.c                                   │   |
|  │                                                                      │   |
|  │  • 一个 .c 文件超过 10000 行                                         │   |
|  │  • 包含所有业务逻辑                                                  │   |
|  │  • 全局变量满天飞                                                    │   |
|  │  • 函数之间隐式依赖                                                  │   |
|  │                                                                      │   |
|  │  后果：无法并行开发，无法局部测试，无法重构                          │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  DISASTER 3: LAYERING VIOLATION (层次穿透)                                 |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  真实案例：某数据库项目                                              │   |
|  │                                                                      │   |
|  │  本应是: SQL Parser → Optimizer → Executor → Storage                 │   |
|  │  实际上: SQL Parser 直接调用 Storage 的内部函数                      │   |
|  │          Executor 直接访问 Parser 的内部数据结构                     │   |
|  │                                                                      │   |
|  │  后果：                                                              │   |
|  │  • 改 Storage 必须同时改 Parser                                      │   |
|  │  • 每次优化都可能引入 regression                                     │   |
|  │  • 新人需要理解整个系统才能改一个模块                                │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  DISASTER 4: OWNERSHIP AMBIGUITY (所有权模糊)                              |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  真实案例：OpenSSL 早期版本                                          │   |
|  │                                                                      │   |
|  │  void *some_function() {                                             │   |
|  │      void *ptr = malloc(...);                                        │   |
|  │      return ptr;  // 谁负责 free？                                   │   |
|  │  }                                                                   │   |
|  │                                                                      │   |
|  │  后果：                                                              │   |
|  │  • 内存泄漏遍布代码库                                                │   |
|  │  • Use-after-free 漏洞（CVE 列表）                                   │   |
|  │  • 双重释放崩溃                                                      │   |
|  │                                                                      │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  DISASTER 5: HIDDEN COUPLING (隐藏耦合)                                    |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  真实案例：某网络协议栈                                              │   |
|  │                                                                      │   |
|  │  // 看起来独立的两个模块                                             │   |
|  │  void module_a_init() {                                              │   |
|  │      global_config = read_config();                                  │   |
|  │  }                                                                   │   |
|  │                                                                      │   |
|  │  void module_b_process() {                                           │   |
|  │      if (global_config->flag) { ... }  // 隐式依赖 A 已初始化        │   |
|  │  }                                                                   │   |
|  │                                                                      │   |
|  │  后果：                                                              │   |
|  │  • 初始化顺序依赖（改顺序就崩溃）                                    │   |
|  │  • 无法独立测试 module_b                                             │   |
|  │  • 看代码看不出依赖关系                                              │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
+============================================================================+
```

---

## 3. Linux 内核如何"用架构对抗复杂度"

### 策略 1：严格的分层

```
LINUX KERNEL LAYERING (Linux 内核分层)
+===========================================================================+
|                                                                            |
|   User Space                                                               |
|   ═══════════════════════════════════════════════════════════════════     |
|   System Call Interface                                                    |
|   ┌─────────────────────────────────────────────────────────────────┐     |
|   │  sys_read(), sys_write(), sys_open(), ...                        │     |
|   │  统一入口，参数校验，权限检查                                    │     |
|   └─────────────────────────────────────────────────────────────────┘     |
|                              │                                             |
|   ═══════════════════════════╪═══════════════════════════════════════     |
|   VFS Layer                  ▼                                             |
|   ┌─────────────────────────────────────────────────────────────────┐     |
|   │  vfs_read(), vfs_write(), vfs_open(), ...                        │     |
|   │  抽象文件操作，不关心具体文件系统                                │     |
|   └─────────────────────────────────────────────────────────────────┘     |
|                              │                                             |
|   ═══════════════════════════╪═══════════════════════════════════════     |
|   Filesystem Layer           ▼                                             |
|   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐               |
|   │   ext4   │  │   xfs    │  │   nfs    │  │   ...    │               |
|   └──────────┘  └──────────┘  └──────────┘  └──────────┘               |
|                              │                                             |
|   ═══════════════════════════╪═══════════════════════════════════════     |
|   Block Layer                ▼                                             |
|   ┌─────────────────────────────────────────────────────────────────┐     |
|   │  I/O 调度，请求合并，设备映射                                    │     |
|   └─────────────────────────────────────────────────────────────────┘     |
|                                                                            |
|   NFSD 的位置：                                                            |
|   User Request → NFSD (网络处理) → VFS → 具体文件系统 → Block              |
|                                                                            |
+============================================================================+
```

### 策略 2：操作表模式（Operations Table）

```c
// Linux 内核大量使用「操作表」来实现接口抽象

// fs/nfsd/vfs.c 使用 VFS 操作表
struct file_operations {
    ssize_t (*read)(struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *);
    int (*open)(struct inode *, struct file *);
    int (*release)(struct inode *, struct file *);
    // ...
};

// 使用方式：
if (file->f_op->splice_read) {
    // 调用具体文件系统的 splice_read 实现
    file->f_op->splice_read(file, ...);
}

// 这实现了：
// 1. 多态（不同文件系统有不同实现）
// 2. 解耦（NFSD 不需要知道具体是哪个文件系统）
// 3. 可扩展（添加新文件系统只需实现操作表）
```

### 策略 3：私有/公开分离

```c
// Linux 内核通过文件组织实现访问控制

// PUBLIC INTERFACE (公开接口)
// include/linux/nfsd/nfsd.h
// include/linux/nfsd/export.h
// 这些头文件定义了其他子系统可以使用的接口

// PRIVATE IMPLEMENTATION (私有实现)
// fs/nfsd/vfs.c 中的 static 函数和变量

// 私有数据结构
static struct raparm_hbucket raparm_hash[RAPARM_HASH_SIZE];

// 私有函数
static inline struct raparms *nfsd_get_raparms(dev_t dev, ino_t ino);
static __be32 nfsd_vfs_read(...);
static __be32 nfsd_vfs_write(...);

// 公开函数（非 static）
__be32 nfsd_read(...);   // 在头文件中声明
__be32 nfsd_write(...);  // 可以被其他模块调用
```

### 策略 4：命名约定作为架构规则

```c
// Linux 内核的命名约定

// 子系统前缀
nfsd_xxx()      // NFSD 子系统
vfs_xxx()       // VFS 层
ext4_xxx()      // ext4 文件系统

// 操作类型后缀
xxx_get() / xxx_put()     // 引用计数操作
xxx_lock() / xxx_unlock() // 锁操作
xxx_init() / xxx_exit()   // 初始化/清理

// 可见性约定
__xxx()         // 内部函数，需要调用者持有某些锁
xxx_nolock()    // 不加锁版本

// fs/nfsd/vfs.c 中的例子
fh_lock(fhp);           // 锁定 file handle
fh_unlock(fhp);         // 解锁
fh_put(fhp);            // 释放引用

dget(dentry);           // 增加 dentry 引用
dput(dentry);           // 减少 dentry 引用

mnt_want_write(mnt);    // 获取写权限
mnt_drop_write(mnt);    // 释放写权限
```

### 策略 5：条件编译隔离可选功能

```c
// fs/nfsd/vfs.c 中的条件编译

// NFSv3 特有功能
#ifdef CONFIG_NFSD_V3
__be32 nfsd_access(...)  { ... }
__be32 nfsd_commit(...)  { ... }
#endif

// NFSv4 特有功能
#ifdef CONFIG_NFSD_V4
__be32 nfsd4_set_nfs4_acl(...) { ... }
int nfsd4_get_nfs4_acl(...) { ... }
int nfsd4_is_junction(...) { ... }
#endif

// ACL 支持
#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)
struct posix_acl *nfsd_get_posix_acl(...) { ... }
int nfsd_set_posix_acl(...) { ... }
#endif

// 这实现了：
// 1. 功能隔离（不需要的功能完全不编译）
// 2. 配置灵活（用户可选择需要的功能）
// 3. 代码清晰（每个功能的边界明确）
```

---

## 核心总结

```
+===========================================================================+
|                 WHY C/C++ NEEDS ARCHITECTURE                               |
|                 为什么 C/C++ 需要架构意识                                  |
+===========================================================================+
|                                                                            |
|  C/C++ 的「自由」是双刃剑：                                                |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │  • 没有模块系统 → 必须用目录和头文件约定来模拟                       │  |
|  │  • 没有访问控制 → 必须用 static 和命名约定来实现                     │  |
|  │  • 指针无限制 → 必须用接口函数来防止绕过抽象                         │  |
|  │  • 手动内存管理 → 必须用 get/put 约定来确保资源释放                  │  |
|  │  • 没有异常 → 必须用返回值约定和错误转换来处理错误                   │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  Linux 内核的应对策略：                                                    |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │  1. 操作表模式 → 实现多态和接口抽象                                  │  |
|  │  2. 严格分层 → 控制依赖方向                                          │  |
|  │  3. 命名约定 → 表达所有权和操作类型                                  │  |
|  │  4. static 关键字 → 实现封装                                         │  |
|  │  5. 条件编译 → 功能隔离                                              │  |
|  │  6. 代码审查 → 强制执行架构规则                                      │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  关键洞察：                                                                |
|  语言不提供的保护，必须用「约定 + 工具 + 流程」来补充                     |
|  约定越清晰，架构越容易维护                                               |
|                                                                            |
+============================================================================+
```
