# 五、没有架构会发生什么？（反面案例）

## 一个真实可信的失败演进路径

### 项目背景

假设一个嵌入式网络设备项目，需要支持多种网络协议和文件操作。

```
PROJECT EVOLUTION TIMELINE (项目演进时间线)
+===========================================================================+
|                                                                            |
|  PHASE 1: PROTOTYPE (原型期)                                               |
|  ─────────────────────────────────────────                                 |
|  Lines of Code: ~2,000                                                     |
|  Team Size: 1 developer                                                    |
|  Duration: 2 months                                                        |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  main.c (2000 lines)                                                  │  |
|  │  ├── main()                                                           │  |
|  │  ├── handle_network()                                                 │  |
|  │  ├── handle_file()                                                    │  |
|  │  ├── parse_config()                                                   │  |
|  │  └── 50+ helper functions                                             │  |
|  │                                                                       │  |
|  │  // 全局变量                                                          │  |
|  │  int g_socket;                                                        │  |
|  │  char g_buffer[4096];                                                 │  |
|  │  struct config g_config;                                              │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  "看，代码很简单，运行正常！"                                              |
|  实际问题：已经埋下了架构债务                                              |
|                                                                            |
+============================================================================+
```

### 阶段 2：快速增长期

```
PHASE 2: RAPID GROWTH (快速增长期)
+===========================================================================+
|                                                                            |
|  Lines of Code: ~15,000                                                    |
|  Team Size: 3 developers                                                   |
|  Duration: 6 months                                                        |
|  New Requirements: NFSv3 support, ACL, logging                             |
|                                                                            |
|  CODE STRUCTURE (代码结构):                                                |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  main.c (5000 lines) ← 继续往里塞                                     │  |
|  │  ├── main()                                                           │  |
|  │  ├── handle_network()                                                 │  |
|  │  │   ├── handle_nfs_v2()    ← 新增                                   │  |
|  │  │   └── handle_nfs_v3()    ← 新增，但和 v2 有大量重复代码            │  |
|  │  ├── handle_file()                                                    │  |
|  │  │   └── check_acl()        ← 新增，200 行嵌入在 handle_file 中间    │  |
|  │  └── ...                                                              │  |
|  │                                                                       │  |
|  │  network.c (4000 lines)     ← 从 main.c 复制出来的                    │  |
|  │  file_ops.c (3000 lines)    ← 从 main.c 复制出来的                    │  |
|  │  utils.c (3000 lines)       ← 各种工具函数，没有组织                  │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  SYMPTOMS APPEARING (症状开始出现):                                        |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │  1. Merge conflicts every day (每天都有合并冲突)                       │  |
|  │     - "我改了 main.c 第 200-500 行"                                   │  |
|  │     - "我也改了 main.c 第 300-600 行"                                 │  |
|  │                                                                       │  |
|  │  2. Bug fixes cause new bugs (修 bug 引入新 bug)                      │  |
|  │     - 修复 NFSv3 的一个 bug，NFSv2 开始出错                           │  |
|  │     - 因为 v2 和 v3 的代码交织在一起                                  │  |
|  │                                                                       │  |
|  │  3. Global state everywhere (全局状态到处都是)                         │  |
|  │     - g_socket, g_buffer, g_config, g_acl_cache, ...                 │  |
|  │     - 没人知道谁在什么时候修改这些变量                                 │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ★ 架构决策失误点 #1:                                                      |
|  不应该把 NFSv3 代码「加」在 NFSv2 旁边                                    |
|  应该抽象出共同层，然后分别实现 v2 和 v3                                   |
|                                                                            |
+============================================================================+
```

### 阶段 3：泥潭期

```
PHASE 3: THE MUD (泥潭期)
+===========================================================================+
|                                                                            |
|  Lines of Code: ~50,000                                                    |
|  Team Size: 5 developers                                                   |
|  Duration: 1 year                                                          |
|  New Requirements: NFSv4, encryption, quota, clustering                    |
|                                                                            |
|  CODE STRUCTURE (已经无法画清楚了):                                        |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │       ┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐          │  |
|  │       │main.c│◄──►│net.c │◄──►│file.c│◄──►│acl.c │◄──►│util.c│          │  |
|  │       └──┬───┘   └──┬───┘   └──┬───┘   └──┬───┘   └──┬───┘          │  |
|  │          │          │          │          │          │               │  |
|  │          └──────────┼──────────┼──────────┼──────────┘               │  |
|  │                     │          │          │                          │  |
|  │       ┌──────┐   ┌──┴───┐   ┌──┴───┐   ┌──┴───┐   ┌──────┐          │  |
|  │       │quota │◄──►│crypt │◄──►│nfsv4│◄──►│cluster│◄──►│cache │          │  |
|  │       └──────┘   └──────┘   └──────┘   └──────┘   └──────┘          │  |
|  │                                                                       │  |
|  │       每个模块都依赖其他所有模块                                       │  |
|  │       形成了「大泥球」(Big Ball of Mud)                                │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 具体的灾难表现

### 「谁都不敢改」的代码

```c
// THE UNTOUCHABLE CODE (不敢碰的代码)

// 这个函数已经 800 行，包含：
// - 协议解析
// - 权限检查
// - 文件操作
// - 加密
// - 日志
// - 错误处理
// 每一行都可能被其他地方依赖

int process_request(struct request *req)
{
    // ... 第 1-50 行: 某人在 2019 年加的，不知道干什么
    
    // ... 第 51-100 行: 协议解析，但里面有 ACL 检查的代码
    
    // ★ 第 101-150 行: 没人敢改这段
    // 注释说 "DO NOT MODIFY - fixes critical bug #1234"
    // 但 bug #1234 的 ticket 已经丢失了
    if (some_condition && another_condition && 
        !some_global_flag && cached_value != NULL) {
        // 没人知道为什么需要这个检查
        // 删了会崩溃，但不知道为什么
    }
    
    // ... 第 151-800 行: 更多「神秘」代码
}

// 后果：
// - 新人不敢改（怕引入 bug）
// - 老人不敢改（忘了当初为什么这么写）
// - 只能在外面包一层 wrapper，代码越来越臃肿
```

### 「永远修不干净」的 Bug

```c
// THE UNFIXABLE BUGS (修不干净的 bug)

// Bug: 在高并发下偶尔出现数据损坏
// 根因: 全局缓冲区在多个地方被使用

char g_buffer[4096];  // 全局缓冲区

// 位置 1: network.c
void handle_network_data() {
    recv(socket, g_buffer, sizeof(g_buffer), 0);
    process_network_data(g_buffer);  // 可能被中断
}

// 位置 2: file.c (同时在另一个线程)
void handle_file_data() {
    read(fd, g_buffer, sizeof(g_buffer));  // 覆盖了网络数据！
    process_file_data(g_buffer);
}

// 尝试修复 1: 加锁
// 结果: 性能下降 50%，客户不接受

// 尝试修复 2: 改成局部缓冲区
// 结果: 需要修改 200 个函数的签名，改了一半放弃了

// 尝试修复 3: 加 workaround
if (is_network_processing) {
    memcpy(g_buffer_backup, g_buffer, sizeof(g_buffer));
}
// 结果: 引入了新的 bug，而且更难调试

// ★ 架构决策失误点 #2:
// 从一开始就不应该使用全局缓冲区
// 应该让每个调用者提供自己的缓冲区
```

### 「黑洞」模块

```c
// THE BLACK HOLE MODULES (黑洞模块)

// cache.c: 500 行变成 5000 行的模块
// 原本只是一个简单的 LRU 缓存
// 后来变成了:

// cache.c 包含:
// - LRU 缓存逻辑
// - 协议特定的序列化
// - 文件系统特定的优化
// - ACL 缓存
// - quota 缓存
// - 加密密钥缓存
// - 集群同步逻辑
// - 日志
// - 监控指标收集

// 每个新功能都说「我需要缓存，就加在 cache.c 里吧」
// 结果:
// - cache.c 变成了「万能模块」
// - 任何改动都需要理解 cache.c
// - 编译 cache.c 需要链接几乎所有模块

// 依赖关系:
//   main.c     → cache.c
//   network.c  → cache.c
//   file.c     → cache.c
//   acl.c      → cache.c
//   quota.c    → cache.c
//   crypt.c    → cache.c
//   cluster.c  → cache.c
//
//   cache.c    → network.c (为了网络同步)
//   cache.c    → file.c    (为了持久化)
//   cache.c    → acl.c     (为了 ACL 缓存)
//   cache.c    → crypt.c   (为了密钥缓存)
//
// 形成了循环依赖，无法拆分

// ★ 架构决策失误点 #3:
// 应该把缓存做成通用基础设施
// 具体的缓存（ACL 缓存、密钥缓存）应该在各自模块中
```

---

## 区分「架构失误」vs「实现水平不够」

```
ARCHITECTURE FAILURE vs IMPLEMENTATION FAILURE (架构失误 vs 实现失误)
+===========================================================================+
|                                                                            |
|  ARCHITECTURE FAILURES (架构失误):                                         |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  决策                          后果                                   │  |
|  │  ────────                      ──────                                 │  |
|  │  1. 全局缓冲区                 → 并发 bug，无法局部修复               │  |
|  │  2. v2/v3 代码交织             → 修一个版本影响另一个                 │  |
|  │  3. 缓存模块承担太多职责       → 成为系统瓶颈，无法拆分               │  |
|  │  4. 没有定义模块边界           → 随意跨模块访问内部数据               │  |
|  │  5. 没有定义错误处理策略       → 每个地方的错误处理都不一样           │  |
|  │                                                                       │  |
|  │  特征: 解决需要大规模重构，影响多个模块                               │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  IMPLEMENTATION FAILURES (实现失误):                                       |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  问题                          修复                                   │  |
|  │  ────────                      ──────                                 │  |
|  │  1. 哈希函数选得不好           → 换一个更好的哈希函数                 │  |
|  │  2. 缓冲区大小不合适           → 调整常量                             │  |
|  │  3. 某个函数太长               → 拆成多个小函数                       │  |
|  │  4. 变量命名不清晰             → 重命名                               │  |
|  │  5. 算法效率低                 → 换算法                               │  |
|  │                                                                       │  |
|  │  特征: 可以局部修复，只影响一个函数/文件                              │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

### 关键的失误时刻

```
CRITICAL DECISION POINTS (关键决策点)
+===========================================================================+
|                                                                            |
|  TIME: 第 2 个月，第一次添加 NFSv3                                         |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  WRONG DECISION (错误决策):                                           │  |
|  │  "NFSv3 和 v2 差不多，直接在 handle_network() 里加个 if-else"         │  |
|  │                                                                       │  |
|  │  RIGHT DECISION (正确决策):                                           │  |
|  │  "v2 和 v3 有共同部分，应该抽出来；不同部分分开实现"                  │  |
|  │                                                                       │  |
|  │  struct nfs_operations {                                              │  |
|  │      int (*parse_request)(struct request *);                          │  |
|  │      int (*handle_read)(struct file *, ...);                          │  |
|  │      int (*handle_write)(struct file *, ...);                         │  |
|  │  };                                                                   │  |
|  │                                                                       │  |
|  │  static struct nfs_operations nfs_v2_ops = { ... };                   │  |
|  │  static struct nfs_operations nfs_v3_ops = { ... };                   │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  TIME: 第 4 个月，添加 ACL 支持                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  WRONG DECISION:                                                      │  |
|  │  "就在 handle_file() 里加 200 行 ACL 检查代码"                        │  |
|  │                                                                       │  |
|  │  RIGHT DECISION:                                                      │  |
|  │  "ACL 应该是独立模块，通过 hook 点接入"                               │  |
|  │                                                                       │  |
|  │  // 定义 hook                                                         │  |
|  │  typedef int (*access_check_fn)(struct file *, int mode);             │  |
|  │                                                                       │  |
|  │  // 注册 ACL 检查                                                     │  |
|  │  register_access_check(acl_check);                                    │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  TIME: 第 6 个月，需要缓存功能                                             |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  WRONG DECISION:                                                      │  |
|  │  "建一个 cache.c 放所有缓存"                                          │  |
|  │                                                                       │  |
|  │  RIGHT DECISION:                                                      │  |
|  │  "做一个通用的缓存库，每个模块用自己的缓存实例"                       │  |
|  │                                                                       │  |
|  │  // 通用缓存接口                                                      │  |
|  │  struct cache *cache_create(size_t size, cache_ops_t *ops);           │  |
|  │  void *cache_get(struct cache *, const void *key);                    │  |
|  │  void cache_put(struct cache *, const void *key, void *value);        │  |
|  │                                                                       │  |
|  │  // 各模块使用自己的缓存                                              │  |
|  │  static struct cache *acl_cache;  // in acl.c                         │  |
|  │  static struct cache *key_cache;  // in crypt.c                       │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 核心教训

```
+===========================================================================+
|                    LESSONS FROM FAILURE                                    |
|                    失败的教训                                              |
+===========================================================================+
|                                                                            |
|  1. 「能跑」不等于「能活」                                                 |
|     代码今天能跑，不代表三个月后还能改                                     |
|                                                                            |
|  2. 架构债务会复利增长                                                     |
|     第一个错误决策让后续决策更容易错                                       |
|     等到发现问题时，已经无法重构                                           |
|                                                                            |
|  3. 「快速实现」往往是最慢的路                                             |
|     省下的设计时间会十倍返还在调试和重写上                                 |
|                                                                            |
|  4. 关键判断点往往不起眼                                                   |
|     「就加个 if-else」「就放这里吧」                                       |
|     这些看似小的决定会累积成大灾难                                         |
|                                                                            |
|  5. 问正确的问题                                                           |
|     不是「怎么最快实现这个功能」                                           |
|     而是「三个月后，另一个人怎么改这个功能」                               |
|                                                                            |
+============================================================================+
```

**中文总结：**

这个失败案例展示了「温水煮青蛙」式的架构腐化：
1. 每一步决策当时看起来都「合理」
2. 问题是渐进积累的，没有明显的崩溃点
3. 当意识到问题时，重构成本已经高到无法接受
4. 最终只能「推倒重来」或「带病运行」

最危险的不是「做错事」，而是「在错误的方向上做对事」。
