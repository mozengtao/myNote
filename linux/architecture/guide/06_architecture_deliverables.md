# 六、架构设计的真正产出是什么？

## 架构设计不是什么

```
WHAT ARCHITECTURE IS NOT (架构不是什么)
+===========================================================================+
|                                                                            |
|  ✗ NOT UML DIAGRAMS (不是 UML 图)                                          |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │  UML 图是「表达」架构的一种方式                                       │  |
|  │  但图本身不是架构                                                     │  |
|  │                                                                       │  |
|  │  你可以画出完美的 UML 图，但代码完全不遵守                            │  |
|  │  你可以没有任何图，但代码结构清晰一致                                 │  |
|  │                                                                       │  |
|  │  架构存在于代码中，不是文档中                                         │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ✗ NOT DOCUMENTATION (不是文档)                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │  文档描述架构，但文档 ≠ 架构                                         │  |
|  │                                                                       │  |
|  │  问题：文档和代码会 diverge（分叉）                                   │  |
|  │  "文档说 A 调用 B，但代码里 A 直接调用 C"                             │  |
|  │                                                                       │  |
|  │  真正的架构是「代码实际遵守的规则」                                   │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ✗ NOT MODULE NAMES (不是模块名)                                           |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │  有 network.c, file.c, cache.c 不代表有架构                          │  |
|  │                                                                       │  |
|  │  如果 network.c 直接访问 file.c 的内部变量                           │  |
|  │  如果 cache.c 依赖所有其他模块                                        │  |
|  │  那只是「文件分开了」，不是「架构分层了」                             │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 架构设计的真正产出

### 1. 稳定决策（Stable Decisions）

```
STABLE DECISIONS (稳定决策)
+===========================================================================+
|                                                                            |
|  架构产出 = 一组「几乎不变」的决策                                         |
|                                                                            |
|  以 fs/nfsd/vfs.c 为例：                                                   |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  STABLE DECISION 1: Error Representation (错误表示)                   │  |
|  │  ─────────────────────────────────────────────────────────           │  |
|  │  • 所有 NFSD 函数返回 __be32 类型的 NFS 协议错误                      │  |
|  │  • 内核错误通过 nfserrno() 转换                                       │  |
|  │  • 这个决策从 Linux 2.0 到现在没变过                                  │  |
|  │                                                                       │  |
|  │  代码体现：                                                           │  |
|  │  __be32 nfsd_open(...) { return nfserrno(host_err); }                │  |
|  │  __be32 nfsd_read(...) { return nfserrno(host_err); }                │  |
|  │  __be32 nfsd_write(...) { return nfserrno(host_err); }               │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  STABLE DECISION 2: File Handle Abstraction (文件句柄抽象)            │  |
|  │  ─────────────────────────────────────────────────────────           │  |
|  │  • 通过 struct svc_fh 访问文件，不直接使用 dentry                     │  |
|  │  • svc_fh 封装了权限检查、导出验证、引用计数                          │  |
|  │                                                                       │  |
|  │  代码体现：                                                           │  |
|  │  __be32 nfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, ...);  │  |
|  │  //                                             ^^^^^^^^^^^^         │  |
|  │  // 所有文件操作都通过 fhp，不是 dentry *                             │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  STABLE DECISION 3: VFS Interface Usage (使用 VFS 接口)               │  |
|  │  ─────────────────────────────────────────────────────────           │  |
|  │  • NFSD 只通过 VFS 接口操作文件系统                                   │  |
|  │  • 不直接调用具体文件系统的函数                                       │  |
|  │                                                                       │  |
|  │  代码体现：                                                           │  |
|  │  vfs_readv(file, ...);      // 不是 ext4_readv()                     │  |
|  │  vfs_writev(file, ...);     // 不是 xfs_writev()                     │  |
|  │  vfs_fsync(file, ...);      // 不是 btrfs_fsync()                    │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

### 2. 禁止事项（Prohibitions）

```
ARCHITECTURAL PROHIBITIONS (架构禁止事项)
+===========================================================================+
|                                                                            |
|  架构产出 = 一组「不能做的事」                                             |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  PROHIBITION 1: No Direct Filesystem Access (禁止直接访问文件系统)    │  |
|  │  ─────────────────────────────────────────────────────────────────   │  |
|  │                                                                       │  |
|  │  ✗ FORBIDDEN:                                                         │  |
|  │  ext4_file_read(inode, ...);   // 直接调用 ext4                       │  |
|  │                                                                       │  |
|  │  ✓ REQUIRED:                                                          │  |
|  │  vfs_read(file, ...);          // 通过 VFS 层                         │  |
|  │                                                                       │  |
|  │  为什么禁止：                                                         │  |
|  │  - NFSD 不应该知道底层是什么文件系统                                  │  |
|  │  - 新文件系统应该自动被 NFSD 支持                                     │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  PROHIBITION 2: No Bypass of Permission Check (禁止绕过权限检查)      │  |
|  │  ─────────────────────────────────────────────────────────────────   │  |
|  │                                                                       │  |
|  │  ✗ FORBIDDEN:                                                         │  |
|  │  dentry = fhp->fh_dentry;     // 直接获取 dentry                      │  |
|  │  file = dentry_open(dentry);  // 绕过 fh_verify                       │  |
|  │                                                                       │  |
|  │  ✓ REQUIRED:                                                          │  |
|  │  err = fh_verify(rqstp, fhp, type, access);  // 先验证                │  |
|  │  if (err) return err;                                                 │  |
|  │  dentry = fhp->fh_dentry;     // 验证后才访问                         │  |
|  │                                                                       │  |
|  │  fs/nfsd/vfs.c 中的体现：                                             │  |
|  │  几乎每个公开函数开头都有 fh_verify() 调用                            │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  PROHIBITION 3: No Leaking Internal Structures (禁止泄露内部结构)     │  |
|  │  ─────────────────────────────────────────────────────────────────   │  |
|  │                                                                       │  |
|  │  ✗ FORBIDDEN:                                                         │  |
|  │  // 在头文件中暴露 raparms 结构                                       │  |
|  │  struct raparms { ... };  // in .h file                               │  |
|  │                                                                       │  |
|  │  ✓ REQUIRED:                                                          │  |
|  │  // 结构只在 .c 文件中定义                                            │  |
|  │  static struct raparms { ... };  // in vfs.c only                     │  |
|  │                                                                       │  |
|  │  为什么禁止：                                                         │  |
|  │  - 内部结构改变不应该影响其他模块                                     │  |
|  │  - 防止其他代码建立对实现细节的依赖                                   │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  PROHIBITION 4: No Wrong Locking Order (禁止错误的锁顺序)             │  |
|  │  ─────────────────────────────────────────────────────────────────   │  |
|  │                                                                       │  |
|  │  ✗ FORBIDDEN:                                                         │  |
|  │  fh_lock(child);    // 先锁子                                         │  |
|  │  fh_lock(parent);   // 后锁父 → 可能死锁！                            │  |
|  │                                                                       │  |
|  │  ✓ REQUIRED:                                                          │  |
|  │  fh_lock_nested(fhp, I_MUTEX_PARENT);  // 先锁父                      │  |
|  │  lookup_one_len(name, dentry, len);    // 操作子                      │  |
|  │                                                                       │  |
|  │  代码注释体现：                                                       │  |
|  │  /* cannot use fh_lock as we need deadlock protective ordering */    │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

### 3. 默认约束（Default Constraints）

```
DEFAULT CONSTRAINTS (默认约束)
+===========================================================================+
|                                                                            |
|  架构产出 = 一组「默认规则」                                               |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  CONSTRAINT 1: Resource Ownership (资源所有权)                        │  |
|  │  ─────────────────────────────────────────────────────────           │  |
|  │                                                                       │  |
|  │  约定：xxx_get() 获取的资源必须用 xxx_put() 释放                      │  |
|  │                                                                       │  |
|  │  代码体现（注释即约束）：                                             │  |
|  │  /*                                                                   │  |
|  │   * N.B. After this call fhp needs an fh_put                          │  |
|  │   */                                                                  │  |
|  │  __be32 nfsd_read(... struct svc_fh *fhp ...);                        │  |
|  │                                                                       │  |
|  │  // 必须这样用：                                                      │  |
|  │  err = nfsd_read(rqstp, fhp, ...);                                    │  |
|  │  fh_put(fhp);  // 调用者负责释放                                      │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  CONSTRAINT 2: Naming Convention (命名约定)                           │  |
|  │  ─────────────────────────────────────────────────────────           │  |
|  │                                                                       │  |
|  │  约定：函数前缀表示所属子系统                                         │  |
|  │                                                                       │  |
|  │  nfsd_xxx()   - NFSD 子系统的函数                                     │  |
|  │  nfserr_xxx   - NFS 错误码                                            │  |
|  │  fh_xxx()     - file handle 操作                                      │  |
|  │  svc_xxx()    - RPC service 层操作                                    │  |
|  │                                                                       │  |
|  │  这不是「美观」，是「可搜索性」和「可理解性」                         │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  CONSTRAINT 3: Error Handling Pattern (错误处理模式)                  │  |
|  │  ─────────────────────────────────────────────────────────           │  |
|  │                                                                       │  |
|  │  约定：使用 goto 统一错误处理                                         │  |
|  │                                                                       │  |
|  │  __be32 nfsd_xxx(...)                                                 │  |
|  │  {                                                                    │  |
|  │      __be32 err;                                                      │  |
|  │      int host_err;                                                    │  |
|  │                                                                       │  |
|  │      // ... 操作 ...                                                  │  |
|  │      if (host_err)                                                    │  |
|  │          goto out_nfserr;                                             │  |
|  │                                                                       │  |
|  │      // ... 更多操作 ...                                              │  |
|  │      err = 0;                                                         │  |
|  │  out:                                                                 │  |
|  │      return err;                                                      │  |
|  │                                                                       │  |
|  │  out_nfserr:                                                          │  |
|  │      err = nfserrno(host_err);                                        │  |
|  │      goto out;                                                        │  |
|  │  }                                                                    │  |
|  │                                                                       │  |
|  │  整个 vfs.c 遵守同样的模式                                            │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  CONSTRAINT 4: Mount Write Protection (挂载写保护)                    │  |
|  │  ─────────────────────────────────────────────────────────           │  |
|  │                                                                       │  |
|  │  约定：写操作前后必须调用 mnt_want_write/mnt_drop_write               │  |
|  │                                                                       │  |
|  │  host_err = mnt_want_write(fhp->fh_export->ex_path.mnt);              │  |
|  │  if (host_err)                                                        │  |
|  │      goto out_nfserr;                                                 │  |
|  │                                                                       │  |
|  │  // ... 写操作 ...                                                    │  |
|  │                                                                       │  |
|  │  mnt_drop_write(fhp->fh_export->ex_path.mnt);                         │  |
|  │                                                                       │  |
|  │  这确保只读挂载不会被意外写入                                         │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 如何识别架构产出

```
HOW TO IDENTIFY ARCHITECTURAL OUTPUTS (如何识别架构产出)
+===========================================================================+
|                                                                            |
|  问自己这些问题：                                                          |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Q1: 这个规则/约定在多少个文件中被遵守？                              │  |
|  │      • 1 个文件 → 可能只是该文件的局部约定                            │  |
|  │      • 多个文件 → 可能是架构约束                                      │  |
|  │                                                                       │  |
|  │  Q2: 违反这个规则会发生什么？                                         │  |
|  │      • 编译错误 → 语言强制的约束                                      │  |
|  │      • 运行时崩溃 → 架构约束（应该变成编译错误）                      │  |
|  │      • 只是不优雅 → 只是风格偏好                                      │  |
|  │                                                                       │  |
|  │  Q3: 新人加入时需要被告知这个规则吗？                                 │  |
|  │      • 是 → 架构约束                                                  │  |
|  │      • 否 → 可能只是实现细节                                          │  |
|  │                                                                       │  |
|  │  Q4: 这个规则会影响模块间的交互吗？                                   │  |
|  │      • 是 → 架构约束                                                  │  |
|  │      • 否 → 实现细节                                                  │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## C/C++ 项目中架构产出的具体形式

```
ARCHITECTURAL OUTPUTS IN C/C++ (C/C++ 中的架构产出)
+===========================================================================+
|                                                                            |
|  1. HEADER FILE DESIGN (头文件设计)                                        |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  头文件 = 接口契约                                                    │  |
|  │                                                                       │  |
|  │  // 公开接口（其他模块可以调用）                                      │  |
|  │  // include/nfsd/export.h                                             │  |
|  │  struct svc_export *rqst_exp_get_by_name(...);                        │  |
|  │                                                                       │  |
|  │  // 私有接口（只有本模块使用）                                        │  |
|  │  // 不在任何公开头文件中                                              │  |
|  │  static struct raparms *nfsd_get_raparms(...);                        │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  2. TYPE DEFINITIONS (类型定义)                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  类型 = 语义契约                                                      │  |
|  │                                                                       │  |
|  │  __be32   // 大端序 32 位，表示网络字节序的 NFS 错误码                │  |
|  │  loff_t   // 64 位文件偏移                                            │  |
|  │  dev_t    // 设备号                                                   │  |
|  │  ino_t    // inode 号                                                 │  |
|  │                                                                       │  |
|  │  typedef 不只是别名，是语义的声明                                     │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  3. FUNCTION SIGNATURES (函数签名)                                         |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  签名 = 调用契约                                                      │  |
|  │                                                                       │  |
|  │  __be32 nfsd_open(                                                    │  |
|  │      struct svc_rqst *rqstp,  // 请求上下文                           │  |
|  │      struct svc_fh *fhp,      // 文件句柄（会被验证）                 │  |
|  │      int type,                // 期望的文件类型                       │  |
|  │      int access,              // 访问模式                             │  |
|  │      struct file **filp       // 输出参数                             │  |
|  │  );                                                                   │  |
|  │                                                                       │  |
|  │  // 签名告诉你：                                                      │  |
|  │  // - 需要什么输入                                                    │  |
|  │  // - 提供什么输出                                                    │  |
|  │  // - 可能的错误（__be32 返回类型）                                   │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  4. MACRO CONSTANTS (宏常量)                                               |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  常量 = 配置契约                                                      │  |
|  │                                                                       │  |
|  │  #define NFSD_MAY_READ      0x001                                     │  |
|  │  #define NFSD_MAY_WRITE     0x002                                     │  |
|  │  #define NFSD_MAY_EXEC      0x004                                     │  |
|  │                                                                       │  |
|  │  这些值定义了权限模型                                                 │  |
|  │  改变它们会影响所有使用权限检查的代码                                 │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  5. STRUCT LAYOUTS (结构体布局)                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  结构体 = 数据契约                                                    │  |
|  │                                                                       │  |
|  │  // 公开结构体的字段布局是架构的一部分                                │  |
|  │  struct svc_fh {                                                      │  |
|  │      struct kref       fh_ref;      // 引用计数                       │  |
|  │      struct dentry     *fh_dentry;  // 缓存的 dentry                  │  |
|  │      struct svc_export *fh_export;  // 关联的导出                     │  |
|  │      ...                                                              │  |
|  │  };                                                                   │  |
|  │                                                                       │  |
|  │  添加/删除/重排字段可能破坏 ABI                                       │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 核心总结

```
+===========================================================================+
|                ARCHITECTURE DELIVERABLES SUMMARY                           |
|                架构产出总结                                                |
+===========================================================================+
|                                                                            |
|  架构设计的真正产出是「约束」，不是「文档」                                |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  STABLE DECISIONS (稳定决策)                                          │  |
|  │  • 错误如何表示和传播                                                 │  |
|  │  • 数据如何在模块间传递                                               │  |
|  │  • 依赖关系是什么样的                                                 │  |
|  │                                                                       │  |
|  │  PROHIBITIONS (禁止事项)                                              │  |
|  │  • 不能绕过哪些抽象层                                                 │  |
|  │  • 不能直接访问哪些内部数据                                           │  |
|  │  • 不能违反哪些顺序约束                                               │  |
|  │                                                                       │  |
|  │  DEFAULT CONSTRAINTS (默认约束)                                       │  |
|  │  • 资源如何获取和释放                                                 │  |
|  │  • 命名遵循什么规则                                                   │  |
|  │  • 错误处理用什么模式                                                 │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  这些约束体现在：                                                          |
|  • 头文件设计                                                              |
|  • 函数签名                                                                |
|  • 类型定义                                                                |
|  • 代码注释（描述契约）                                                    |
|  • 代码审查标准                                                            |
|                                                                            |
|  关键洞察：                                                                |
|  架构 = 代码中「不变的部分」+ 「变化的边界」                               |
|                                                                            |
+============================================================================+
```
