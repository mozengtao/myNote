# 八、为后续学习建立思维锚点

## 学到一个架构模式时，应该先问什么？

```
ARCHITECTURE PATTERN EVALUATION QUESTIONS (架构模式评估问题)
+===========================================================================+
|                                                                            |
|  当你学习一个新的架构模式时，按顺序问这些问题：                             |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Q1: 这个模式解决什么「工程问题」？                                   │  |
|  │  ────────────────────────────────                                     │  |
|  │  不是「这个模式是什么」                                               │  |
|  │  而是「什么场景下，不用这个模式会出问题」                             │  |
|  │                                                                       │  |
|  │  例如「操作表模式」：                                                 │  |
|  │  ✗ 坏回答："用函数指针实现多态"                                      │  |
|  │  ✓ 好回答："让调用者不需要知道具体实现，                              │  |
|  │            支持运行时选择不同实现，                                   │  |
|  │            新增实现不需要修改调用者代码"                              │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Q2: 这个模式的「代价」是什么？                                       │  |
|  │  ──────────────────────────                                           │  |
|  │  每个架构决策都有成本                                                 │  |
|  │  不了解成本就无法判断何时使用                                         │  |
|  │                                                                       │  |
|  │  例如「操作表模式」的代价：                                           │  |
|  │  • 间接调用，略有性能损失                                             │  |
|  │  • 调试时看不到函数名，需要查表                                       │  |
|  │  • 接口一旦确定，很难修改                                             │  |
|  │  • 需要理解整个操作表才能理解系统                                     │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Q3: 这个模式的「适用边界」是什么？                                   │  |
|  │  ─────────────────────────────                                        │  |
|  │  在什么条件下有效？                                                   │  |
|  │  在什么条件下不应该使用？                                             │  |
|  │                                                                       │  |
|  │  例如「操作表模式」的边界：                                           │  |
|  │  ✓ 适用：多种实现，需要运行时选择                                     │  |
|  │  ✓ 适用：实现可能增加                                                 │  |
|  │  ✗ 不适用：只有一个实现，未来也不会有第二个                           │  |
|  │  ✗ 不适用：极端性能敏感（如中断处理）                                 │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Q4: 我在哪里见过这个模式的「真实使用」？                             │  |
|  │  ─────────────────────────────────────                                │  |
|  │  不是玩具例子，是生产代码                                             │  |
|  │                                                                       │  |
|  │  例如「操作表模式」在 Linux 中：                                      │  |
|  │  • struct file_operations (VFS)                                       │  |
|  │  • struct net_device_ops (网络)                                       │  |
|  │  • struct block_device_operations (块设备)                            │  |
|  │  • struct platform_driver (设备驱动)                                  │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Q5: 如果我的项目用这个模式，要改什么？                               │  |
|  │  ────────────────────────────────────                                 │  |
|  │  立即思考迁移路径                                                     │  |
|  │  不只是理论学习                                                       │  |
|  │                                                                       │  |
|  │  例如在你的项目中引入「操作表」：                                     │  |
|  │  • 需要定义哪些操作？                                                 │  |
|  │  • 谁来实现这些操作？                                                 │  |
|  │  • 现有代码需要怎么改？                                               │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 看到 C/C++ 代码时，如何快速判断架构层 vs 实现层？

### 判断流程图

```
CODE CLASSIFICATION FLOWCHART (代码分类流程)
+===========================================================================+
|                                                                            |
|                     ┌──────────────────────┐                               |
|                     │   这段代码在哪里？    │                               |
|                     └──────────┬───────────┘                               |
|                                │                                           |
|           ┌────────────────────┼────────────────────┐                      |
|           ▼                    ▼                    ▼                      |
|     头文件 (.h)          .c 文件顶部          .c 文件函数内部              |
|           │                    │                    │                      |
|           │                    │                    ▼                      |
|           │                    │              ┌──────────┐                 |
|           │                    │              │  实现层   │                 |
|           │                    │              │ 几乎确定  │                 |
|           │                    │              └──────────┘                 |
|           │                    │                                           |
|           ▼                    ▼                                           |
|     ┌──────────┐        ┌──────────┐                                       |
|     │  架构层   │        │ 继续判断  │                                       |
|     │ 几乎确定  │        └────┬─────┘                                       |
|     └──────────┘             │                                             |
|                              ▼                                             |
|                    ┌─────────────────────┐                                 |
|                    │  有 static 关键字？  │                                 |
|                    └──────────┬──────────┘                                 |
|                               │                                            |
|                    ┌──────────┴──────────┐                                 |
|                    ▼                     ▼                                 |
|                   YES                   NO                                 |
|                    │                     │                                 |
|                    ▼                     ▼                                 |
|              ┌──────────┐          ┌──────────────┐                        |
|              │  实现层   │          │ 可能是架构层  │                        |
|              └──────────┘          │ 需要进一步判断 │                        |
|                                    └──────┬───────┘                        |
|                                           │                                |
|                                           ▼                                |
|                              ┌────────────────────────┐                    |
|                              │ 其他模块会调用这个吗？  │                    |
|                              └───────────┬────────────┘                    |
|                                          │                                 |
|                               ┌──────────┴──────────┐                      |
|                               ▼                     ▼                      |
|                              YES                   NO                      |
|                               │                     │                      |
|                               ▼                     ▼                      |
|                         ┌──────────┐          ┌──────────┐                 |
|                         │  架构层   │          │  实现层   │                 |
|                         └──────────┘          └──────────┘                 |
|                                                                            |
+============================================================================+
```

### 快速识别标志

```
QUICK IDENTIFICATION MARKERS (快速识别标志)
+===========================================================================+
|                                                                            |
|  ARCHITECTURE LAYER MARKERS (架构层标志)                                   |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  1. 在头文件中声明                                                    │  |
|  │     __be32 nfsd_open(...);  // 在 .h 中                               │  |
|  │                                                                       │  |
|  │  2. 结构体定义（尤其是操作表）                                        │  |
|  │     struct file_operations { ... };                                   │  |
|  │     struct svc_fh { ... };                                            │  |
|  │                                                                       │  |
|  │  3. 类型定义                                                          │  |
|  │     typedef __u32 __be32;                                             │  |
|  │                                                                       │  |
|  │  4. 宏定义（公开的）                                                  │  |
|  │     #define NFSD_MAY_READ 0x001                                       │  |
|  │                                                                       │  |
|  │  5. 没有 static 的函数                                                │  |
|  │     __be32 nfsd_read(...) { ... }                                     │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  IMPLEMENTATION LAYER MARKERS (实现层标志)                                 |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  1. static 关键字                                                     │  |
|  │     static struct raparms { ... };                                    │  |
|  │     static int nfsd_get_raparms(...) { ... }                          │  |
|  │                                                                       │  |
|  │  2. 只在 .c 文件中定义的宏                                            │  |
|  │     #define RAPARM_HASH_BITS 4  // 在 vfs.c 中                        │  |
|  │                                                                       │  |
|  │  3. 函数内部的局部变量和逻辑                                          │  |
|  │     int host_err;                                                     │  |
|  │     for (i = 0; i < HASH_SIZE; i++) { ... }                           │  |
|  │                                                                       │  |
|  │  4. 算法实现细节                                                      │  |
|  │     hash = jhash_2words(dev, ino, 0xfeedbeef);                        │  |
|  │                                                                       │  |
|  │  5. 优化路径选择                                                      │  |
|  │     if (file->f_op->splice_read) { ... } else { ... }                 │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

### 以 NFSD VFS 为例

```c
// fs/nfsd/vfs.c 中的例子

// ═══════════════════════════════════════════════════════════════
// ARCHITECTURE LAYER (架构层)
// ═══════════════════════════════════════════════════════════════

// 1. 公开的函数（没有 static）
__be32 nfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, ...);
__be32 nfsd_read(struct svc_rqst *rqstp, struct svc_fh *fhp, ...);
__be32 nfsd_write(struct svc_rqst *rqstp, struct svc_fh *fhp, ...);

// 为什么是架构层？
// - 其他模块（nfs3proc.c, nfs4proc.c）会调用这些函数
// - 函数签名是契约，改变会影响多个文件
// - 这些函数定义了 NFSD VFS 子系统的边界

// 2. 错误转换函数
__be32 nfserrno(int errno);

// 为什么是架构层？
// - 定义了错误如何跨层传播
// - 所有 NFSD 代码都依赖这个转换

// ═══════════════════════════════════════════════════════════════
// IMPLEMENTATION LAYER (实现层)
// ═══════════════════════════════════════════════════════════════

// 1. static 结构体和变量
static struct raparm_hbucket raparm_hash[RAPARM_HASH_SIZE];

// 为什么是实现层？
// - 其他文件看不到这个数组
// - 可以随时换成红黑树，不影响其他代码

// 2. static 函数
static inline struct raparms *nfsd_get_raparms(dev_t dev, ino_t ino);
static __be32 nfsd_vfs_read(...);

// 为什么是实现层？
// - 只被本文件内的代码调用
// - 可以自由修改签名

// 3. 内部常量
#define RAPARM_HASH_BITS    4
#define RAPARM_HASH_SIZE    (1<<RAPARM_HASH_BITS)

// 为什么是实现层？
// - 只在本文件使用
// - 改成 8 不影响任何接口

// 4. 算法细节
hash = jhash_2words(dev, ino, 0xfeedbeef) & RAPARM_HASH_MASK;
msleep(10);  // gathered writes delay

// 为什么是实现层？
// - 调用者不知道用了什么哈希函数
// - 调用者不知道有这个延迟
```

---

## 建立思维习惯

```
MENTAL HABITS FOR ARCHITECTURE (架构思维习惯)
+===========================================================================+
|                                                                            |
|  HABIT 1: 看到代码先问「这是给谁用的？」                                   |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  • 只给自己用 → 实现层，可以随时改                                    │  |
|  │  • 给其他模块用 → 架构层，改动要谨慎                                  │  |
|  │  • 给外部系统用 → 接口层，改动需要版本化                              │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  HABIT 2: 看到修改先问「这会影响几个文件？」                               |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  • 1 个文件 → 安全，随便改                                            │  |
|  │  • 2-5 个文件 → 需要确认依赖关系                                      │  |
|  │  • > 5 个文件 → 这是架构变更，需要设计评审                            │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  HABIT 3: 写代码时问「三个月后别人怎么改这里？」                           |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  • 需要理解多少上下文？                                               │  |
|  │  • 有哪些隐式依赖？                                                   │  |
|  │  • 改了会不会破坏其他地方？                                           │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  HABIT 4: 添加功能时问「这应该放在哪一层？」                               |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  • 是通用能力还是特定实现？                                           │  |
|  │  • 需要被其他模块使用吗？                                             │  |
|  │  • 和现有抽象是什么关系？                                             │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  HABIT 5: 遇到问题时问「这是架构问题还是实现问题？」                       |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  架构问题：需要改多个模块，需要协调，成本高                           │  |
|  │  实现问题：可以局部修复，影响范围小                                   │  |
|  │                                                                       │  |
|  │  区分后才能选择正确的解决方案                                         │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 始终回答的三个问题

```
THREE QUESTIONS TO ALWAYS ANSWER (始终要回答的三个问题)
+===========================================================================+
|                                                                            |
|  对于每一个架构决策，都要能回答：                                          |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Q1: 这个决策解决了什么工程问题？                                     │  |
|  │  ───────────────────────────────                                      │  |
|  │                                                                       │  |
|  │  不是「这样更优雅」「这是最佳实践」                                   │  |
|  │  而是「如果不这样，具体会出什么问题」                                 │  |
|  │                                                                       │  |
|  │  例如 NFSD 使用 svc_fh 而不是 dentry：                                │  |
|  │  • 问题：NFS 客户端没有登录，权限检查和本地不同                       │  |
|  │  • 解决：svc_fh 封装了 NFS 特有的权限检查逻辑                         │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Q2: 如果不这样设计，最坏的后果是什么？                               │  |
|  │  ─────────────────────────────────────                                │  |
|  │                                                                       │  |
|  │  不是「不太好」「不够优雅」                                           │  |
|  │  而是「具体会发生什么故障」                                           │  |
|  │                                                                       │  |
|  │  例如如果绕过 fh_verify 直接访问 dentry：                             │  |
|  │  • 最坏后果：未授权用户可以读写任意文件                               │  |
|  │  • 这是安全漏洞，不只是「设计不好」                                   │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Q3: 如何把这个理解迁移到自己的项目中？                               │  |
|  │  ─────────────────────────────────────                                │  |
|  │                                                                       │  |
|  │  不是「Linux 这样做很厉害」                                           │  |
|  │  而是「我的项目有没有类似场景？怎么应用？」                           │  |
|  │                                                                       │  |
|  │  例如我的项目也需要权限检查：                                         │  |
|  │  • 是否应该有一个统一的"句柄"封装权限检查？                          │  |
|  │  • 调用者应该直接操作数据还是通过句柄？                               │  |
|  │  • 权限检查逻辑应该放在哪一层？                                       │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 核心总结

```
+===========================================================================+
|                     THINKING ANCHORS SUMMARY                               |
|                     思维锚点总结                                           |
+===========================================================================+
|                                                                            |
|  学习架构模式时：                                                          |
|  1. 先问「解决什么问题」，不是「怎么实现」                                 |
|  2. 理解「代价」，不是只看「好处」                                         |
|  3. 找「真实使用」，不是只看「玩具例子」                                   |
|  4. 想「如何应用」，不是只「理论学习」                                     |
|                                                                            |
|  看代码时：                                                                |
|  1. 头文件 → 几乎肯定是架构                                                |
|  2. static → 几乎肯定是实现                                                |
|  3. 被多个文件调用 → 架构层                                                |
|  4. 只被本文件使用 → 实现层                                                |
|                                                                            |
|  写代码时：                                                                |
|  1. 想想「这是给谁用的」                                                   |
|  2. 想想「改了会影响谁」                                                   |
|  3. 想想「三个月后怎么改」                                                 |
|                                                                            |
|  架构思维的本质：                                                          |
|  • 不是记住模式名称                                                        |
|  • 而是能识别「高代价决策」和「低代价决策」                                |
|  • 对高代价决策花时间设计                                                  |
|  • 对低代价决策快速实现，等需要时再优化                                    |
|                                                                            |
+============================================================================+
```
