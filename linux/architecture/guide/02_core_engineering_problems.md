# 二、架构解决的核心工程问题（WHY 架构存在）

## 1. 规模问题（Scale）

### 代码规模增长时，最先崩溃的是什么？

```
CODE SCALE PROGRESSION (代码规模演进)
+========================================================================+
|                                                                         |
|  1K Lines                                                               |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │  • One person can hold everything in head                        │   |
|  │  • No formal interfaces needed                                   │   |
|  │  • Global variables are "convenient"                             │   |
|  │  • 一个人能记住所有代码，全局变量"很方便"                        │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                              ▼                                          |
|  10K Lines - FIRST COLLAPSE POINT (第一个崩溃点)                        |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │  ✗ WHAT BREAKS: Mental model (心智模型崩溃)                      │   |
|  │    - "Where was that function defined?"                          │   |
|  │    - "Who calls this? Who does this call?"                       │   |
|  │    - "What side effects does this have?"                         │   |
|  │                                                                   │   |
|  │  ✓ SOLUTION: File organization + naming conventions              │   |
|  │    解决方案：文件组织 + 命名约定                                  │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                              ▼                                          |
|  100K Lines - SECOND COLLAPSE POINT (第二个崩溃点)                      |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │  ✗ WHAT BREAKS: Dependency management (依赖管理崩溃)             │   |
|  │    - Circular includes everywhere                                │   |
|  │    - Change one header → recompile 500 files                     │   |
|  │    - "I can't figure out which .o files I need"                  │   |
|  │                                                                   │   |
|  │  ✓ SOLUTION: Layered architecture + interface headers            │   |
|  │    解决方案：分层架构 + 接口头文件                                │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                              ▼                                          |
|  1M+ Lines - THIRD COLLAPSE POINT (第三个崩溃点)                        |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │  ✗ WHAT BREAKS: Coordination (协调崩溃)                          │   |
|  │    - Team A's change breaks Team B's code                        │   |
|  │    - "Which version of struct X are we using?"                   │   |
|  │    - Integration takes weeks, not hours                          │   |
|  │                                                                   │   |
|  │  ✓ SOLUTION: Subsystem boundaries + stable APIs                  │   |
|  │    解决方案：子系统边界 + 稳定 API                                │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
+=========================================================================+
```

**中文说明：**

规模增长时，崩溃顺序是：
1. **10K 行**：人脑记不住了 → 需要清晰的文件/函数划分
2. **100K 行**：编译和依赖混乱 → 需要分层和接口隔离
3. **1M 行**：团队协作冲突 → 需要子系统边界和版本化 API

### 以 NFSD VFS 为例

```c
// fs/nfsd/vfs.c 约 2300 行
// 如果没有架构，会发生什么？

// 假设把所有 NFSD 代码放一个文件：
// - nfsd_main.c: 50000+ lines
// - 包含：网络处理 + 协议解析 + VFS操作 + 缓存 + 锁 + 导出管理

// 问题 1: 编译时间
// 改一个常量，重新编译 50000 行

// 问题 2: 理解成本
// "nfsd_read() 调用了谁？" → 需要搜索 50000 行

// 问题 3: 并发修改
// 两个人同时改 nfsd_main.c → 冲突

// 实际的架构解决方案：
fs/nfsd/
├── vfs.c        (2294 lines)  ← VFS 操作
├── nfsproc.c    (~600 lines)  ← NFSv2
├── nfs3proc.c   (~700 lines)  ← NFSv3  
├── nfs4proc.c   (~2000 lines) ← NFSv4
├── nfssvc.c     (~700 lines)  ← 服务管理
└── export.c     (~800 lines)  ← 导出管理

// 每个文件有明确职责，可以独立编译、独立修改
```

### "代码能跑" ≠ "系统能演进"

```
"WORKS" vs "EVOLVABLE" (能跑 vs 能演进)
+=====================================================================+
|                                                                      |
|  CODE THAT "WORKS" (能跑的代码):                                     |
|  ┌────────────────────────────────────────────────────────────────┐ |
|  │  int handle_request(char *data, int len) {                      │ |
|  │      if (data[0] == 'A') {                                      │ |
|  │          // 500 lines of protocol A handling                    │ |
|  │          if (data[1] == 'X') {                                  │ |
|  │              // 200 lines of subtype X                          │ |
|  │          }                                                      │ |
|  │      } else if (data[0] == 'B') {                               │ |
|  │          // 400 lines of protocol B handling                    │ |
|  │      }                                                          │ |
|  │      // ... 20 more branches                                    │ |
|  │  }                                                              │ |
|  └────────────────────────────────────────────────────────────────┘ |
|                                                                      |
|  CAN'T EVOLVE BECAUSE (无法演进因为):                                |
|  • 添加 Protocol C: 必须理解整个 2000 行函数                        |
|  • 修复 Protocol A bug: 可能意外影响 Protocol B                     |
|  • 测试 Protocol B: 无法隔离测试                                    |
|  • 两人并行开发: 必须 merge 同一个巨大函数                          |
|                                                                      |
+======================================================================+
|                                                                      |
|  CODE THAT "EVOLVES" (能演进的代码):                                 |
|  ┌────────────────────────────────────────────────────────────────┐ |
|  │  // 架构层：定义接口                                             │ |
|  │  struct protocol_handler {                                       │ |
|  │      char id;                                                    │ |
|  │      int (*handle)(char *data, int len);                        │ |
|  │  };                                                              │ |
|  │                                                                  │ |
|  │  // 实现层：各自独立                                             │ |
|  │  static int handle_protocol_a(char *data, int len);             │ |
|  │  static int handle_protocol_b(char *data, int len);             │ |
|  │                                                                  │ |
|  │  // 调度层：简单查表                                             │ |
|  │  int handle_request(char *data, int len) {                      │ |
|  │      return handlers[data[0]].handle(data, len);                │ |
|  │  }                                                              │ |
|  └────────────────────────────────────────────────────────────────┘ |
|                                                                      |
+======================================================================+
```

---

## 2. 变化问题（Change）

### 哪些变化是"不可避免的"？

```
INEVITABLE CHANGES IN SOFTWARE SYSTEMS (不可避免的变化)
+========================================================================+
|                                                                         |
|  PROTOCOL/FORMAT CHANGES (协议/格式变化)                                |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │  NFSv2 → NFSv3 → NFSv4 → NFSv4.1 → NFSv4.2                       │   |
|  │  新版本添加新字段、新操作、新语义                                 │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
|  PLATFORM CHANGES (平台变化)                                            |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │  32-bit → 64-bit                                                  │   |
|  │  x86 → ARM → RISC-V                                               │   |
|  │  单核 → 多核 → NUMA                                               │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
|  REQUIREMENT CHANGES (需求变化)                                         |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │  "We need ACL support"                                            │   |
|  │  "We need encryption"                                             │   |
|  │  "We need quota"                                                  │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
|  PERFORMANCE CHANGES (性能变化)                                         |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │  "splice() is faster than read/write for large files"            │   |
|  │  "We need zero-copy networking"                                   │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
+=========================================================================+
```

### 架构如何控制变化的传播范围？

```
CHANGE PROPAGATION CONTROL (变化传播控制)
+========================================================================+
|                                                                         |
|  WITHOUT ARCHITECTURE (无架构):                                         |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │                                                                   │   |
|  │      ┌───┐  ┌───┐  ┌───┐  ┌───┐  ┌───┐                           │   |
|  │      │ A ├──┤ B ├──┤ C ├──┤ D ├──┤ E │                           │   |
|  │      └─┬─┘  └─┬─┘  └─┬─┘  └─┬─┘  └─┬─┘                           │   |
|  │        │      │      │      │      │                              │   |
|  │        └──────┴──────┼──────┴──────┘                              │   |
|  │                      │                                            │   |
|  │                    ┌─┴─┐                                          │   |
|  │                    │ F │                                          │   |
|  │                    └───┘                                          │   |
|  │                                                                   │   |
|  │  Change F → Must check A, B, C, D, E (改 F 必须检查 A,B,C,D,E)   │   |
|  │                                                                   │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
|  WITH ARCHITECTURE (有架构):                                            |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │                                                                   │   |
|  │   Layer 3:  ┌───┐  ┌───┐  ┌───┐                                  │   |
|  │   (Users)   │ A │  │ B │  │ C │                                  │   |
|  │             └─┬─┘  └─┬─┘  └─┬─┘                                  │   |
|  │               │      │      │                                     │   |
|  │   ════════════╪══════╪══════╪═══════  INTERFACE (接口)            │   |
|  │               │      │      │                                     │   |
|  │   Layer 2:  ┌─┴──────┴──────┴─┐                                  │   |
|  │   (Core)    │        X        │                                  │   |
|  │             └────────┬────────┘                                  │   |
|  │                      │                                            │   |
|  │   ═══════════════════╪═════════════  INTERFACE (接口)              │   |
|  │                      │                                            │   |
|  │   Layer 1:        ┌──┴──┐                                        │   |
|  │   (Platform)      │  F  │                                        │   |
|  │                   └─────┘                                        │   |
|  │                                                                   │   |
|  │  Change F (内部) → Only affects F                                │   |
|  │  Change F (接口) → Only affects X                                │   |
|  │  Change X (接口) → Only affects A, B, C                          │   |
|  │                                                                   │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
+=========================================================================+
```

### NFSD VFS 中的例子

```c
// fs/nfsd/vfs.c

// 架构隔离层：VFS 接口
// 当 VFS 内部实现改变（如 splice 优化），NFSD 代码几乎不用改
static __be32
nfsd_vfs_read(...)
{
    // 检查是否支持 splice（性能优化路径）
    if (file->f_op->splice_read && rqstp->rq_splice_ok) {
        // 新路径：使用 splice
        host_err = splice_direct_to_actor(file, &sd, ...);
    } else {
        // 旧路径：使用传统 read
        host_err = vfs_readv(file, ...);
    }
    // 无论哪条路径，上层代码都不用改！
}

// 变化隔离的关键：
// 1. nfsd_vfs_read 的签名不变
// 2. 错误返回方式不变（host_err → nfserrno）
// 3. 调用者 nfsd_read() 完全不用改
```

### 什么是"变化放大效应"？

```
CHANGE AMPLIFICATION EFFECT (变化放大效应)
+========================================================================+
|                                                                         |
|  SCENARIO: 添加一个新字段到核心数据结构                                 |
|                                                                         |
|  WITHOUT ENCAPSULATION (无封装):                                        |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │  // 到处直接访问结构体字段                                        │   |
|  │  struct file_info {                                               │   |
|  │      int size;                                                    │   |
|  │      int mode;                                                    │   |
|  │      // 新增: int flags;  ← 影响所有直接访问此结构的代码          │   |
|  │  };                                                               │   |
|  │                                                                   │   |
|  │  // file_a.c: if (info.size > 0 && info.mode == X) ...            │   |
|  │  // file_b.c: info.size = get_size();                             │   |
|  │  // file_c.c: memset(&info, 0, sizeof(info));  ← BUG!             │   |
|  │  //           sizeof(info) 变了！                                  │   |
|  │                                                                   │   |
|  │  1 line change → 50+ files to review                              │   |
|  │  变化放大倍数: 50x                                                 │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
|  WITH ENCAPSULATION (有封装):                                           |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │  // 通过函数访问，内部结构对外不可见                              │   |
|  │  struct file_info;  // opaque type (不透明类型)                   │   |
|  │                                                                   │   |
|  │  // 接口函数                                                      │   |
|  │  int file_info_get_size(struct file_info *);                      │   |
|  │  void file_info_init(struct file_info *);                         │   |
|  │                                                                   │   |
|  │  // 添加 flags: 只改 file_info.c 内部                             │   |
|  │  // 如果新接口：添加 file_info_get_flags()                        │   |
|  │                                                                   │   |
|  │  1 line change → 1-2 files to modify                              │   |
|  │  变化放大倍数: 1x                                                  │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
+=========================================================================+
```

---

## 3. 协作问题（Collaboration）

### 多人协作时，架构扮演什么角色？

```
ARCHITECTURE AS COLLABORATION CONTRACT (架构作为协作契约)
+========================================================================+
|                                                                         |
|  WITHOUT ARCHITECTURE (无架构):                                         |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │                                                                   │   |
|  │  Developer A: "我改了 struct X，你那边用到了吗？"                │   |
|  │  Developer B: "不确定，让我 grep 一下... 好像有 20 个地方"       │   |
|  │  Developer A: "那你帮我看看会不会 break？"                       │   |
|  │  Developer B: "我周末有空..."                                    │   |
|  │                                                                   │   |
|  │  问题：                                                           │   |
|  │  • 任何修改都可能影响任何人                                       │   |
|  │  • 无法独立开发和测试                                             │   |
|  │  • 代码 review 需要理解整个系统                                  │   |
|  │                                                                   │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
|  WITH ARCHITECTURE (有架构):                                            |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │                                                                   │   |
|  │  ┌──────────────┐    Interface    ┌──────────────┐              │   |
|  │  │   Module A   │◄───(stable)────►│   Module B   │              │   |
|  │  │              │                 │              │              │   |
|  │  │  Owner: Dev A│                 │  Owner: Dev B│              │   |
|  │  └──────────────┘                 └──────────────┘              │   |
|  │                                                                   │   |
|  │  规则：                                                           │   |
|  │  • Dev A 可以自由改 Module A 内部                                │   |
|  │  • 改 Interface 需要和 Dev B 协商                                │   |
|  │  • Dev B 的 Module B 只依赖 Interface，不依赖 A 的内部           │   |
|  │                                                                   │   |
|  │  效果：                                                           │   |
|  │  • 独立开发成为可能                                               │   |
|  │  • Code review 范围缩小到模块内部                                │   |
|  │  • 接口变更需要显式审批                                           │   |
|  │                                                                   │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
+=========================================================================+
```

### 为什么架构不清晰时，代码 Review 会变得无效？

```c
// SCENARIO: Review a change to nfsd_read()

// WITHOUT CLEAR ARCHITECTURE (架构不清晰时):
// Reviewer 必须回答这些问题：
// 1. 这个改动会影响 NFSv3 吗？NFSv4 呢？
// 2. 会影响 ACL 检查吗？
// 3. 会影响 quota 吗？
// 4. 错误处理路径都覆盖了吗？
// 5. 锁的顺序还对吗？
// 6. ...

// Reviewer 需要理解整个 NFSD 子系统才能 review 一个函数
// 结果：Review 变成形式主义，或者需要数小时

// WITH CLEAR ARCHITECTURE (架构清晰时):
// 架构约束已经回答了大部分问题：
// 
// vfs.c 的契约:
// - 只通过 VFS 接口访问文件系统
// - 通过 svc_fh 验证权限（fh_verify 调用）
// - 错误必须通过 nfserrno() 转换
// - 文件访问后必须 fh_put()
//
// Reviewer 只需要检查:
// 1. 是否遵守了这些契约？
// 2. 改动的函数内部逻辑是否正确？
//
// Review 时间：分钟级别
```

### Linux 内核的架构协作模式

```
LINUX KERNEL COLLABORATION MODEL (Linux 内核协作模型)
+========================================================================+
|                                                                         |
|  MAINTAINER HIERARCHY (维护者层级)                                      |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │                                                                   │   |
|  │                    ┌─────────────┐                                │   |
|  │                    │   Linus     │                                │   |
|  │                    │   (final)   │                                │   |
|  │                    └──────┬──────┘                                │   |
|  │            ┌──────────────┼──────────────┐                        │   |
|  │            ▼              ▼              ▼                        │   |
|  │     ┌───────────┐  ┌───────────┐  ┌───────────┐                  │   |
|  │     │ net/ 维护者│  │ fs/ 维护者 │  │ mm/ 维护者│                  │   |
|  │     └─────┬─────┘  └─────┬─────┘  └─────┬─────┘                  │   |
|  │           │              │              │                         │   |
|  │     ┌─────┴─────┐  ┌─────┴─────┐  ┌─────┴─────┐                  │   |
|  │     │ nfsd 维护者│  │ ext4 维护者│  │ slab 维护者│                  │   |
|  │     └───────────┘  └───────────┘  └───────────┘                  │   |
|  │                                                                   │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
|  HOW ARCHITECTURE ENABLES THIS (架构如何使之可行):                      |
|  ┌─────────────────────────────────────────────────────────────────┐   |
|  │                                                                   │   |
|  │  1. 子系统边界清晰 → 维护者职责清晰                              │   |
|  │  2. 接口稳定 → 子系统可以独立演进                                │   |
|  │  3. 依赖方向明确 → 变更影响可预测                                │   |
|  │                                                                   │   |
|  │  例如 NFSD 修改 vfs.c:                                            │   |
|  │  - 不涉及 VFS 接口 → nfsd 维护者自己决定                         │   |
|  │  - 涉及 VFS 接口 → 需要 fs/ 维护者审核                           │   |
|  │  - 涉及网络接口 → 需要 net/ 维护者审核                           │   |
|  │                                                                   │   |
|  └─────────────────────────────────────────────────────────────────┘   |
|                                                                         |
+=========================================================================+
```

---

## 核心总结

```
+========================================================================+
|            ARCHITECTURE SOLVES THREE ENGINEERING PROBLEMS              |
|            架构解决三个工程问题                                         |
+========================================================================+
|                                                                         |
|  1. SCALE (规模)                                                        |
|     问题：代码量增长，人脑无法处理                                      |
|     解法：分解为可独立理解的模块                                        |
|     指标：单个开发者能否独立理解一个模块？                              |
|                                                                         |
|  2. CHANGE (变化)                                                       |
|     问题：需求不断变化，每次变化代价巨大                                |
|     解法：隔离变化，限制传播范围                                        |
|     指标：改一个需求需要改几个文件？                                    |
|                                                                         |
|  3. COLLABORATION (协作)                                                |
|     问题：多人同时开发，频繁冲突                                        |
|     解法：明确边界和责任，允许独立开发                                  |
|     指标：两个开发者能否同时工作而不互相阻塞？                          |
|                                                                         |
+=========================================================================+
```

**中文总结：**

架构不是为了「好看」或「正确」，而是为了解决真实的工程问题：
1. **规模**：让系统可以被人类理解（否则没人敢改）
2. **变化**：让修改的代价可控（否则改一处崩百处）
3. **协作**：让团队可以并行工作（否则天天等别人）

判断架构好坏的最简单方法：
- 新人多久能独立贡献代码？
- 改一个功能需要跨几个模块？
- 两个人能不能同时改不同功能？
