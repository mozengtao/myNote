# 三、架构 vs 实现：本质区别

## 架构与实现的对比

```
ARCHITECTURE vs IMPLEMENTATION COMPARISON (架构 vs 实现对比)
+===========================================================================+
|                                                                            |
|   DIMENSION        ARCHITECTURE (架构)         IMPLEMENTATION (实现)       |
|   ─────────        ───────────────────         ─────────────────────       |
|                                                                            |
|   FOCUS            WHAT components exist       HOW each component works    |
|   关注点           有哪些组件                   每个组件怎么工作            |
|                    WHO talks to whom           WHICH algorithm to use      |
|                    谁和谁通信                   用什么算法                  |
|                                                                            |
|   STABILITY        Very stable                 Can change frequently       |
|   稳定性           非常稳定                     可以频繁变化                |
|                    Changes once per years      Changes weekly/monthly      |
|                    几年改一次                   每周/月都可能改             |
|                                                                            |
|   CHANGE FREQ      Very low                    High                        |
|   变化频率         非常低                       高                          |
|                    Should resist change        Should embrace change       |
|                    应该抵抗变化                 应该拥抱变化                |
|                                                                            |
|   ERROR COST       Extremely high              Moderate                    |
|   错误代价         极高                         中等                        |
|                    May require rewrite         Local fix possible          |
|                    可能需要重写                 可以局部修复                |
|                                                                            |
|   VISIBILITY       Cross-module/system         Single module/function      |
|   可见性           跨模块/系统可见              单模块/函数内部             |
|                                                                            |
|   REVERSIBILITY    Very hard to reverse        Easy to reverse             |
|   可逆性           很难逆转                     容易逆转                    |
|                                                                            |
+============================================================================+
```

---

## 以 NFSD VFS 为例的具体对比

### 架构决策示例

```c
// fs/nfsd/vfs.c

// ═══════════════════════════════════════════════════════════════
// ARCHITECTURE DECISION 1: Error Representation (错误表示)
// ═══════════════════════════════════════════════════════════════
// 决策：所有 NFS 操作返回 __be32 类型的 NFS 协议错误
// 内部错误通过 nfserrno() 转换

__be32 nfsd_open(...)  // 返回 __be32
{
    int host_err;        // 内部用 int
    ...
    err = nfserrno(host_err);  // 转换点
    return err;
}

// 为什么是架构决策？
// - 影响所有 NFSD 函数的签名
// - 定义了错误如何跨层传播
// - 改变它需要修改几十个函数

// ═══════════════════════════════════════════════════════════════
// ARCHITECTURE DECISION 2: File Access Abstraction (文件访问抽象)
// ═══════════════════════════════════════════════════════════════
// 决策：通过 struct svc_fh（file handle）访问文件，而不是直接用 dentry

__be32 nfsd_read(struct svc_rqst *rqstp, 
                 struct svc_fh *fhp,     // ← 抽象层
                 loff_t offset, ...)

// 为什么是架构决策？
// - svc_fh 封装了权限检查、导出验证、锁管理
// - 所有文件操作都依赖这个抽象
// - 改变它需要重新设计整个 NFSD 子系统

// ═══════════════════════════════════════════════════════════════
// ARCHITECTURE DECISION 3: Version Separation (版本分离)
// ═══════════════════════════════════════════════════════════════
// 决策：NFSv2, NFSv3, NFSv4 有独立的 proc 文件，共享 vfs.c

// 结构：
// fs/nfsd/
// ├── vfs.c        ← 共享的 VFS 操作层
// ├── nfsproc.c    ← NFSv2 specific
// ├── nfs3proc.c   ← NFSv3 specific
// └── nfs4proc.c   ← NFSv4 specific

// 条件编译保护版本特定代码
#ifdef CONFIG_NFSD_V3
__be32 nfsd_access(...)  // NFSv3+ only
#endif

#ifdef CONFIG_NFSD_V4
__be32 nfsd4_set_nfs4_acl(...)  // NFSv4 only
#endif
```

### 实现决策示例

```c
// fs/nfsd/vfs.c

// ═══════════════════════════════════════════════════════════════
// IMPLEMENTATION DECISION 1: Readahead Cache (预读缓存)
// ═══════════════════════════════════════════════════════════════
// 决策：用 hash table 缓存 readahead 参数，16 个 bucket

#define RAPARM_HASH_BITS    4
#define RAPARM_HASH_SIZE    (1<<RAPARM_HASH_BITS)  // 16
static struct raparm_hbucket raparm_hash[RAPARM_HASH_SIZE];

// 哈希函数选择
hash = jhash_2words(dev, ino, 0xfeedbeef) & RAPARM_HASH_MASK;

// 为什么是实现决策？
// - 完全封装在 vfs.c 内部
// - 可以随时改成 32 个 bucket，或用不同的哈希函数
// - 上层代码 (nfsd_read) 完全不需要知道这个缓存的存在

// ═══════════════════════════════════════════════════════════════
// IMPLEMENTATION DECISION 2: Gathered Writes (聚合写入)
// ═══════════════════════════════════════════════════════════════
// NFSv2 的写入聚合策略

static int wait_for_concurrent_writes(struct file *file)
{
    ...
    if (atomic_read(&inode->i_writecount) > 1 || ...) {
        msleep(10);  // ← 实现细节：等待 10ms
    }
    ...
}

// 为什么是实现决策？
// - 10ms 可以调成 20ms，上层不受影响
// - 整个函数可以被移除或重写
// - 只影响 NFSv2 写入性能，不影响接口

// ═══════════════════════════════════════════════════════════════
// IMPLEMENTATION DECISION 3: Read Path Selection (读取路径选择)
// ═══════════════════════════════════════════════════════════════

static __be32 nfsd_vfs_read(...)
{
    // 实现决策：优先使用 splice，否则用 readv
    if (file->f_op->splice_read && rqstp->rq_splice_ok) {
        host_err = splice_direct_to_actor(file, &sd, ...);
    } else {
        host_err = vfs_readv(file, ...);
    }
}

// 为什么是实现决策？
// - 调用者 nfsd_read() 不知道使用了哪条路径
// - 可以添加第三条路径（如 io_uring）不改接口
// - 这是性能优化，不影响正确性
```

---

## 一旦写进架构就很难改的决策

```
HARD-TO-CHANGE ARCHITECTURAL DECISIONS (难以改变的架构决策)
+===========================================================================+
|                                                                            |
|  1. DATA STRUCTURE LAYOUT IN PUBLIC HEADERS (公开头文件中的数据结构)       |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  // include/linux/nfsd/nfsfh.h                                      │   |
|  │  struct svc_fh {                                                    │   |
|  │      struct kref       fh_ref;                                      │   |
|  │      struct dentry     *fh_dentry;                                  │   |
|  │      struct svc_export *fh_export;                                  │   |
|  │      ...                                                            │   |
|  │  };                                                                 │   |
|  │                                                                      │   |
|  │  一旦这个结构被多个模块直接访问，任何字段改动都是 ABI break          │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  2. FUNCTION SIGNATURES IN PUBLIC HEADERS (公开头文件中的函数签名)         |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  // 改签名 = 改所有调用者                                            │   |
|  │  __be32 nfsd_open(struct svc_rqst *rqstp,                           │   |
|  │                   struct svc_fh *fhp,                               │   |
|  │                   int type,                                         │   |
|  │                   int access,                                       │   |
|  │                   struct file **filp);                              │   |
|  │                                                                      │   |
|  │  想加一个参数？所有调用点都要改                                      │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  3. ERROR CODE SEMANTICS (错误码语义)                                      |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  // nfserrno() 的映射规则是架构                                      │   |
|  │  // -ENOENT → nfserr_noent                                          │   |
|  │  // -EACCES → nfserr_acces                                          │   |
|  │                                                                      │   |
|  │  改变映射规则会破坏所有依赖错误语义的客户端                          │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  4. CALLBACK/HOOK INTERFACES (回调/钩子接口)                               |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  // VFS 操作表是架构级接口                                           │   |
|  │  struct file_operations {                                           │   |
|  │      ssize_t (*read)(...);                                          │   |
|  │      ssize_t (*write)(...);                                         │   |
|  │      int (*open)(...);                                              │   |
|  │      ...                                                            │   |
|  │  };                                                                 │   |
|  │                                                                      │   |
|  │  添加一个新操作 = 所有文件系统都要考虑是否实现                       │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  5. LOCKING ORDER (锁顺序)                                                 |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  // Documentation/filesystems/locking.rst                           │   |
|  │  // 定义了锁的获取顺序                                               │   |
|  │                                                                      │   |
|  │  fh_lock(parent);     // 必须先锁父目录                              │   |
|  │  lookup_one_len();    // 然后查找                                    │   |
|  │  // 如果改变顺序 → 死锁                                              │   |
|  │                                                                      │   |
|  │  锁顺序一旦确定，所有使用这些锁的代码都必须遵守                      │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
+============================================================================+
```

---

## 应该推迟到实现阶段的决策

```
DECISIONS TO DEFER TO IMPLEMENTATION (应推迟的决策)
+===========================================================================+
|                                                                            |
|  1. ALGORITHM CHOICE (算法选择)                                            |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  // 哈希函数、排序算法、搜索策略                                     │   |
|  │  hash = jhash_2words(dev, ino, 0xfeedbeef);  // 可以换成 xxhash      │   |
|  │                                                                      │   |
|  │  只要接口不变（输入 dev+ino，输出 hash），实现可以随时优化           │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  2. BUFFER SIZES (缓冲区大小)                                              |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  #define RAPARM_HASH_SIZE (1<<RAPARM_HASH_BITS)                     │   |
|  │                                                                      │   |
|  │  只要是 static/内部定义，可以根据性能测试调整                        │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  3. OPTIMIZATION PATHS (优化路径)                                          |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  if (file->f_op->splice_read && rqstp->rq_splice_ok) {              │   |
|  │      // 快速路径                                                     │   |
|  │  } else {                                                           │   |
|  │      // 慢速路径                                                     │   |
|  │  }                                                                  │   |
|  │                                                                      │   |
|  │  可以随时添加新的优化路径，不影响调用者                              │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  4. INTERNAL DATA STRUCTURES (内部数据结构)                                |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  // static = 文件私有，可以自由改动                                  │   |
|  │  static struct raparms {                                            │   |
|  │      struct raparms *p_next;  // 链表实现                            │   |
|  │      ...                                                            │   |
|  │  };                                                                 │   |
|  │                                                                      │   |
|  │  可以改成红黑树、跳表，只要接口函数不变                              │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
|  5. TIMING/DELAYS (时间/延迟)                                              |
|  ┌────────────────────────────────────────────────────────────────────┐   |
|  │  msleep(10);  // gathered writes 延迟                                │   |
|  │                                                                      │   |
|  │  可以改成 msleep(20) 或动态计算，都是实现细节                        │   |
|  └────────────────────────────────────────────────────────────────────┘   |
|                                                                            |
+============================================================================+
```

---

## 判断决策属于架构还是实现的方法

```
DECISION CLASSIFICATION FLOWCHART (决策分类流程)
+===========================================================================+
|                                                                            |
|                    ┌─────────────────────────┐                             |
|                    │   这个决策影响几个文件？  │                             |
|                    └───────────┬─────────────┘                             |
|                                │                                           |
|               ┌────────────────┼────────────────┐                          |
|               ▼                ▼                ▼                          |
|          只有 1 个         2-5 个            > 5 个                        |
|               │                │                │                          |
|               │                │                │                          |
|               ▼                ▼                ▼                          |
|           ┌───────┐       ┌───────────┐    ┌───────────┐                  |
|           │ 实现层 │       │  灰色地带  │    │   架构层   │                  |
|           └───────┘       └───────────┘    └───────────┘                  |
|                                │                                           |
|                                ▼                                           |
|                    ┌─────────────────────────┐                             |
|                    │  这个决策改了会不会导致  │                             |
|                    │  接口/ABI break？        │                             |
|                    └───────────┬─────────────┘                             |
|                                │                                           |
|                    ┌───────────┴───────────┐                               |
|                    ▼                       ▼                               |
|                   YES                      NO                              |
|                    │                       │                               |
|                    ▼                       ▼                               |
|               ┌───────────┐           ┌───────┐                            |
|               │   架构层   │           │ 实现层 │                            |
|               └───────────┘           └───────┘                            |
|                                                                            |
+============================================================================+
```

**中文说明：**

实际判断时，问自己两个问题：

1. **改这个决策，需要动几个文件？**
   - 1 个文件 → 几乎肯定是实现
   - 5 个以上 → 几乎肯定是架构
   - 中间地带需要继续分析

2. **改这个决策，会不会破坏已有调用者？**
   - 会 → 架构决策
   - 不会 → 实现决策

### 具体例子

```c
// 问题：nfsd_vfs_read() 里选择 splice vs readv，是架构还是实现？

// 分析：
// Q1: 影响几个文件？ → 只影响 vfs.c
// Q2: 改了会破坏调用者吗？ → 不会，nfsd_read() 完全不知道内部用了什么
// 结论：实现决策

// 问题：把 nfsd_read() 的返回类型从 __be32 改成 int？

// 分析：
// Q1: 影响几个文件？ → 所有调用 nfsd_read() 的文件
// Q2: 改了会破坏调用者吗？ → 会，调用者期望 __be32
// 结论：架构决策，需要非常谨慎
```

---

## 核心理解

```
+========================================================================+
|              ARCHITECTURE vs IMPLEMENTATION ESSENCE                     |
|              架构 vs 实现的本质                                         |
+========================================================================+
|                                                                         |
|  ARCHITECTURE (架构):                                                   |
|  • 定义「边界在哪里」                                                   |
|  • 定义「谁可以依赖谁」                                                 |
|  • 定义「接口长什么样」                                                 |
|  • 改变代价极高，影响范围广                                             |
|                                                                         |
|  IMPLEMENTATION (实现):                                                 |
|  • 在边界内部「如何做」                                                 |
|  • 可以自由优化和重构                                                   |
|  • 只要接口不变，随便改                                                 |
|  • 改变代价低，影响范围小                                               |
|                                                                         |
|  KEY INSIGHT (关键洞察):                                                |
|  好的架构 = 最大化「可以自由改的部分」（实现）                          |
|           + 最小化「不能随便改的部分」（接口）                          |
|           + 尽早识别「不能改的部分」（核心架构）                        |
|                                                                         |
+=========================================================================+
```

**中文总结：**

1. 架构决策是「高成本」决策 —— 错了要改很多代码
2. 实现决策是「低成本」决策 —— 错了可以局部修复
3. 好的设计师知道哪些决策必须现在做对（架构），哪些可以以后再说（实现）
4. 在 C/C++ 中，头文件里的东西基本都是架构，`.c` 文件里 `static` 的东西基本都是实现
