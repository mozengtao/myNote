# 七、判断"是否需要架构设计"的准则

## 什么规模/类型的项目必须有架构？

```
WHEN ARCHITECTURE IS MANDATORY (何时架构是必须的)
+===========================================================================+
|                                                                            |
|  RULE 1: TEAM SIZE (团队规模)                                              |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  1 人             2-3 人           4+ 人                              │  |
|  │  ────             ──────           ─────                              │  |
|  │  可选             推荐             必须                               │  |
|  │                                                                       │  |
|  │  • 1 人可以靠记忆和习惯保持一致性                                     │  |
|  │  • 2-3 人需要口头约定 + 代码审查                                      │  |
|  │  • 4+ 人必须有明确的架构规则，否则一定会冲突                          │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  RULE 2: CODE SIZE (代码规模)                                              |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  < 5K lines      5K-20K lines     > 20K lines                        │  |
|  │  ──────────      ────────────     ───────────                        │  |
|  │  可选             推荐             必须                               │  |
|  │                                                                       │  |
|  │  • < 5K: 一个人可以理解全部代码                                       │  |
|  │  • 5K-20K: 需要模块划分帮助理解                                       │  |
|  │  • > 20K: 没有架构就无法维护                                          │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  RULE 3: LIFETIME (生命周期)                                               |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  一次性脚本      短期项目(< 1年)   长期项目(> 1年)                    │  |
|  │  ──────────      ──────────────    ───────────────                   │  |
|  │  不需要          推荐               必须                              │  |
|  │                                                                       │  |
|  │  • 一次性代码不需要维护                                               │  |
|  │  • 短期项目可以接受一定技术债务                                       │  |
|  │  • 长期项目的技术债务会随时间指数增长                                 │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  RULE 4: DOMAIN COMPLEXITY (领域复杂度)                                    |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  简单 CRUD        业务逻辑复杂      系统级软件                        │  |
|  │  ──────────       ────────────      ──────────                        │  |
|  │  可选              推荐              必须                              │  |
|  │                                                                       │  |
|  │  • CRUD: 框架提供架构，你只需遵守                                     │  |
|  │  • 业务逻辑: 需要领域模型设计                                         │  |
|  │  • 系统级: 必须精心设计，如 NFSD                                      │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

### 具体判断清单

```
ARCHITECTURE NECESSITY CHECKLIST (架构必要性检查清单)
+===========================================================================+
|                                                                            |
|  如果以下问题的回答是 YES，你需要架构：                                    |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  □ 代码会存活超过 6 个月？                                            │  |
|  │  □ 会有超过 1 个人开发？                                              │  |
|  │  □ 代码量会超过 5000 行？                                             │  |
|  │  □ 需要支持多种配置/平台？                                            │  |
|  │  □ 需要处理多种输入/协议？                                            │  |
|  │  □ 有性能/安全性要求？                                                │  |
|  │  □ 其他系统会依赖这个代码？                                           │  |
|  │  □ 需要支持扩展/插件？                                                │  |
|  │                                                                       │  |
|  │  如果 ≥ 3 个 YES → 必须有架构                                         │  |
|  │  如果 1-2 个 YES → 建议有架构                                         │  |
|  │  如果 0 个 YES → 可以简单处理                                         │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 什么情况下"过度架构"反而有害？

```
OVER-ARCHITECTURE ANTI-PATTERNS (过度架构反模式)
+===========================================================================+
|                                                                            |
|  ANTI-PATTERN 1: PREMATURE ABSTRACTION (过早抽象)                          |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  症状：                                                               │  |
|  │  • 只有一个实现的接口                                                 │  |
|  │  • 从未被使用的"扩展点"                                              │  |
|  │  • 比实现还复杂的抽象层                                               │  |
|  │                                                                       │  |
|  │  例子：                                                               │  |
|  │  // 过度设计                                                          │  |
|  │  struct file_reader_ops {                                             │  |
|  │      int (*open)(const char *path);                                   │  |
|  │      int (*read)(int fd, void *buf, size_t len);                      │  |
|  │      int (*close)(int fd);                                            │  |
|  │  };                                                                   │  |
|  │                                                                       │  |
|  │  struct file_reader_ops posix_reader = {                              │  |
|  │      .open = posix_open,                                              │  |
|  │      .read = posix_read,                                              │  |
|  │      .close = posix_close,                                            │  |
|  │  };                                                                   │  |
|  │  // 但永远只有一个实现...                                             │  |
|  │                                                                       │  |
|  │  正确做法：                                                           │  |
|  │  直接使用 open/read/close，等真的需要多个实现时再抽象                 │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ANTI-PATTERN 2: EXCESSIVE LAYERING (过多分层)                             |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  症状：                                                               │  |
|  │  • 调用栈深度超过 10 层                                               │  |
|  │  • 每层只是转发调用                                                   │  |
|  │  • 找一个 bug 需要穿过 5 个文件                                       │  |
|  │                                                                       │  |
|  │  例子：                                                               │  |
|  │  user_read()                                                          │  |
|  │    → read_manager_read()                                              │  |
|  │      → read_handler_read()                                            │  |
|  │        → read_processor_read()                                        │  |
|  │          → read_executor_read()                                       │  |
|  │            → actual_read()   // 终于到了实际操作                      │  |
|  │                                                                       │  |
|  │  正确做法：                                                           │  |
|  │  每一层应该有明确的职责，不是只转发调用                               │  |
|  │  Linux VFS 只有 3 层：syscall → VFS → 具体文件系统                    │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ANTI-PATTERN 3: CONFIGURATION EXPLOSION (配置爆炸)                        |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  症状：                                                               │  |
|  │  • 配置文件比代码还长                                                 │  |
|  │  • 大多数配置选项从不修改                                             │  |
|  │  • 配置错误导致难以调试的行为                                         │  |
|  │                                                                       │  |
|  │  例子：                                                               │  |
|  │  struct config {                                                      │  |
|  │      int buffer_size;           // 默认 4096                          │  |
|  │      int max_connections;       // 默认 100                           │  |
|  │      int timeout_ms;            // 默认 5000                          │  |
|  │      int retry_count;           // 默认 3                             │  |
|  │      bool enable_logging;       // 默认 true                          │  |
|  │      bool enable_metrics;       // 默认 true                          │  |
|  │      // ... 50 more options ...                                       │  |
|  │  };                                                                   │  |
|  │                                                                       │  |
|  │  正确做法：                                                           │  |
|  │  只暴露真正需要用户修改的配置                                         │  |
|  │  其他用代码中的 #define 常量                                          │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ANTI-PATTERN 4: FRAMEWORK FOR FRAMEWORK'S SAKE (为架构而架构)             |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  症状：                                                               │  |
|  │  • 引入的框架比解决的问题还复杂                                       │  |
|  │  • 团队花更多时间理解框架而不是业务                                   │  |
|  │  • 简单功能需要大量样板代码                                           │  |
|  │                                                                       │  |
|  │  正确做法：                                                           │  |
|  │  架构应该让简单的事情保持简单                                         │  |
|  │  复杂的事情变得可能                                                   │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 错过最佳架构设计窗口的信号

```
MISSED ARCHITECTURE WINDOW SIGNALS (错过架构窗口的信号)
+===========================================================================+
|                                                                            |
|  SIGNAL 1: MERGE CONFLICTS (合并冲突)                                      |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  早期信号：                                                           │  |
|  │  • 同一个文件频繁出现合并冲突                                         │  |
|  │  • 开发者开始"等别人先 merge"                                        │  |
|  │                                                                       │  |
|  │  含义：                                                               │  |
|  │  模块边界不清晰，多人修改同一代码                                     │  |
|  │                                                                       │  |
|  │  已经晚了的信号：                                                     │  |
|  │  • 合并冲突需要整个团队开会解决                                       │  |
|  │  • 有人专门负责"集成"                                                │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  SIGNAL 2: BUG PROPAGATION (Bug 传播)                                      |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  早期信号：                                                           │  |
|  │  • 修一个 bug 经常引入另一个 bug                                      │  |
|  │  • 改动影响范围难以预测                                               │  |
|  │                                                                       │  |
|  │  含义：                                                               │  |
|  │  模块耦合太紧，没有隔离                                               │  |
|  │                                                                       │  |
|  │  已经晚了的信号：                                                     │  |
|  │  • 有些代码"不敢改"                                                  │  |
|  │  • Bug 反复出现（修了又来）                                           │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  SIGNAL 3: ONBOARDING TIME (新人上手时间)                                  |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  早期信号：                                                           │  |
|  │  • 新人需要问很多"这个为什么这样写"                                  │  |
|  │  • 代码风格不一致                                                     │  |
|  │                                                                       │  |
|  │  含义：                                                               │  |
|  │  没有明确的架构约定                                                   │  |
|  │                                                                       │  |
|  │  已经晚了的信号：                                                     │  |
|  │  • 新人 3 个月还不能独立开发                                          │  |
|  │  • 只有"老人"敢改核心代码                                            │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  SIGNAL 4: BUILD/COMPILE TIME (构建时间)                                   |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  早期信号：                                                           │  |
|  │  • 改一行代码需要重新编译很多文件                                     │  |
|  │  • 头文件依赖混乱                                                     │  |
|  │                                                                       │  |
|  │  含义：                                                               │  |
|  │  模块接口不清晰，依赖关系混乱                                         │  |
|  │                                                                       │  |
|  │  已经晚了的信号：                                                     │  |
|  │  • 增量编译和全量编译时间差不多                                       │  |
|  │  • 开始讨论分布式编译                                                 │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  SIGNAL 5: TESTING DIFFICULTY (测试困难)                                   |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  早期信号：                                                           │  |
|  │  • 单元测试需要大量 mock                                              │  |
|  │  • 测试一个函数需要初始化半个系统                                     │  |
|  │                                                                       │  |
|  │  含义：                                                               │  |
|  │  模块依赖了不该依赖的东西                                             │  |
|  │                                                                       │  |
|  │  已经晚了的信号：                                                     │  |
|  │  • 放弃单元测试，只做集成测试                                         │  |
|  │  • "这个没法测试"                                                    │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 最佳架构设计时机

```
OPTIMAL ARCHITECTURE TIMING (最佳架构设计时机)
+===========================================================================+
|                                                                            |
|  Timeline:                                                                 |
|                                                                            |
|  Project Start                                                             |
|      │                                                                     |
|      ├── [BEST] 项目开始前：定义核心模块和接口                             |
|      │   • 决定主要组件                                                    |
|      │   • 定义数据流向                                                    |
|      │   • 确定错误处理策略                                                |
|      │                                                                     |
|      ├── [GOOD] 第一个功能完成后：回顾和固化                               |
|      │   • 提取通用模式                                                    |
|      │   • 定义命名规范                                                    |
|      │   • 文档化隐式约定                                                  |
|      │                                                                     |
|      ├── [ACCEPTABLE] 代码达到 5K 行：强制重构                             |
|      │   • 拆分大文件                                                      |
|      │   • 清理循环依赖                                                    |
|      │   • 建立模块边界                                                    |
|      │                                                                     |
|      ├── [DIFFICULT] 代码达到 20K 行：局部重构                             |
|      │   • 只能重构部分模块                                                |
|      │   • 需要保持向后兼容                                                |
|      │   • 成本高                                                          |
|      │                                                                     |
|      └── [TOO LATE] 代码达到 100K 行：几乎无法重构                         |
|          • 只能"冻结"并在外面加包装                                       |
|          • 或者重写                                                        |
|                                                                            |
+============================================================================+
```

---

## 实用决策框架

```
ARCHITECTURE DECISION FRAMEWORK (架构决策框架)
+===========================================================================+
|                                                                            |
|  问题：现在需要做架构设计吗？                                              |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Step 1: 评估项目特征                                                 │  |
|  │  ─────────────────────                                                │  |
|  │  □ 预计代码量 > 5K 行？                                               │  |
|  │  □ 团队 > 1 人？                                                      │  |
|  │  □ 生命周期 > 6 个月？                                                │  |
|  │  □ 有多种输入/配置/平台？                                             │  |
|  │                                                                       │  |
|  │  如果 ≥ 2 个 YES → 需要架构设计                                       │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Step 2: 确定架构深度                                                 │  |
|  │  ────────────────────                                                 │  |
|  │  Level 1 (轻量): 只定义文件组织和命名规范                             │  |
|  │  Level 2 (标准): + 模块接口和依赖规则                                 │  |
|  │  Level 3 (完整): + 错误处理、资源管理、并发模型                       │  |
|  │                                                                       │  |
|  │  代码 < 10K → Level 1                                                 │  |
|  │  代码 10K-50K → Level 2                                               │  |
|  │  代码 > 50K → Level 3                                                 │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │                                                                       │  |
|  │  Step 3: 定义最小必要架构                                             │  |
|  │  ─────────────────────                                                │  |
|  │  必须回答的问题：                                                     │  |
|  │  1. 主要模块是什么？                                                  │  |
|  │  2. 模块之间如何通信？                                                │  |
|  │  3. 错误如何处理和传播？                                              │  |
|  │  4. 资源谁负责分配和释放？                                            │  |
|  │                                                                       │  |
|  │  可以推迟的决策：                                                     │  |
|  │  1. 具体算法选择                                                      │  |
|  │  2. 缓存策略                                                          │  |
|  │  3. 日志格式                                                          │  |
|  │  4. 配置文件格式                                                      │  |
|  │                                                                       │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

---

## 核心总结

```
+===========================================================================+
|                ARCHITECTURE NECESSITY SUMMARY                              |
|                架构必要性总结                                              |
+===========================================================================+
|                                                                            |
|  需要架构的场景：                                                          |
|  • 团队 > 1 人                                                             |
|  • 代码 > 5K 行                                                            |
|  • 生命周期 > 6 个月                                                       |
|  • 多种配置/平台                                                           |
|                                                                            |
|  过度架构的信号：                                                          |
|  • 只有一个实现的接口                                                      |
|  • 调用栈过深                                                              |
|  • 简单功能需要大量代码                                                    |
|  • 团队花更多时间理解框架而非业务                                          |
|                                                                            |
|  错过架构窗口的信号：                                                      |
|  • 频繁的合并冲突                                                          |
|  • 修 bug 引入新 bug                                                       |
|  • 新人上手时间过长                                                        |
|  • 编译时间过长                                                            |
|  • 测试困难                                                                |
|                                                                            |
|  黄金法则：                                                                |
|  • 刚好够用的架构 > 完美但推迟的架构                                       |
|  • 简单的约定 > 复杂的框架                                                 |
|  • 早期的小重构 > 后期的大重写                                             |
|                                                                            |
+============================================================================+
```
