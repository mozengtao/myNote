# 一、什么是软件架构（Architecture 的真实含义）

## 1. 架构在工程中到底"管什么、不管什么"？

### 架构层 vs 实现层的职责边界

```
+===========================================================================+
|                        SOFTWARE SYSTEM                                     |
+===========================================================================+
|                                                                            |
|  ARCHITECTURE LAYER (架构层)                                               |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │  • Module boundaries (模块边界)                                      │  |
|  │  • Interface contracts (接口契约)                                    │  |
|  │  • Data flow directions (数据流向)                                   │  |
|  │  • Dependency rules (依赖规则)                                       │  |
|  │  • Error propagation strategy (错误传播策略)                         │  |
|  │  • Resource ownership model (资源所有权模型)                         │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                              ▼                                             |
|                    DOES NOT MANAGE (不管)                                  |
|                              ▼                                             |
|  IMPLEMENTATION LAYER (实现层)                                             |
|  ┌─────────────────────────────────────────────────────────────────────┐  |
|  │  • Algorithm choice (算法选择)                                       │  |
|  │  • Local variable names (局部变量命名)                               │  |
|  │  • Loop optimization (循环优化)                                      │  |
|  │  • Cache strategy details (缓存策略细节)                             │  |
|  │  • Platform-specific tricks (平台特定技巧)                           │  |
|  └─────────────────────────────────────────────────────────────────────┘  |
|                                                                            |
+============================================================================+
```

**中文说明：**

架构管理的是「系统级决策」—— 那些一旦改变，会导致多个模块需要同时修改的决策。
架构不管「局部决策」—— 那些改变只影响一个函数或一个文件内部的决策。

### 以 NFSD VFS 为例（fs/nfsd/vfs.c）

**架构决策的例子：**

```c
// 架构决策：所有 NFS 操作必须通过 svc_fh（file handle）访问文件
// 这是接口契约，改变它会影响整个 NFSD 子系统
__be32 nfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, ...)

// 架构决策：错误必须从 host_err (内核错误) 转换为 NFS 协议错误
err = nfserrno(host_err);
```

**实现决策的例子：**

```c
// 实现决策：readahead 缓存用 jhash 做哈希
hash = jhash_2words(dev, ino, 0xfeedbeef) & RAPARM_HASH_MASK;

// 实现决策：写操作延迟 10ms 以便聚合
msleep(10);
```

### 架构 ≠ 目录结构

```
WRONG THINKING (错误理解):
  "架构设计 = 先画好 src/lib/include 目录"
  
RIGHT THINKING (正确理解):
  架构设计 = 定义「谁可以依赖谁」「谁拥有什么资源」「错误如何传播」
  目录结构只是架构的一个物理映射，不是架构本身
```

**Linux 内核例子：**

```
fs/nfsd/
├── vfs.c          ← VFS 操作封装层
├── nfsfh.c        ← File Handle 管理
├── nfs4proc.c     ← NFSv4 协议处理
├── nfs3proc.c     ← NFSv3 协议处理
└── export.c       ← 导出管理

架构决策不是「有这些文件」，而是：
- vfs.c 只能调用 VFS 接口，不能直接操作 inode 内部
- nfs*proc.c 必须通过 svc_fh 访问文件，不能绕过 vfs.c
- 所有导出检查必须通过 export.c，其他模块不能直接访问导出表
```

---

## 2. 在 C/C++ 项目中的架构意识

### 什么情况下「你其实已经在做架构设计了」？

```
+-----------------------------------------------------------------------+
|  SIGNS YOU ARE DOING ARCHITECTURE (你正在做架构设计的信号)            |
+-----------------------------------------------------------------------+
|                                                                        |
|  1. 定义头文件接口时                                                   |
|     ┌──────────────────────────────────────────────────────────────┐  |
|     │  // 你在决定：谁可以看到什么                                  │  |
|     │  // include/nfsd/vfs.h                                        │  |
|     │  __be32 nfsd_open(...);      // 公开                          │  |
|     │  // nfsd_vfs_read() 不在头文件中 → 私有                       │  |
|     └──────────────────────────────────────────────────────────────┘  |
|                                                                        |
|  2. 决定参数传递方式时                                                 |
|     ┌──────────────────────────────────────────────────────────────┐  |
|     │  // 传 struct svc_fh* 而不是 struct dentry*                   │  |
|     │  // → 你在定义抽象边界                                        │  |
|     │  __be32 nfsd_read(struct svc_rqst *rqstp,                     │  |
|     │                   struct svc_fh *fhp, ...)                    │  |
|     └──────────────────────────────────────────────────────────────┘  |
|                                                                        |
|  3. 设计错误处理策略时                                                 |
|     ┌──────────────────────────────────────────────────────────────┐  |
|     │  // host_err → nfserrno() → __be32                            │  |
|     │  // 你在定义错误如何跨层传播                                  │  |
|     └──────────────────────────────────────────────────────────────┘  |
|                                                                        |
|  4. 决定资源生命周期时                                                 |
|     ┌──────────────────────────────────────────────────────────────┐  |
|     │  // "After this call fhp needs an fh_put"                     │  |
|     │  // 你在定义资源所有权规则                                    │  |
|     └──────────────────────────────────────────────────────────────┘  |
|                                                                        |
+------------------------------------------------------------------------+
```

### 什么情况下「你以为在写代码，实际上在破坏架构」？

```c
// 破坏架构的例子 1: 绕过抽象层
// WRONG: 直接访问 dentry 内部字段
if (dentry->d_inode->i_mode & S_IFDIR) { ... }  // 绕过 VFS 接口

// RIGHT: 使用提供的宏/函数
if (S_ISDIR(inode->i_mode)) { ... }

// 破坏架构的例子 2: 违反依赖方向
// WRONG: nfsd/vfs.c 里 #include 了某个客户端模块的头文件
#include "nfs_client_internal.h"  // 底层依赖上层！

// 破坏架构的例子 3: 泄露实现细节
// WRONG: 在头文件暴露内部结构
// include/nfsd/vfs.h
struct raparms {  // 这是 readahead 缓存的内部实现！
    struct raparms *p_next;
    ...
};

// RIGHT: 只暴露操作接口，隐藏实现
// vfs.c 内部
static struct raparms { ... };  // static = 文件私有
```

**中文说明：**

破坏架构最常见的方式是「走捷径」—— 为了快速实现功能，绕过已定义的接口直接访问内部数据。
这在当时看起来没问题（代码能跑），但会导致：
1. 接口承诺无法兑现（别人改了内部实现，你的代码就崩溃）
2. 测试变得困难（依赖了不该依赖的东西）
3. 并行开发冲突增加（多人改同一份代码）

---

## 3. 架构存在前 vs 架构存在后

### 以 Linux VFS 为例

```
BEFORE VFS ARCHITECTURE (VFS 架构存在之前):
+------------------------------------------------------------------+
|                                                                   |
|   ext2_read()     minix_read()     nfs_read()     fat_read()     |
|       │               │                │              │          |
|       ▼               ▼                ▼              ▼          |
|   ┌───────────────────────────────────────────────────────────┐  |
|   │              每个应用都要知道每种文件系统                   │  |
|   │              N 个应用 × M 个文件系统 = N×M 种组合           │  |
|   └───────────────────────────────────────────────────────────┘  |
|                                                                   |
+------------------------------------------------------------------+

AFTER VFS ARCHITECTURE (VFS 架构存在之后):
+------------------------------------------------------------------+
|                                                                   |
|   Application Layer:  cat, cp, nfsd, samba, ...                  |
|                              │                                    |
|                              ▼                                    |
|   ┌───────────────────────────────────────────────────────────┐  |
|   │                    VFS Interface                           │  |
|   │    vfs_read()  vfs_write()  vfs_open()  vfs_stat()        │  |
|   └───────────────────────────────────────────────────────────┘  |
|                              │                                    |
|            ┌────────┬────────┼────────┬────────┐                 |
|            ▼        ▼        ▼        ▼        ▼                 |
|         ext4     btrfs     nfs      xfs      tmpfs              |
|                                                                   |
|   N 个应用 + M 个文件系统 = N + M 种实现                         |
|                                                                   |
+------------------------------------------------------------------+
```

**中文说明：**

VFS 架构的存在带来了根本性变化：

| 变化维度 | 架构前 | 架构后 |
|---------|-------|-------|
| 代码复用 | 每个应用重复实现文件操作 | 统一接口，一次实现 |
| 添加新文件系统 | 修改所有应用 | 只实现 VFS 接口 |
| 添加新应用 | 为每个文件系统写适配代码 | 只用 VFS 接口 |
| Bug 影响范围 | ext2 bug 只影响 ext2 用户 | 仍然隔离 |
| 测试复杂度 | O(N×M) | O(N+M) |

### NFSD 中的具体体现

```c
// nfsd/vfs.c 使用 VFS 接口，不关心具体文件系统
static __be32
nfsd_vfs_read(struct svc_rqst *rqstp, struct svc_fh *fhp, 
              struct file *file, ...)
{
    // 使用 VFS 接口，不管底层是 ext4 还是 xfs
    if (file->f_op->splice_read && rqstp->rq_splice_ok) {
        host_err = splice_direct_to_actor(file, &sd, ...);
    } else {
        host_err = vfs_readv(file, ...);  // VFS 接口！
    }
}
```

**这就是架构的价值：**
1. NFSD 不需要为每种文件系统写读取代码
2. 新文件系统（如 bcachefs）自动被 NFSD 支持
3. 文件系统内部优化不影响 NFSD 代码

---

## 关键理解

```
+====================================================================+
|                     ARCHITECTURE ESSENCE                            |
+====================================================================+
|                                                                     |
|  架构 = 「边界」 + 「契约」 + 「约束」                              |
|                                                                     |
|  边界: 哪些代码属于哪个模块                                         |
|  契约: 模块之间如何交互（接口、协议、数据格式）                     |
|  约束: 什么是禁止的（依赖方向、资源访问规则）                       |
|                                                                     |
|  架构设计的核心问题：                                               |
|  「如果这个决策错了，需要改多少代码？」                             |
|                                                                     |
|  如果答案是「几乎所有代码」→ 这是架构决策                          |
|  如果答案是「一个函数内部」→ 这是实现决策                          |
|                                                                     |
+=====================================================================+
```

**中文总结：**

1. 架构不是画图，是做「高代价决策」
2. C/C++ 项目中，头文件设计、指针传递策略、错误处理方式都是架构决策
3. 好的架构让「添加新功能」的成本是线性的，而不是指数级的
4. 判断架构质量的最简单方法：「改一个需求，需要改几个文件？」
