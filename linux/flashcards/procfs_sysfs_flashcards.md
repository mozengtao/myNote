# Linux Kernel v3.2 ProcFS and SysFS Flashcards

> Comprehensive Anki-style flashcards covering virtual filesystems, procfs internals, sysfs/kobject model, kernel APIs, and driver integration patterns.

---

## Section 1: ProcFS Fundamentals

---

Q: What is procfs in the Linux kernel?
A: Procfs (Process File System) is a pseudo-filesystem mounted at `/proc` that provides an interface to kernel data structures. It presents kernel and process information as a hierarchy of virtual files that are generated on-the-fly when read.
[Basic]

---

Q: Why is procfs called a "pseudo-filesystem" or "virtual filesystem"?
A: Because its files don't exist on any physical storage device. The content is dynamically generated by the kernel when a file is read and exists only in memory. There's no actual disk I/O involved.
[Basic]

---

Q: What is the standard mount point for procfs?
A: `/proc` - This is where the procfs filesystem is traditionally mounted. The mount is typically done at boot time by init scripts or systemd.
[Basic]

---

Q: (Cloze) Procfs was originally introduced to provide information about _____, but later expanded to expose general _____ information.
A: processes, kernel. Originally, procfs only contained per-process directories (/proc/PID), but it grew to include system-wide kernel parameters, hardware info, and tunables.
[Basic]

---

Q: What is the filesystem type name used when mounting procfs?
A: `proc` - The mount command is: `mount -t proc proc /proc` or equivalently `mount -t proc none /proc`
[Basic]

---

Q: How do you verify that procfs is mounted on a system?
A: Use `mount | grep proc` or check `/proc/mounts` for an entry with type "proc". Also `cat /proc/filesystems` shows if proc is a registered filesystem type.
[Basic]

---

Q: (Reverse) This directory contains numbered subdirectories, where each number corresponds to a running process's PID.
A: Q: What is the /proc directory's characteristic for process information?
[Basic]

---

Q: What happens when you `cat /proc/meminfo`?
A: The kernel's procfs handler for meminfo is invoked, which reads current memory statistics from kernel data structures (zone information, page counters, etc.) and formats them as text output. No file is actually stored anywhere.
[Basic]

---

Q: Why doesn't `ls -l /proc/meminfo` show the file's actual content size?
A: Because the file content doesn't exist until you read it. The size shown (often 0) is a placeholder. The actual content is generated dynamically by the kernel's read handler when the file is opened and read.
[Basic]

---

Q: What is the relationship between procfs and the VFS (Virtual File System) layer?
A: Procfs implements the standard VFS interface (file_operations, inode_operations, etc.). When user-space accesses /proc files, VFS routes the calls to procfs handlers, which generate content from kernel data structures.
[Intermediate]

---

Q: (ASCII Diagram) How does a read from /proc/meminfo flow through the kernel?
A:
```
User Space                    Kernel Space
+-----------+                +------------------+
| cat cmd   |                |      VFS         |
|  read()   | --syscall-->   | lookup/open/read |
+-----------+                +--------+---------+
                                      |
                                      v
                             +------------------+
                             | procfs handlers  |
                             | meminfo_proc_show|
                             +--------+---------+
                                      |
                                      v
                             +------------------+
                             | Kernel Data      |
                             | (zone stats,     |
                             |  page counters)  |
                             +------------------+
```
[Intermediate]

---

Q: What does it mean that procfs files are "generated on-the-fly"?
A: The file content is computed at the moment of reading. Each time you read /proc/uptime, the kernel calculates the current uptime from jiffies. The value is never stored - it's computed fresh on every read.
[Basic]

---

Q: Can you write to procfs files?
A: Some procfs files support writing (e.g., `/proc/sys/*` tunables), but many are read-only. Write support depends on whether the specific file has a write handler registered. Read-only files will return -EACCES or -EPERM on write attempts.
[Basic]

---

Q: What is the primary use of /proc/sys directory?
A: `/proc/sys` exposes kernel tunables (sysctl parameters) as files. Writing to these files changes kernel behavior at runtime without recompilation. Examples: `/proc/sys/net/ipv4/ip_forward`, `/proc/sys/vm/swappiness`.
[Basic]

---

Q: How is /proc/sys different from other /proc entries?
A: `/proc/sys` is specifically for kernel parameters (sysctls) that can be both read and modified. It's backed by the sysctl subsystem. Other /proc entries mostly provide read-only information about system state.
[Intermediate]

---

Q: (Cloze) The content of procfs files exists only in _____, not on _____.
A: memory (RAM), disk. Procfs is entirely memory-resident. When the system reboots, all /proc content is regenerated from kernel state - nothing persists.
[Basic]

---

Q: What happens if you try to create a regular file in /proc using `touch`?
A: It will fail with "Permission denied" or "Read-only file system". Procfs doesn't support creating arbitrary files from user-space - its structure is defined by the kernel code.
[Basic]

---

Q: Why was procfs originally created? (Historical context)
A: Procfs originated in UNIX System V and was adopted by Linux to provide process information without requiring special system calls. Instead of complex APIs, process info (memory maps, open files, etc.) could be read as simple text files.
[Basic]

---

Q: What is the key advantage of exposing kernel data through procfs instead of system calls?
A: Simplicity and scriptability. Shell scripts can use standard tools (cat, grep, awk) to access kernel data. No need for specialized programs or understanding binary formats. Easy debugging and monitoring.
[Basic]

---

Q: (Understanding) Why might reading from the same /proc file twice give different results?
A: Because procfs content reflects current kernel state. Between two reads, processes may have started/stopped, memory usage changed, network counters incremented, etc. Each read shows a snapshot of that moment.
[Basic]

---

Q: What permission model does procfs use?
A: Procfs uses standard UNIX permissions (owner, group, mode). Files like `/proc/PID/mem` are restricted to the process owner. Root can access most entries. Some files (like `/proc/kallsyms`) may be restricted by kernel config.
[Intermediate]

---

Q: What does the /proc/self symlink point to?
A: `/proc/self` is a magic symlink that always points to the /proc/PID directory of the process accessing it. If PID 1234 reads `/proc/self/status`, it actually reads `/proc/1234/status`.
[Basic]

---

Q: (Reverse) This special symlink in /proc allows a process to access its own proc directory without knowing its PID.
A: Q: What is /proc/self?
[Basic]

---

Q: How does the kernel determine which process's data to show when /proc/self is accessed?
A: The kernel uses `current->pid` (or `current->tgid` for thread group leader) at the time of access. The VFS layer resolves the symlink target dynamically based on the calling process.
[Intermediate]

---

Q: What is the difference between /proc/PID and /proc/PID/task/TID?
A: `/proc/PID` shows information for the thread group leader (main thread). `/proc/PID/task/TID` contains directories for each individual thread, showing per-thread info like stack, status, etc.
[Intermediate]

---

Q: Can procfs show information about kernel threads?
A: Yes. Kernel threads appear in /proc with their own PID directories. You can identify them because their `/proc/PID/exe` symlink will be empty (or point to nothing) since they have no user-space executable.
[Intermediate]

---

Q: (Code Interpretation) What does this shell one-liner do?
```bash
cat /proc/$$/status | grep VmRSS
```
A: It reads the memory status of the current shell process ($$) and extracts the Resident Set Size (VmRSS) - the amount of physical memory currently used by the shell. `/proc/$$/status` contains detailed process information.
[Basic]

---

Q: What is the role of the `struct proc_dir_entry` in procfs?
A: `struct proc_dir_entry` represents each file or directory in /proc. It contains the file name, permissions, pointers to read/write handlers, parent directory link, and associated data pointer for the handler to use.
[Intermediate]

---

Q: Why doesn't `du /proc` show meaningful disk usage?
A: Because procfs files have no disk allocation - they're generated on demand from kernel memory. The reported sizes are often 0 or nominal values. `du` measures disk blocks, but procfs uses no disk blocks.
[Basic]

---

Q: (Understanding) What could happen if you're reading a /proc file while the corresponding process exits?
A: The read might fail partway through, return partial data, or the file might disappear (ENOENT). The kernel tries to handle this gracefully, but there's inherent race conditions with dynamic /proc/PID entries.
[Intermediate]

---

Q: What is the kernel configuration option to enable procfs?
A: `CONFIG_PROC_FS` - This must be enabled in the kernel config. Most distributions enable it by default because many userspace tools depend on /proc.
[Basic]

---

Q: Name three essential userspace tools that depend on procfs.
A: 
- `ps` - reads /proc/PID/* for process information
- `top` - reads /proc/stat, /proc/PID/stat for CPU/memory stats
- `free` - reads /proc/meminfo for memory statistics
Many others: netstat, lsof, vmstat, etc.
[Basic]

---

Q: (Cloze) The /proc filesystem is registered with the kernel using the _____ macro/function during kernel initialization.
A: `register_filesystem()` with `&proc_fs_type`. The procfs code calls this during boot to register "proc" as a filesystem type that can be mounted.
[Intermediate]

---

Q: What is the superblock in the context of procfs?
A: The procfs superblock (`struct super_block`) is a minimal structure that satisfies VFS requirements. It contains metadata about the mounted procfs instance but doesn't store actual data since procfs is memory-backed.
[Intermediate]

---

Q: How does procfs handle concurrent reads from multiple processes?
A: Each open file has its own file position and buffer. The procfs handlers typically generate a snapshot of data for each read operation. Locking depends on the specific handler - some use RCU, spinlocks, or accept small races.
[Intermediate]

---

Q: (ASCII Diagram) Show the basic structure of /proc directory.
A:
```
/proc/
├── 1/              # PID 1 (init)
├── 2/              # PID 2 (kthreadd)
├── .../            # Other process PIDs
├── self -> PID     # Symlink to current process
├── cpuinfo         # CPU information
├── meminfo         # Memory statistics
├── interrupts      # IRQ statistics
├── sys/            # Kernel tunables (sysctl)
│   ├── kernel/
│   ├── vm/
│   └── net/
├── net/            # Network statistics
├── fs/             # Filesystem info
└── bus/            # Bus information
```
[Basic]

---

Q: What does /proc/filesystems show?
A: A list of filesystem types currently registered with the kernel. Entries marked "nodev" are pseudo-filesystems (like proc, sysfs) that don't require a block device. This is used by mount when auto-detecting filesystem types.
[Basic]

---

Q: (Reverse) This file in /proc shows all registered filesystem types and whether they require a block device.
A: Q: What is /proc/filesystems?
[Basic]

---

Q: Why might some /proc files be larger when read than their reported size?
A: The reported size (from stat()) is often 0 or an estimate. The actual content is generated on read and may be larger. The kernel doesn't always pre-calculate exact sizes for dynamic content.
[Intermediate]

---

Q: What is the difference between procfs "synthetic" files and regular files?
A: Synthetic files have no backing storage - content is computed on read from kernel state. Regular files store content persistently. All procfs files are synthetic. This is why they're also called "virtual" files.
[Basic]

---

Q: (Understanding) Why is procfs particularly useful for debugging kernel issues?
A: It exposes internal kernel state without requiring special debug builds or tools. Administrators can check memory pressure (/proc/meminfo), interrupt counts (/proc/interrupts), scheduler stats, lock contention, etc. - all with simple file reads.
[Basic]

---

## Section 1: COMPLETE ✓

---

## Section 2: ProcFS Directory Structure

---

Q: What information is contained in /proc/PID/status?
A: Human-readable process status including: Name, State (running/sleeping), Tgid, Pid, PPid, Uid/Gid, VmPeak, VmSize, VmRSS, VmData, VmStk, VmExe, Threads count, signal masks, and capability sets.
[Basic]

---

Q: What is the difference between /proc/PID/stat and /proc/PID/status?
A: `/proc/PID/stat` is a single line of space-separated values optimized for parsing by programs (ps, top). `/proc/PID/status` is multi-line key-value format designed for human readability. Both contain similar information.
[Basic]

---

Q: What does /proc/PID/cmdline contain?
A: The complete command line used to start the process, with arguments separated by null bytes (\0). If the process modified its argv[], the modified version is shown. Kernel threads have empty cmdline.
[Basic]

---

Q: (Code Interpretation) Why does this command work to show process arguments?
```bash
cat /proc/1234/cmdline | tr '\0' ' '
```
A: `/proc/PID/cmdline` uses null bytes as argument separators (matching how argv[] is stored in memory). The `tr` command replaces nulls with spaces for readable output.
[Basic]

---

Q: What does /proc/PID/exe point to?
A: A symbolic link to the executable file that was used to start the process. Even if the original file is deleted, this symlink allows access to the running binary. Returns "(deleted)" suffix if file was removed.
[Basic]

---

Q: What is /proc/PID/cwd?
A: A symbolic link to the current working directory of the process. Follows directory changes made by chdir(). Useful for understanding where relative file paths in the process resolve to.
[Basic]

---

Q: What does /proc/PID/root point to?
A: A symbolic link to the root directory as seen by the process. Usually "/" but different if the process used chroot(). Important for understanding containerized or chrooted processes.
[Basic]

---

Q: (Reverse) This symlink in /proc/PID allows you to see what directory a process considers as its filesystem root.
A: Q: What is /proc/PID/root?
[Basic]

---

Q: What information does /proc/PID/fd/ directory contain?
A: Symbolic links to all open file descriptors of the process. Each link is named by fd number (0, 1, 2, ...) and points to the actual file, socket, pipe, or device. `/proc/PID/fd/0` is usually stdin.
[Basic]

---

Q: What does a /proc/PID/fd/N symlink look like for different file types?
A: 
- Regular file: `/path/to/file`
- Socket: `socket:[inode]`
- Pipe: `pipe:[inode]`
- Anonymous inode: `anon_inode:[type]`
- Device: `/dev/tty`, `/dev/null`, etc.
[Intermediate]

---

Q: What is /proc/PID/maps and what does it show?
A: Memory mappings of the process: start-end addresses, permissions (rwxp/s), offset, device, inode, and pathname. Shows code segments, libraries, heap, stack, vDSO, and anonymous mappings.
[Intermediate]

---

Q: (ASCII Diagram) What does a typical /proc/PID/maps entry look like?
A:
```
address           perms offset   dev   inode   pathname
08048000-08049000 r-xp  00000000 08:01 123456  /bin/cat
│        │        │     │        │     │       └── mapped file
│        │        │     │        │     └── inode number
│        │        │     │        └── device (major:minor)
│        │        │     └── offset in file
│        │        └── r=read,w=write,x=exec,p=private,s=shared
│        └── end address
└── start address
```
[Intermediate]

---

Q: What is the difference between /proc/PID/maps and /proc/PID/smaps?
A: `/proc/PID/maps` shows basic mapping information. `/proc/PID/smaps` provides detailed memory statistics for each mapping: Rss, Pss, Shared/Private_Clean/Dirty, Referenced, Swap, etc.
[Intermediate]

---

Q: What does /proc/PID/mem allow?
A: Direct read/write access to the process's virtual memory space. Requires same-user or CAP_SYS_PTRACE. Used by debuggers (like gdb) to examine/modify process memory at specific virtual addresses.
[Advanced]

---

Q: Why is reading /proc/PID/mem different from reading /proc/PID/maps?
A: `/proc/PID/maps` is a text description of memory regions. `/proc/PID/mem` provides actual raw memory content - you seek to a virtual address and read bytes. Permission checks and address validity are enforced.
[Intermediate]

---

Q: What does /proc/PID/environ contain?
A: The initial environment variables of the process (null-separated KEY=VALUE pairs). Shows the environment at exec() time. Security note: may expose sensitive data like passwords in environment.
[Basic]

---

Q: What is /proc/cpuinfo?
A: Detailed information about each CPU core: vendor, model, MHz, cache size, flags (capabilities), bogomips, etc. Format varies by architecture. Each processor section starts with "processor : N".
[Basic]

---

Q: (Cloze) The CPU capability flags shown in /proc/cpuinfo indicate supported _____ like SSE, AVX, AES-NI.
A: instruction set extensions (or CPU features). These flags tell software what instructions are safe to use. Examples: sse4_2, avx2, aes, vmx.
[Basic]

---

Q: What information does /proc/meminfo provide?
A: System-wide memory statistics: MemTotal, MemFree, MemAvailable, Buffers, Cached, SwapTotal, SwapFree, Active, Inactive, Dirty, Writeback, Mapped, Slab, PageTables, etc.
[Basic]

---

Q: What is the difference between MemFree and MemAvailable in /proc/meminfo?
A: MemFree is truly unused RAM. MemAvailable estimates how much memory is available for starting new applications without swapping - includes reclaimable cache and buffers. MemAvailable is the better metric for "usable" memory.
[Intermediate]

---

Q: What does /proc/interrupts show?
A: Per-CPU interrupt counts for each IRQ number. Columns show counts per CPU, IRQ type (IO-APIC, MSI), and the device(s) using that IRQ. Useful for diagnosing interrupt storms or IRQ balancing issues.
[Basic]

---

Q: (Reverse) This /proc file shows a table of interrupt counts per CPU and which devices are using each IRQ.
A: Q: What is /proc/interrupts?
[Basic]

---

Q: What does /proc/sys/kernel/pid_max contain?
A: The maximum PID value the kernel will assign. When reached, PIDs wrap around to low values. Default is typically 32768 (15 bits) but can be increased up to 4194304 (22 bits) on 64-bit systems.
[Intermediate]

---

Q: How do you change kernel parameters via /proc/sys?
A: Write the new value to the file: `echo 1 > /proc/sys/net/ipv4/ip_forward`. Or use the sysctl command: `sysctl -w net.ipv4.ip_forward=1`. Changes take effect immediately but don't persist across reboots.
[Basic]

---

Q: What is /proc/net/dev?
A: Network interface statistics: bytes/packets received/transmitted, errors, drops, fifo overruns, frame errors, collisions, carrier errors per interface. Format is a table with header rows.
[Basic]

---

Q: What does /proc/mounts show?
A: Currently mounted filesystems with mount point, filesystem type, and options. Similar to the output of `mount` command. Actually a symlink to /proc/self/mounts in modern kernels.
[Basic]

---

Q: What is the difference between /etc/mtab and /proc/mounts?
A: `/proc/mounts` shows the kernel's view of mounted filesystems (always accurate). `/etc/mtab` is maintained by mount/umount utilities and can become stale. Modern systems often symlink /etc/mtab to /proc/mounts.
[Intermediate]

---

Q: What does /proc/loadavg contain?
A: Load averages for 1, 5, and 15 minute intervals, plus running/total processes, and last PID created. Example: "0.15 0.10 0.05 2/150 12345". Load average represents runnable + uninterruptible processes.
[Basic]

---

Q: What does /proc/uptime show?
A: Two space-separated numbers: system uptime in seconds (with decimal precision) and total idle time across all CPUs in seconds. Example: "12345.67 98765.43".
[Basic]

---

Q: What is /proc/version?
A: A single line containing: Linux kernel version, compiler info (gcc version), build user, build host, and build date. Example: "Linux version 3.2.0 (gcc version 4.6.3) #1 SMP Tue Jan 1 00:00:00 UTC 2012"
[Basic]

---

## Section 2: COMPLETE ✓

---

## Section 3: ProcFS Implementation Internals

---

Q: What is `struct proc_dir_entry` and what is its purpose?
A: The fundamental data structure representing a file or directory in procfs. Contains: name, mode (permissions), uid/gid, parent pointer, proc_fops (file operations), data pointer for handlers, and child/sibling links for hierarchy.
[Intermediate]

---

Q: (Code Interpretation) What are the key fields in struct proc_dir_entry (v3.2)?
```c
struct proc_dir_entry {
    unsigned int low_ino;
    unsigned short namelen;
    const char *name;
    mode_t mode;
    nlink_t nlink;
    uid_t uid;
    gid_t gid;
    loff_t size;
    const struct inode_operations *proc_iops;
    const struct file_operations *proc_fops;
    struct proc_dir_entry *parent;
    void *data;
    read_proc_t *read_proc;
    write_proc_t *write_proc;
};
```
A: Key fields:
- `name/namelen`: file/dir name
- `mode`: permissions (S_IFREG|0644, etc.)
- `proc_fops`: VFS file operations
- `parent`: parent directory
- `data`: arbitrary data for handlers
- `read_proc/write_proc`: legacy read/write functions
[Intermediate]

---

Q: What is the difference between `create_proc_entry()` and `proc_create()`?
A: `create_proc_entry()` is the older API (deprecated in v3.10+). `proc_create()` is newer, takes file_operations directly, and is safer. In v3.2, both exist but `proc_create()` is preferred for new code.
[Intermediate]

---

Q: (Code Interpretation) What does this code do?
```c
static int my_proc_show(struct seq_file *m, void *v)
{
    seq_printf(m, "Hello from procfs!\n");
    return 0;
}

static int my_proc_open(struct inode *inode, struct file *file)
{
    return single_open(file, my_proc_show, NULL);
}

static const struct file_operations my_fops = {
    .open    = my_proc_open,
    .read    = seq_read,
    .llseek  = seq_lseek,
    .release = single_release,
};
```
A: Creates a simple read-only proc file using seq_file interface:
- `my_proc_show`: generates output using seq_printf
- `single_open`: helper for single-iteration seq_file
- `seq_read/seq_lseek/single_release`: standard seq_file ops
This pattern is the modern way to create simple proc files.
[Intermediate]

---

Q: What is the seq_file interface and why was it created?
A: seq_file is a helper for creating proc files that output sequential data. It handles buffer management, partial reads, and seeking automatically. Created because manually handling read() with offsets and buffer sizes is error-prone.
[Intermediate]

---

Q: What problem does seq_file solve that raw read_proc had?
A: Raw read_proc required manual handling of: file position, partial reads, buffer overflow checks, and continuation across multiple read() calls. seq_file abstracts this - you just output data with seq_printf() and it handles pagination.
[Intermediate]

---

Q: What are the four main operations in `struct seq_operations`?
A:
- `start(seq_file, pos)`: initialize iteration, return first item
- `next(seq_file, v, pos)`: return next item
- `stop(seq_file, v)`: cleanup after iteration
- `show(seq_file, v)`: output current item
These enable iterating over data structures (lists, arrays, etc.).
[Intermediate]

---

Q: (Cloze) The _____ function is used for simple proc files that output all content in one shot, without needing iteration.
A: `single_open()`. It's a seq_file helper for files where start() returns one item and next() returns NULL. Pairs with `single_release()` for cleanup.
[Intermediate]

---

Q: What does `seq_printf()` do?
A: Outputs formatted text to a seq_file buffer (like printf but for seq_file). Handles buffer overflow by returning an error flag that triggers buffer resize and re-iteration. Never write directly to user buffers.
[Intermediate]

---

Q: What other output functions does seq_file provide besides seq_printf?
A:
- `seq_puts(m, str)`: output simple string
- `seq_putc(m, char)`: output single character  
- `seq_write(m, buf, len)`: output raw bytes
- `seq_escape(m, str, esc)`: output with escape sequences
[Intermediate]

---

Q: (Code Interpretation) What is the purpose of the pos parameter in seq_operations?
```c
static void *my_start(struct seq_file *m, loff_t *pos)
{
    return (*pos < nr_items) ? &items[*pos] : NULL;
}
```
A: `pos` is the iteration position/index. It starts at 0 for a new read, but may be non-zero if the user is seeking or continuing a partial read. The start() function must handle any valid position value.
[Intermediate]

---

Q: How does seq_file handle reads larger than its internal buffer?
A: seq_file has an internal buffer (default 4KB). If show() output exceeds it, seq_file doubles the buffer and retries from start(). This automatic resizing ensures complete output without manual buffer management.
[Intermediate]

---

Q: What does `proc_create_data()` do differently from `proc_create()`?
A: `proc_create_data()` accepts an additional void* data parameter that's stored in proc_dir_entry->data. This data pointer is accessible in file operations via `PDE_DATA(inode)` or `PDE(inode)->data`.
[Intermediate]

---

Q: (Code Interpretation) How do you access the data pointer in a proc file handler?
```c
static int my_show(struct seq_file *m, void *v)
{
    struct my_data *data = m->private;
    // or: struct my_data *data = PDE_DATA(file_inode(m->file));
    seq_printf(m, "value: %d\n", data->value);
    return 0;
}
```
A: The data pointer set via proc_create_data() can be accessed:
1. Via `m->private` if passed to single_open()'s third argument
2. Via `PDE_DATA(inode)` macro from the inode
3. Via `PDE(inode)->data` directly
[Intermediate]

---

Q: What is the function signature for proc file read handler (legacy API)?
A: `int (*read_proc)(char *page, char **start, off_t off, int count, int *eof, void *data)`
- `page`: buffer to write output (typically PAGE_SIZE)
- `start`: for complex seeking
- `off`: current position
- `count`: max bytes requested
- `eof`: set to 1 when done
- `data`: private data pointer
[Intermediate]

---

Q: Why is the legacy read_proc/write_proc interface deprecated?
A: It's error-prone: manual buffer management, complex offset handling, easy to create buffer overflows or missing data. seq_file is safer and handles these issues automatically. Legacy interface removed in v3.10.
[Intermediate]

---

Q: How do you remove a proc entry?
A: `remove_proc_entry(name, parent)` where name is the file/dir name and parent is the parent proc_dir_entry (NULL for /proc root). Must remove children before parent. Use `proc_remove()` in newer kernels.
[Intermediate]

---

Q: (Code Interpretation) What's the correct order for cleanup?
```c
static struct proc_dir_entry *proc_dir;
static struct proc_dir_entry *proc_file;

// In exit function:
remove_proc_entry("myfile", proc_dir);  // Remove child first
remove_proc_entry("mydir", NULL);        // Then remove parent
```
A: Children must be removed before their parent directory. Removing a directory with children will cause a kernel warning/oops. This is a common mistake in driver cleanup code.
[Intermediate]

---

Q: What is `proc_mkdir()` used for?
A: Creates a subdirectory under /proc. Returns a proc_dir_entry* that can be passed as parent to proc_create() for creating files within that directory. Example: `proc_mkdir("mydriver", NULL)` creates /proc/mydriver/.
[Intermediate]

---

Q: (Code Interpretation) What does this initialization code do?
```c
static struct proc_dir_entry *proc_dir;

static int __init my_init(void)
{
    proc_dir = proc_mkdir("mydriver", NULL);
    if (!proc_dir)
        return -ENOMEM;
    
    proc_create("status", 0444, proc_dir, &status_fops);
    proc_create("config", 0644, proc_dir, &config_fops);
    return 0;
}
```
A: Creates a proc directory structure:
```
/proc/mydriver/
├── status  (read-only, 0444)
└── config  (read-write, 0644)
```
Each file has its own file_operations for handling reads/writes.
[Intermediate]

---

Q: What does the mode parameter in proc_create() specify?
A: Standard Unix file permissions in octal. Common values:
- `0444`: read-only for all
- `0644`: read for all, write for owner
- `0600`: read/write for owner only
Combined with S_IFREG (regular file) internally.
[Basic]

---

Q: How does procfs convert a file path to the correct proc_dir_entry?
A: The VFS calls procfs's lookup() function, which walks the proc_dir_entry tree matching path components. Each proc_dir_entry has a parent pointer and sibling list, forming a tree structure mirroring /proc hierarchy.
[Advanced]

---

Q: (ASCII Diagram) How is the proc_dir_entry tree organized?
A:
```
proc_root (/)
├── proc_dir_entry: "cpuinfo"
├── proc_dir_entry: "meminfo"
├── proc_dir_entry: "sys" (directory)
│   ├── proc_dir_entry: "kernel"
│   │   └── proc_dir_entry: "pid_max"
│   └── proc_dir_entry: "vm"
│       └── proc_dir_entry: "swappiness"
└── proc_dir_entry: "1" (PID directory)
    ├── proc_dir_entry: "status"
    ├── proc_dir_entry: "cmdline"
    └── proc_dir_entry: "fd" (directory)
```
Each entry has: parent pointer, child list, sibling links.
[Intermediate]

---

Q: What is special about /proc/PID directories? How are they created?
A: They're created dynamically by the kernel when listing /proc (readdir). The proc code iterates over task_struct list to generate entries on-the-fly. No proc_dir_entry exists for most PID directories until accessed.
[Advanced]

---

Q: How does the kernel know which inode operations to use for /proc files?
A: Each proc_dir_entry has a `proc_iops` field pointing to inode_operations. For regular files, this includes lookup, permission checks. For symlinks, it includes readlink, follow_link. Set during proc_create().
[Intermediate]

---

Q: What is `proc_symlink()` used for?
A: Creates a symbolic link in /proc. Used for things like /proc/self, /proc/PID/exe. Example: `proc_symlink("self", NULL, "%d", current->pid)` - though /proc/self is actually handled specially.
[Intermediate]

---

Q: What locking protects proc_dir_entry tree modifications?
A: A global spinlock `proc_subdir_lock` protects insertion/removal of proc entries. This prevents races when multiple modules create/remove proc entries simultaneously. The lock is internal to procfs.
[Advanced]

---

Q: (Understanding) Why might a proc read handler need its own locking?
A: The proc infrastructure only protects the proc_dir_entry tree. The handler's data (e.g., device statistics, network counters) may change during the read. Handlers often use RCU, spinlocks, or accept small races.
[Advanced]

---

Q: What is the difference between /proc/net and /proc/self/net?
A: In modern kernels (including 3.2), /proc/net is a symlink to /proc/self/net. This provides network namespace support - each process sees network info for its namespace. Pre-namespace kernels had /proc/net as a real directory.
[Advanced]

---

Q: How do you create a proc file that supports both reading and writing?
A: Implement both .read (typically seq_read with seq_file) and .write in file_operations. Write handler receives user buffer, parses it, and updates kernel state. Example: /proc/sys/* entries do this.
[Intermediate]

---

Q: (Code Interpretation) What does this write handler do?
```c
static ssize_t my_write(struct file *file, const char __user *buf,
                        size_t count, loff_t *ppos)
{
    char kbuf[32];
    int val;
    
    if (count >= sizeof(kbuf))
        return -EINVAL;
    if (copy_from_user(kbuf, buf, count))
        return -EFAULT;
    kbuf[count] = '\0';
    
    if (kstrtoint(kbuf, 10, &val))
        return -EINVAL;
    
    my_value = val;
    return count;
}
```
A: A typical procfs write handler:
1. Bounds check input size
2. Copy from user space (must use copy_from_user!)
3. Null-terminate the string
4. Parse the value (kstrtoint for integer)
5. Update kernel variable
6. Return bytes written (or error)
[Intermediate]

---

## Section 3: COMPLETE ✓

---

## Section 4: SysFS Fundamentals

---

Q: What is sysfs in the Linux kernel?
A: Sysfs is a pseudo-filesystem mounted at `/sys` that exports the kernel's device model to user space. It provides a structured, hierarchical view of devices, buses, drivers, and kernel objects with a strict one-value-per-file policy.
[Basic]

---

Q: Why was sysfs created when procfs already existed?
A: Procfs became cluttered with non-process data and had no organizational structure. Sysfs was designed specifically for the device model with strict rules: hierarchical organization reflecting object relationships, one value per file, and clear separation of concerns.
[Basic]

---

Q: What is the standard mount point for sysfs?
A: `/sys` - This is where sysfs is mounted at boot. The mount command is: `mount -t sysfs sysfs /sys`
[Basic]

---

Q: What is the fundamental design principle of sysfs file content?
A: "One value per file" - Each sysfs file should contain a single ASCII value (integer, string, etc.). No complex multi-field formats. This makes parsing trivial and files self-documenting.
[Basic]

---

Q: (Cloze) The sysfs design philosophy is "one _____ per _____" to ensure simple, predictable file contents.
A: value, file. Unlike procfs which often has complex multi-line formats, sysfs files typically contain a single value followed by a newline. This simplifies both kernel handlers and user-space parsing.
[Basic]

---

Q: What is a kobject?
A: A kobject (kernel object) is the fundamental building block of sysfs and the Linux device model. It provides: reference counting, hierarchical organization (parent/child), sysfs representation, and hotplug event notification.
[Basic]

---

Q: (Reverse) This kernel data structure is the fundamental building block that represents objects in sysfs and provides reference counting.
A: Q: What is a kobject?
[Basic]

---

Q: What header file contains the kobject definition?
A: `<linux/kobject.h>` - Contains struct kobject, kset, kobj_type, and related APIs. Most subsystems include this indirectly through device.h.
[Basic]

---

Q: What are the key fields in struct kobject?
A: Key fields:
- `name`: object name (becomes sysfs directory name)
- `entry`: list linkage for kset membership
- `parent`: parent kobject (hierarchy)
- `kset`: containing kset
- `ktype`: operations and attributes
- `sd`: sysfs_dirent pointer
- `kref`: reference count
[Intermediate]

---

Q: (Code Interpretation) What does this struct kobject look like?
```c
struct kobject {
    const char        *name;
    struct list_head   entry;
    struct kobject    *parent;
    struct kset       *kset;
    struct kobj_type  *ktype;
    struct sysfs_dirent *sd;
    struct kref        kref;
    unsigned int state_initialized:1;
    unsigned int state_in_sysfs:1;
    unsigned int state_add_uevent_sent:1;
    unsigned int state_remove_uevent_sent:1;
    unsigned int uevent_suppress:1;
};
```
A: The kobject structure:
- `name`: visible in /sys
- `parent`: creates hierarchy
- `kset`: group membership
- `ktype`: operations (release, show, store)
- `kref`: reference counting
- State bits: track initialization/sysfs/uevent status
[Intermediate]

---

Q: What is the relationship between kobject and sysfs directories?
A: Each kobject registered with sysfs becomes a directory in /sys. The kobject's name becomes the directory name. Parent kobject determines directory location. Kobject hierarchy directly maps to sysfs hierarchy.
[Basic]

---

Q: What is a kset?
A: A kset is a collection of kobjects of similar type. It's itself a kobject (so it has a sysfs directory) plus a linked list of member kobjects. Ksets provide grouping and common uevent handling.
[Intermediate]

---

Q: (ASCII Diagram) How do kobjects, ksets, and directories relate?
A:
```
Kernel Space                     /sys
+------------------+            
|     kset         |             
| (container, also |             /sys/bus/
|  a kobject)      |                │
|    │             |                │
|    ├── kobject ──────────────── pci/
|    │     │       |                │
|    │     └── kobject ───────────  0000:00:00.0/
|    │             |                
|    └── kobject ──────────────── usb/
|          │       |                │
|          └── kobject ─────────── 1-1/
+------------------+
```
[Intermediate]

---

Q: What is a kobj_type (ktype)?
A: A kobj_type defines the behavior of a class of kobjects:
- `release()`: cleanup function when refcount hits 0
- `sysfs_ops`: show/store functions for attributes
- `default_attrs`: attributes created automatically
- `namespace()`: for namespaced sysfs entries
[Intermediate]

---

Q: (Cloze) Every kobject must have an associated _____ that defines its release function and sysfs operations.
A: kobj_type (or ktype). Without a ktype, the kobject cannot be properly destroyed (memory leak) and cannot have sysfs attributes. The ktype's release() is called when kref drops to zero.
[Intermediate]

---

Q: What is the purpose of kobject reference counting?
A: Ensures the kobject (and its containing structure) isn't freed while still in use. kobject_get() increments the count, kobject_put() decrements. When count reaches 0, ktype->release() is called for cleanup.
[Intermediate]

---

Q: What functions manage kobject reference counts?
A:
- `kobject_get(kobj)`: increment refcount, returns kobj
- `kobject_put(kobj)`: decrement refcount, may trigger release
- `kref_get()`: underlying kref increment
- `kref_put()`: underlying kref decrement
[Intermediate]

---

Q: What happens when a kobject's reference count reaches zero?
A: The ktype->release() function is called. This function should free the kobject and typically the containing structure. The release is asynchronous - kobject_put() may return before release() runs.
[Intermediate]

---

Q: (Code Interpretation) What pattern does this demonstrate?
```c
struct my_device {
    struct kobject kobj;
    int value;
};

static void my_release(struct kobject *kobj)
{
    struct my_device *dev = container_of(kobj, struct my_device, kobj);
    kfree(dev);
}
```
A: The standard kobject embedding pattern:
1. Embed kobject in your structure (not a pointer!)
2. In release(), use container_of() to get your structure
3. Free your structure (which contains the kobject)
This ensures proper lifetime management.
[Intermediate]

---

Q: Why should kobject be embedded in structures rather than used as a pointer?
A: Embedding allows container_of() to work in release(). If kobject were a pointer, you'd need another way to find the containing structure. Embedding also ensures single allocation/free for the whole object.
[Intermediate]

---

Q: What is the container_of() macro?
A: Macro to get pointer to containing structure from a member pointer: `container_of(ptr, type, member)`. Uses pointer arithmetic: `(type *)((char *)ptr - offsetof(type, member))`. Essential for kobject release handlers.
[Intermediate]

---

Q: What is an attribute in sysfs?
A: An attribute represents a single sysfs file. It has a name (filename) and mode (permissions). The sysfs_ops from the ktype provide show() and store() functions to read/write the file content.
[Basic]

---

Q: (Code Interpretation) What does struct attribute contain?
```c
struct attribute {
    const char *name;
    struct module *owner;
    mode_t mode;
};
```
A: - `name`: filename in sysfs (e.g., "value")
- `owner`: module owning this attribute (for refcounting)
- `mode`: permissions (0644, 0444, etc.)
The attribute itself doesn't have show/store - those come from ktype->sysfs_ops.
[Intermediate]

---

Q: What is the role of sysfs_ops in a ktype?
A: sysfs_ops provides the show() and store() functions used for ALL attributes of kobjects with this ktype. The functions receive the kobject and attribute, allowing them to dispatch to attribute-specific handlers.
[Intermediate]

---

Q: (Code Interpretation) What do show() and store() look like?
```c
struct sysfs_ops {
    ssize_t (*show)(struct kobject *kobj, struct attribute *attr, char *buf);
    ssize_t (*store)(struct kobject *kobj, struct attribute *attr,
                     const char *buf, size_t count);
};
```
A: - `show(kobj, attr, buf)`: format value into buf (PAGE_SIZE max), return byte count
- `store(kobj, attr, buf, count)`: parse buf, update kernel state, return bytes consumed
Both receive the kobject (for context) and attribute (to identify which file).
[Intermediate]

---

Q: What is the maximum size for a sysfs show() output?
A: PAGE_SIZE (typically 4096 bytes). The buf parameter is a single page. Anything larger should be in debugfs or a binary attribute. This limit enforces the "simple values" philosophy.
[Intermediate]

---

Q: How does sysfs differ from procfs in its organizational structure?
A: Procfs is mostly flat with some directories (/proc/sys, /proc/net). Sysfs is strictly hierarchical, reflecting actual kernel object relationships. Device hierarchy, bus topology, and class membership are visible in the directory structure.
[Basic]

---

Q: (Reverse) This is a key difference: procfs is mostly flat, while _____ is strictly hierarchical reflecting kernel object relationships.
A: Q: How does sysfs differ from procfs structurally?
(Answer: sysfs)
[Basic]

---

Q: What is the relationship between sysfs and the Linux device model?
A: Sysfs IS the user-space view of the device model. When a device is registered, sysfs directories are created automatically. Bus, device, driver relationships visible in /sys directly reflect the kernel's internal device model structures.
[Intermediate]

---

Q: What kernel subsystem does sysfs closely integrate with?
A: The driver model / device model. struct device, struct bus_type, struct device_driver all embed kobjects. Registration with the driver core automatically creates sysfs entries.
[Basic]

---

Q: (ASCII Diagram) How does the device model map to sysfs?
A:
```
Device Model (Kernel)              Sysfs (/sys)
=====================              ============

struct bus_type                    /sys/bus/<bus>/
    └── struct device          --> /sys/bus/<bus>/devices/<dev>
                                       └── symlink to actual device

struct device                      /sys/devices/<path>/<dev>/
    ├── struct device_driver   --> /sys/devices/<path>/<dev>/driver -> ...
    └── struct class          --> /sys/class/<class>/<dev> -> ...

struct device_driver               /sys/bus/<bus>/drivers/<driver>/
```
[Intermediate]

---

Q: How does sysfs support hotplug/udev?
A: When kobjects are added/removed, the kernel sends uevents to userspace. udev listens for these events via netlink, reads device attributes from /sys, and creates /dev entries. Sysfs is the source of truth for udev.
[Intermediate]

---

Q: What is a uevent?
A: A kernel-to-userspace notification about kobject changes (add, remove, change, etc.). Sent via netlink socket. Contains kobject path, action, and environment variables. udev/systemd-udevd processes these to manage /dev.
[Intermediate]

---

Q: (Cloze) Uevents are sent via _____ socket to notify userspace about device additions and removals.
A: netlink. The KOBJECT_UEVENT netlink family carries add/remove/change/move events from kernel to userspace daemons like udev or mdev.
[Intermediate]

---

Q: What does /sys/bus contain?
A: Subdirectories for each bus type registered in the system (pci, usb, platform, i2c, etc.). Each bus directory contains `devices/` (symlinks to devices) and `drivers/` (subdirs for each driver).
[Basic]

---

Q: What does /sys/class contain?
A: Device class directories (net, block, tty, input, etc.). Classes group devices by function regardless of bus. Each class directory contains symlinks to devices in /sys/devices/. Example: /sys/class/net/eth0.
[Basic]

---

Q: What does /sys/devices contain?
A: The actual device hierarchy, organized by bus topology. This is where "real" device directories live (not symlinks). Example: /sys/devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda.
[Basic]

---

Q: (ASCII Diagram) Show the relationship between /sys/bus, /sys/class, and /sys/devices.
A:
```
/sys/
├── devices/                    # Actual device hierarchy
│   └── pci0000:00/
│       └── 0000:00:02.0/       # Real device directory
│           └── drm/
│               └── card0/
│
├── bus/
│   └── pci/
│       └── devices/
│           └── 0000:00:02.0 -> ../../../devices/pci0000:00/0000:00:02.0
│
└── class/
    └── drm/
        └── card0 -> ../../devices/pci0000:00/0000:00:02.0/drm/card0

Real data is in /sys/devices/; others are symlinks providing different views.
```
[Intermediate]

---

Q: Why does sysfs use so many symlinks?
A: To provide multiple views of the same device:
- By bus (how it's connected)
- By class (what it does)
- By topology (physical hierarchy)
Without duplication of device directories.
[Intermediate]

---

Q: What is /sys/module?
A: Contains a directory for each loaded kernel module. Each module directory has: parameters/ (module params), holders/, refcnt, etc. Unloading a module removes its /sys/module entry.
[Basic]

---

Q: What is /sys/kernel?
A: Contains kernel-wide attributes and subdirectories not associated with specific devices. Examples: /sys/kernel/debug (if debugfs mounted), /sys/kernel/mm (memory management), /sys/kernel/uevent_seqnum.
[Basic]

---

Q: What is /sys/firmware?
A: Exposes firmware-related data: ACPI tables, device tree (on ARM/PowerPC), DMI/SMBIOS info, EFI variables. Allows userspace to read firmware configuration.
[Basic]

---

Q: How does sysfs handle permissions and security?
A: Standard Unix permissions (mode in attribute). Files are owned by root by default. Write access often requires CAP_SYS_ADMIN. Some distributions use SELinux/AppArmor policies for additional sysfs restrictions.
[Intermediate]

---

Q: (Understanding) When should you use sysfs vs procfs for kernel data?
A: 
- **sysfs**: Device/driver information, hardware attributes, object hierarchies
- **procfs**: Process information, system statistics, kernel tunables (/proc/sys)
Rule: If it's related to the device model, use sysfs. If it's process or general system info, use procfs.
[Basic]

---

Q: What is the binary attribute (bin_attribute) in sysfs?
A: A special attribute type for binary data that doesn't fit the one-value-per-file rule. Has read/write functions with size/offset parameters. Used for firmware blobs, EEPROM content, etc.
[Intermediate]

---

Q: Why was sysfs designed with strict rules unlike procfs?
A: procfs's lack of structure led to abuse - driver developers dumped all kinds of data there in arbitrary formats. Sysfs rules (hierarchy, one-value-per-file, kobject-based) prevent this chaos and enable consistent tooling.
[Basic]

---

Q: (Reverse) This guideline prevents the chaos that occurred in procfs: each sysfs file should contain only a single value.
A: Q: What is sysfs's "one value per file" rule?
[Basic]

---

Q: What common tools interact with sysfs?
A:
- `udev`/`udevd`: Device node creation using sysfs attributes
- `lspci -v`: Reads PCI device info from sysfs
- `lsusb`: Reads USB device info from sysfs
- `systool`: Browse sysfs (from sysfsutils package)
- Direct reads/writes: echo/cat for device control
[Basic]

---

Q: How can you trigger a device rescan or other action through sysfs?
A: Some devices have writable "trigger" files. Example: `echo 1 > /sys/bus/pci/rescan` triggers PCI bus rescan. The kernel handler reads the value and performs the action. These are sometimes called "trigger attributes".
[Intermediate]

---

Q: What is /sys/power?
A: Contains power management interfaces: state (sleep states), wakeup_count, pm_async, disk (hibernate mode), etc. Writing to `state` can suspend the system.
[Basic]

---

## Section 4: COMPLETE ✓

---

## Section 5: SysFS Directory Structure

---

Q: What subdirectories exist directly under /sys?
A: Main subdirectories:
- `bus/` - bus type subdirectories
- `class/` - device class groupings
- `devices/` - device hierarchy (actual objects)
- `block/` - block devices (symlinks)
- `module/` - loaded kernel modules
- `kernel/` - kernel-wide attributes
- `firmware/` - firmware interfaces
- `power/` - power management
[Basic]

---

Q: What is the internal structure of /sys/bus/<bustype>/?
A: Each bus directory contains:
- `devices/` - symlinks to all devices on this bus
- `drivers/` - subdirectory for each registered driver
- `drivers_probe` - write device name to force driver binding
- `drivers_autoprobe` - enable/disable automatic driver probing
- `uevent` - trigger uevent for the bus
[Intermediate]

---

Q: (ASCII Diagram) Show the structure of /sys/bus/pci/.
A:
```
/sys/bus/pci/
├── devices/
│   ├── 0000:00:00.0 -> ../../../devices/pci0000:00/0000:00:00.0
│   ├── 0000:00:02.0 -> ../../../devices/pci0000:00/0000:00:02.0
│   └── ...
├── drivers/
│   ├── pcieport/
│   │   ├── bind          # write device name to bind
│   │   ├── unbind        # write device name to unbind
│   │   └── 0000:00:1c.0 -> ../../../../devices/pci0000:00/0000:00:1c.0
│   └── e1000e/
│       └── ...
├── drivers_probe
├── drivers_autoprobe
└── uevent
```
[Intermediate]

---

Q: What files exist in a driver's sysfs directory?
A: Typical driver directory (/sys/bus/<bus>/drivers/<driver>/) contains:
- `bind` - write device name to bind driver to device
- `unbind` - write device name to unbind driver
- `uevent` - trigger uevent
- Symlinks to bound devices
- Module reference symlink
[Intermediate]

---

Q: How do you manually bind/unbind a driver from a device via sysfs?
A: 
- Unbind: `echo "0000:00:02.0" > /sys/bus/pci/drivers/i915/unbind`
- Bind: `echo "0000:00:02.0" > /sys/bus/pci/drivers/i915/bind`
Device must be compatible with the driver for bind to succeed.
[Intermediate]

---

Q: What is /sys/block and what does it contain?
A: `/sys/block` contains symlinks to all block devices in the system. Example: /sys/block/sda -> ../devices/pci0000:00/.../block/sda. Provides quick access to block devices without navigating device hierarchy.
[Basic]

---

Q: (Reverse) This /sys subdirectory provides quick access to all block devices via symlinks.
A: Q: What is /sys/block?
[Basic]

---

Q: What files/directories exist in a block device's sysfs directory?
A: Common entries in /sys/block/<dev>/:
- `size` - device size in 512-byte sectors
- `queue/` - I/O scheduler settings, queue parameters
- `stat` - I/O statistics
- `device` - symlink to parent device
- `holders/` - devices using this one
- Partition subdirectories (sda1, sda2, etc.)
[Intermediate]

---

Q: What is the structure of /sys/class/<classname>/?
A: Each class directory contains symlinks to devices in that class:
```
/sys/class/net/
├── eth0 -> ../../devices/pci0000:00/.../net/eth0
├── lo -> ../../devices/virtual/net/lo
└── wlan0 -> ../../devices/pci0000:00/.../net/wlan0
```
Classes group devices by function.
[Basic]

---

Q: How do /sys/class and /sys/bus differ in their organization?
A: 
- `/sys/bus` - groups devices by how they're connected (PCI, USB, I2C)
- `/sys/class` - groups devices by what they do (network, block, input)
Same device appears in both, differently organized.
[Basic]

---

Q: What common entries exist in /sys/devices/system/?
A: System devices not attached to a bus:
- `cpu/` - CPU information (cpufreq, topology)
- `memory/` - memory hotplug information
- `node/` - NUMA node information
- `clocksource/` - available clock sources
[Intermediate]

---

Q: What is /sys/devices/virtual/?
A: Contains virtual devices not backed by physical hardware:
- Virtual network interfaces (lo, tun, bridges)
- Virtual block devices (loop, dm-*)
- Virtual TTYs
- Memory-backed devices
[Basic]

---

Q: What information can be found in /sys/module/<modulename>/?
A: 
- `parameters/` - module parameters (read/write for writable params)
- `sections/` - ELF section addresses (for debugging)
- `refcnt` - reference count
- `holders/` - modules depending on this one
- `initstate` - "live", "coming", "going"
- `uevent` - trigger uevent
[Intermediate]

---

Q: (Code Interpretation) How can you check or modify a module parameter via sysfs?
```bash
# Read current value
cat /sys/module/e1000e/parameters/IntMode

# Change value (if parameter is writable)
echo 2 > /sys/module/e1000e/parameters/IntMode
```
A: Module parameters appear as files in /sys/module/<mod>/parameters/. Read-only parameters have mode 0444, writable have 0644. Changes via sysfs take effect immediately for parameters that support runtime modification.
[Intermediate]

---

Q: What is /sys/firmware/acpi?
A: ACPI firmware interface containing:
- `tables/` - raw ACPI tables (DSDT, SSDT, etc.)
- `pm_profile` - power management profile
- `interrupts/` - ACPI interrupt statistics
Platform-specific subdirectories for ACPI device control.
[Intermediate]

---

Q: What is /sys/firmware/dmi?
A: DMI (Desktop Management Interface) / SMBIOS data:
- `tables/` - raw DMI tables
- `entries/` - parsed DMI entries
Provides system information: manufacturer, product name, serial numbers, BIOS version.
[Intermediate]

---

Q: What does /sys/power/state contain?
A: Available sleep states and current state. Reading shows supported states (freeze, mem, disk). Writing triggers transition: `echo mem > /sys/power/state` puts system to sleep (RAM suspend).
[Basic]

---

Q: (ASCII Diagram) Show a typical device's complete sysfs representation.
A:
```
PCI Network Card Example:

/sys/devices/pci0000:00/0000:00:1c.0/0000:01:00.0/  # Actual device
├── class                 # 0x020000 (network controller)
├── vendor                # 0x8086 (Intel)
├── device                # Device ID
├── irq                   # Interrupt number
├── resource              # Memory/IO resources
├── driver -> ../../../../bus/pci/drivers/e1000e
├── net/
│   └── eth0/
│       ├── address       # MAC address
│       ├── mtu
│       ├── operstate     # up/down
│       └── statistics/
└── uevent

/sys/bus/pci/devices/0000:01:00.0 -> symlink to above
/sys/class/net/eth0 -> symlink to net/eth0 above
```
[Intermediate]

---

Q: How do you find the actual device directory from a /sys/class symlink?
A: Use `readlink -f /sys/class/<class>/<device>` to resolve the symlink to the actual path in /sys/devices/. Example: `readlink -f /sys/class/net/eth0` returns full /sys/devices/... path.
[Basic]

---

Q: What does /sys/kernel/mm/ contain?
A: Memory management interfaces:
- `hugepages/` - huge page configuration
- `ksm/` - Kernel Same-page Merging statistics (if enabled)
- `transparent_hugepage/` - THP settings
Used for memory tuning and statistics.
[Intermediate]

---

## Section 5: COMPLETE ✓

---

## Section 6: SysFS Implementation Internals

---

Q: What function initializes a kobject?
A: `kobject_init(kobj, ktype)` - Sets up the kobject: clears fields, initializes reference count to 1, sets the ktype. Must be called before kobject_add(). Never re-initialize an active kobject.
[Intermediate]

---

Q: What function adds a kobject to sysfs?
A: `kobject_add(kobj, parent, fmt, ...)` - Creates sysfs directory for the kobject. The parent determines location in hierarchy. fmt/... specify the directory name (printf-style). Returns 0 on success.
[Intermediate]

---

Q: What is the convenience function that combines init and add?
A: `kobject_init_and_add(kobj, ktype, parent, fmt, ...)` - Calls kobject_init() then kobject_add() in one step. Common pattern for simple cases. Still need to call kobject_put() on failure or cleanup.
[Intermediate]

---

Q: (Code Interpretation) What does this kobject setup do?
```c
struct my_obj {
    struct kobject kobj;
    int value;
};

static struct my_obj *obj;
static struct kobj_type my_ktype = { .release = my_release };

obj = kzalloc(sizeof(*obj), GFP_KERNEL);
kobject_init(&obj->kobj, &my_ktype);
kobject_add(&obj->kobj, NULL, "my_object");
```
A: Creates a top-level sysfs directory:
1. Allocates memory for object
2. Initializes embedded kobject with ktype
3. Adds to sysfs under /sys with name "my_object"
Result: /sys/my_object/ directory is created.
[Intermediate]

---

Q: What does kobject_uevent() do?
A: Sends a hotplug/uevent notification for the kobject. Actions: KOBJ_ADD, KOBJ_REMOVE, KOBJ_CHANGE. Example: `kobject_uevent(&kobj, KOBJ_ADD)` notifies userspace (udev) that a new object exists.
[Intermediate]

---

Q: What is the combined add-and-uevent pattern?
A: After kobject_add(), call kobject_uevent() to notify userspace:
```c
kobject_init_and_add(&obj->kobj, &ktype, parent, "myobj");
kobject_uevent(&obj->kobj, KOBJ_ADD);
```
This is the standard pattern for new device-like objects.
[Intermediate]

---

Q: How do you remove a kobject from sysfs?
A: `kobject_del(kobj)` - Removes the sysfs directory. Then `kobject_put(kobj)` - Decrements refcount, triggers release when zero. Often combined: `kobject_put()` after `kobject_del()`.
[Intermediate]

---

Q: (Cloze) The correct removal sequence is: _____ to remove from sysfs, then _____ to release the reference.
A: `kobject_del()`, `kobject_put()`. kobject_del() removes sysfs representation, kobject_put() handles refcount and eventual memory release. Some code uses just kobject_put() if the kobject wasn't added to sysfs.
[Intermediate]

---

Q: What is the purpose of sysfs_create_file()?
A: Creates a single attribute file for a kobject:
`sysfs_create_file(&kobj, &my_attr.attr)`
The attribute's show/store are called via kobj->ktype->sysfs_ops. Returns 0 on success.
[Intermediate]

---

Q: How do you remove a sysfs attribute file?
A: `sysfs_remove_file(&kobj, &my_attr.attr)` - Removes the attribute file from the kobject's sysfs directory. Call before kobject_del() during cleanup.
[Intermediate]

---

Q: What is an attribute group?
A: A collection of attributes that can be created/removed together. Struct attribute_group contains name (subdirectory) and array of attributes. Created with `sysfs_create_group()`, removed with `sysfs_remove_group()`.
[Intermediate]

---

Q: (Code Interpretation) How are attribute groups defined and used?
```c
static struct attribute *my_attrs[] = {
    &attr1.attr,
    &attr2.attr,
    &attr3.attr,
    NULL,
};

static struct attribute_group my_group = {
    .name = "settings",  /* optional: creates subdirectory */
    .attrs = my_attrs,
};

sysfs_create_group(&kobj, &my_group);
```
A: Creates multiple attributes at once:
- If `.name` is set, creates /sys/.../kobject/settings/ subdirectory
- If `.name` is NULL, attributes go directly in kobject's directory
- NULL-terminated array of attribute pointers
Much cleaner than individual sysfs_create_file() calls.
[Intermediate]

---

Q: What is device_attribute and how does it differ from attribute?
A: device_attribute wraps attribute for struct device:
```c
struct device_attribute {
    struct attribute attr;
    ssize_t (*show)(struct device *dev, struct device_attribute *attr, char *buf);
    ssize_t (*store)(struct device *dev, struct device_attribute *attr,
                     const char *buf, size_t count);
};
```
The show/store receive struct device* directly, not kobject*.
[Intermediate]

---

Q: What is the DEVICE_ATTR macro?
A: `DEVICE_ATTR(name, mode, show, store)` - Declares a device_attribute:
```c
DEVICE_ATTR(my_attr, 0644, my_show, my_store);
// Expands to:
// struct device_attribute dev_attr_my_attr = {...};
```
Creates variable named `dev_attr_<name>`.
[Intermediate]

---

Q: (Code Interpretation) What does this device attribute implementation do?
```c
static ssize_t value_show(struct device *dev,
                          struct device_attribute *attr, char *buf)
{
    struct my_device *mydev = dev_get_drvdata(dev);
    return sprintf(buf, "%d\n", mydev->value);
}

static ssize_t value_store(struct device *dev,
                           struct device_attribute *attr,
                           const char *buf, size_t count)
{
    struct my_device *mydev = dev_get_drvdata(dev);
    int val;
    if (kstrtoint(buf, 10, &val))
        return -EINVAL;
    mydev->value = val;
    return count;
}

static DEVICE_ATTR_RW(value);
```
A: Complete read/write sysfs attribute:
- show: Gets driver data, formats value as decimal + newline
- store: Parses integer from user input, stores it
- DEVICE_ATTR_RW: Creates attribute with show and store
Creates /sys/.../device/value file.
[Intermediate]

---

Q: What are the DEVICE_ATTR variants?
A: 
- `DEVICE_ATTR(name, mode, show, store)` - full control
- `DEVICE_ATTR_RW(name)` - read/write, uses name_show/name_store
- `DEVICE_ATTR_RO(name)` - read-only, uses name_show
- `DEVICE_ATTR_WO(name)` - write-only, uses name_store
RW/RO/WO set permissions automatically.
[Intermediate]

---

Q: How do you add attributes to a device?
A: 
- `device_create_file(dev, &dev_attr_name)` - single attribute
- `device_add_groups(dev, groups)` - attribute groups
Or use default_groups in struct device_type for automatic creation.
[Intermediate]

---

Q: What is struct bin_attribute for?
A: Binary attributes for large or binary data. Unlike regular attributes:
- Has size field
- read/write functions take offset parameter
- Can be larger than PAGE_SIZE
Used for firmware, EEPROM, large config data.
[Intermediate]

---

Q: (Code Interpretation) What does struct bin_attribute contain?
```c
struct bin_attribute {
    struct attribute attr;
    size_t size;
    void *private;
    ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *,
                    char *buf, loff_t off, size_t count);
    ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *,
                     char *buf, loff_t off, size_t count);
    int (*mmap)(struct file *, struct kobject *, struct bin_attribute *,
                struct vm_area_struct *);
};
```
A: Binary attribute for non-ASCII data:
- `size`: total size of binary data
- `read/write`: handle offset and count (like regular files)
- `mmap`: optional memory mapping support
- `private`: custom data pointer
Used with `sysfs_create_bin_file()`.
[Advanced]

---

Q: What is a kset and when should you use one?
A: A kset is a collection of kobjects that:
- Shares a common parent in sysfs
- Has unified uevent handling
- Can filter/modify uevents for all members
Use when you have multiple similar objects (e.g., all devices on a bus).
[Intermediate]

---

Q: How do you create and register a kset?
A: `kset_create_and_add(name, uevent_ops, parent_kobj)`:
```c
my_kset = kset_create_and_add("myobjects", NULL, kernel_kobj);
```
Creates /sys/kernel/myobjects/ directory. Member kobjects set their kset field before kobject_add().
[Intermediate]

---

Q: (Code Interpretation) How does a kobject join a kset?
```c
obj->kobj.kset = my_kset;
kobject_init_and_add(&obj->kobj, &my_ktype, NULL, "obj1");
```
A: Set kobject's kset field BEFORE calling kobject_add(). If parent is NULL but kset is set, the kobject appears under the kset's directory:
/sys/.../myobjects/obj1/
The kset manages the kobject list and can intercept uevents.
[Intermediate]

---

Q: What is the sysfs_dirent structure?
A: Internal sysfs structure (renamed to kernfs_node in later kernels). Each sysfs entry (file, directory, symlink) has one. Contains: name hash, parent, mode, and union of type-specific data. Not directly used by drivers.
[Advanced]

---

Q: What locking protects sysfs operations?
A: sysfs uses:
- `sysfs_mutex` for directory operations
- Per-attribute locking for show/store
- kobject kref for lifetime
Drivers should use their own locking in show/store for their data.
[Advanced]

---

Q: (Understanding) Why should show/store functions be careful about locking?
A: show/store may be called concurrently from multiple processes. If they access shared driver state, that state needs locking. sysfs only protects its own structures, not driver data.
[Intermediate]

---

Q: What is the return value convention for show() functions?
A: Return bytes written to buf (positive) or negative error code. Include newline in output but count it in return value:
```c
return sprintf(buf, "%d\n", value);  // Returns 2 for "5\n"
```
Never return 0 unless the attribute is truly empty.
[Intermediate]

---

Q: What is the return value convention for store() functions?
A: Return bytes consumed (typically `count`) or negative error code. Must return a positive value on success or the write will retry:
```c
return count;  // Success - consumed all input
return -EINVAL;  // Invalid input
```
[Intermediate]

---

Q: How do you create a symlink in sysfs?
A: `sysfs_create_link(kobj, target, name)`:
```c
sysfs_create_link(&dev->kobj, &driver->kobj, "driver");
```
Creates symlink "driver" in dev's directory pointing to driver's directory. Remove with `sysfs_remove_link()`.
[Intermediate]

---

Q: What does device_add() do with sysfs?
A: When a device is added to the driver model, device_add():
1. Calls kobject_add() - creates /sys/devices/... directory
2. Creates default attributes
3. Creates bus/class symlinks
4. Sends uevent
Most drivers use device_register() which calls device_initialize() + device_add().
[Intermediate]

---

Q: (ASCII Diagram) Show the call path for adding a device to sysfs.
A:
```
device_register()
    │
    ├── device_initialize()
    │       └── kobject_init(&dev->kobj, &device_ktype)
    │
    └── device_add()
            ├── kobject_add(&dev->kobj, parent, name)
            │       └── creates /sys/devices/.../name/
            ├── device_create_file() for default attrs
            ├── bus_add_device()
            │       └── sysfs_create_link() for bus symlinks
            ├── device_add_class_symlinks()
            └── kobject_uevent(&dev->kobj, KOBJ_ADD)
                    └── notifies udev
```
[Advanced]

---

## Section 6: COMPLETE ✓

---

## Section 7: Kernel APIs and Code Patterns

---

Q: What is the complete pattern for creating a simple procfs file using seq_file?
A:
```c
static int my_show(struct seq_file *m, void *v) {
    seq_printf(m, "value: %d\n", my_value);
    return 0;
}

static int my_open(struct inode *inode, struct file *file) {
    return single_open(file, my_show, NULL);
}

static const struct file_operations my_fops = {
    .owner   = THIS_MODULE,
    .open    = my_open,
    .read    = seq_read,
    .llseek  = seq_lseek,
    .release = single_release,
};

proc_create("myfile", 0444, NULL, &my_fops);
```
Creates /proc/myfile, read-only.
[Intermediate]

---

Q: What is the pattern for a proc file that iterates over a list?
A:
```c
static void *my_start(struct seq_file *m, loff_t *pos) {
    return seq_list_start(&my_list, *pos);
}
static void *my_next(struct seq_file *m, void *v, loff_t *pos) {
    return seq_list_next(v, &my_list, pos);
}
static void my_stop(struct seq_file *m, void *v) { /* nothing */ }
static int my_show(struct seq_file *m, void *v) {
    struct my_item *item = list_entry(v, struct my_item, list);
    seq_printf(m, "%s\n", item->name);
    return 0;
}

static const struct seq_operations my_seq_ops = {
    .start = my_start, .next = my_next,
    .stop = my_stop, .show = my_show,
};
```
Use with `seq_open(file, &my_seq_ops)` in open handler.
[Intermediate]

---

Q: What helper functions exist for iterating kernel lists in seq_file?
A:
- `seq_list_start(head, pos)` - get item at position
- `seq_list_next(v, head, pos)` - get next item
- `seq_list_start_head(head, pos)` - start at head
These handle the common case of iterating struct list_head.
[Intermediate]

---

Q: (Code Interpretation) How does this write handler parse multiple values?
```c
static ssize_t my_write(struct file *file, const char __user *buf,
                        size_t count, loff_t *ppos)
{
    char kbuf[64];
    int a, b;

    if (count >= sizeof(kbuf)) return -EINVAL;
    if (copy_from_user(kbuf, buf, count)) return -EFAULT;
    kbuf[count] = '\0';

    if (sscanf(kbuf, "%d %d", &a, &b) != 2)
        return -EINVAL;

    do_something(a, b);
    return count;
}
```
A: Pattern for parsing space-separated values:
1. Copy user data to kernel buffer (size check first!)
2. Null-terminate the string
3. Use sscanf to parse (check return value!)
4. Return count on success, -EINVAL on parse failure
[Intermediate]

---

Q: What is the standard sysfs show/store pattern for a device attribute?
A:
```c
static ssize_t foo_show(struct device *dev,
        struct device_attribute *attr, char *buf) {
    struct my_dev *d = dev_get_drvdata(dev);
    return sprintf(buf, "%d\n", d->foo);
}

static ssize_t foo_store(struct device *dev,
        struct device_attribute *attr, const char *buf, size_t count) {
    struct my_dev *d = dev_get_drvdata(dev);
    int val;
    if (kstrtoint(buf, 10, &val)) return -EINVAL;
    d->foo = val;
    return count;
}
static DEVICE_ATTR_RW(foo);
```
[Intermediate]

---

Q: What parsing functions should be used instead of sscanf for single values?
A: kstrto* family (kernel string to number):
- `kstrtoint(buf, base, &val)` - int
- `kstrtol(buf, base, &val)` - long
- `kstrtoul(buf, base, &val)` - unsigned long
- `kstrtobool(buf, &val)` - boolean (y/n/1/0)
Returns 0 on success, -EINVAL on failure.
[Intermediate]

---

Q: Why prefer kstrtoint() over sscanf() or simple_strtol()?
A: 
- `kstrtoint()`: validates entire string, reports errors properly
- `sscanf()`: stops at first non-matching char, no error for trailing garbage
- `simple_strtol()`: deprecated, no error checking
kstrto* is the modern, safe choice.
[Intermediate]

---

Q: (Code Interpretation) What's wrong with this show function?
```c
static ssize_t bad_show(struct device *dev,
        struct device_attribute *attr, char *buf) {
    return sprintf(buf, "%d", value);  /* BUG */
}
```
A: Missing newline! Sysfs convention requires trailing newline:
```c
return sprintf(buf, "%d\n", value);  /* Correct */
```
Without newline, `cat /sys/.../file` output runs into prompt.
[Intermediate]

---

Q: What is the pattern for creating a sysfs directory with multiple attributes?
A:
```c
static struct attribute *my_attrs[] = {
    &dev_attr_foo.attr,
    &dev_attr_bar.attr,
    NULL,  /* Must be NULL-terminated */
};
ATTRIBUTE_GROUPS(my);  /* Creates my_groups[] */

/* In driver: */
static struct device_type my_type = {
    .groups = my_groups,
};
/* Or manually: */
device_add_groups(dev, my_groups);
```
[Intermediate]

---

Q: What is the ATTRIBUTE_GROUPS macro?
A: Convenience macro that creates the groups array:
```c
static struct attribute *foo_attrs[] = { ..., NULL };
ATTRIBUTE_GROUPS(foo);
/* Expands to: */
static const struct attribute_group foo_group = { .attrs = foo_attrs };
static const struct attribute_group *foo_groups[] = { &foo_group, NULL };
```
[Intermediate]

---

Q: (ASCII Diagram) Show the relationship between driver data structures and sysfs.
A:
```
struct my_driver                    /sys/bus/pci/drivers/my_driver/
├── driver.groups ──────────────────├── foo (attribute)
│   └── driver_attr_foo             ├── bar (attribute)
│                                   └── 0000:01:00.0 -> (bound device)

struct my_device                    /sys/devices/.../0000:01:00.0/
├── dev.kobj ───────────────────────├── driver -> ../../../drivers/my_driver
├── dev.groups ─────────────────────├── value (attribute from group)
│   └── dev_attr_value              └── power/
└── dev.drvdata ───┐                    └── control
                   │
                   v
            struct my_private_data
            (accessed in show/store via dev_get_drvdata)
```
[Intermediate]

---

Q: How do you pass private data to a proc file handler?
A: Use proc_create_data() with data pointer:
```c
proc_create_data("myfile", 0644, NULL, &fops, my_data);
```
Access in handler via:
```c
void *data = PDE_DATA(file_inode(file));
/* or via seq_file: */
void *data = ((struct seq_file *)file->private_data)->private;
```
[Intermediate]

---

Q: What is the pattern for a writable /proc/sys-style tunable in procfs?
A:
```c
static int value = 100;

static int my_show(struct seq_file *m, void *v) {
    seq_printf(m, "%d\n", value);
    return 0;
}

static ssize_t my_write(struct file *file, const char __user *buf,
                        size_t count, loff_t *ppos) {
    int val;
    if (kstrtoint_from_user(buf, count, 10, &val))
        return -EINVAL;
    value = val;
    return count;
}

static int my_open(struct inode *inode, struct file *file) {
    return single_open(file, my_show, NULL);
}

static const struct file_operations my_fops = {
    .open = my_open, .read = seq_read, .write = my_write,
    .llseek = seq_lseek, .release = single_release,
};
```
[Intermediate]

---

Q: What is kstrtoint_from_user() and when to use it?
A: Combines copy_from_user and kstrtoint in one call:
```c
kstrtoint_from_user(ubuf, count, base, &val)
```
Useful for simple sysfs/procfs store handlers. Returns 0 on success. Handles the user-space buffer directly.
[Intermediate]

---

Q: (Code Interpretation) What error handling is missing here?
```c
static int my_init(void)
{
    proc_create("foo", 0644, NULL, &foo_fops);
    proc_create("bar", 0644, NULL, &bar_fops);
    return 0;
}
```
A: No error checking! proc_create returns NULL on failure:
```c
static int my_init(void) {
    entry_foo = proc_create("foo", 0644, NULL, &foo_fops);
    if (!entry_foo)
        return -ENOMEM;
    entry_bar = proc_create("bar", 0644, NULL, &bar_fops);
    if (!entry_bar) {
        remove_proc_entry("foo", NULL);
        return -ENOMEM;
    }
    return 0;
}
```
[Intermediate]

---

Q: What is the cleanup pattern for procfs entries?
A:
```c
static void my_exit(void)
{
    remove_proc_entry("bar", proc_dir);  /* children first */
    remove_proc_entry("foo", proc_dir);
    remove_proc_entry("mydir", NULL);    /* then parent */
}
```
Remove children before parent. Pass the parent directory to remove_proc_entry.
[Intermediate]

---

Q: What is the cleanup pattern for sysfs kobject entries?
A:
```c
static void my_exit(void)
{
    sysfs_remove_group(&kobj, &my_group);  /* attributes first */
    kobject_uevent(&kobj, KOBJ_REMOVE);     /* notify userspace */
    kobject_del(&kobj);                     /* remove from sysfs */
    kobject_put(&kobj);                     /* release reference */
}
```
[Intermediate]

---

Q: How do you safely read a variable that might change during sysfs read?
A: Options:
1. Use atomic types: `atomic_read(&my_atomic_var)`
2. Use spinlock: `spin_lock(); val = shared; spin_unlock();`
3. Use RCU for pointer-based data
4. Accept small races for statistics (document it)
[Intermediate]

---

Q: (Code Interpretation) What does scnprintf() do and why use it over sprintf()?
```c
return scnprintf(buf, PAGE_SIZE, "%s\n", long_string);
```
A: `scnprintf()` is bounds-checked sprintf that never writes beyond the buffer:
- Returns actual bytes written (excluding \0)
- Won't overflow even if output exceeds size
- Prefer for sysfs show() to avoid buffer overruns
sprintf() can overflow if output exceeds PAGE_SIZE.
[Intermediate]

---

Q: What macros help define proc/sysfs entries at compile time?
A: In procfs:
```c
#define MY_PROC_FOPS(name) \
    static const struct file_operations name##_fops = { ... }
```
In sysfs:
```c
DEVICE_ATTR_RO(name)      /* creates dev_attr_name */
DEVICE_ATTR_RW(name)
DEVICE_ATTR_WO(name)
```
Reduces boilerplate.
[Intermediate]

---

Q: (ASCII Diagram) Compare procfs and sysfs file creation call stacks.
A:
```
ProcFS File Creation:
──────────────────────
proc_create("name", mode, parent, &fops)
    └── __proc_create()
            ├── allocate proc_dir_entry
            ├── set name, mode, fops
            └── add to parent's child list

SysFS File Creation (via device):
──────────────────────────────────
device_register(dev)
    └── device_add(dev)
            ├── kobject_add(&dev->kobj, ...)
            │       └── create_dir(kobj)
            │               └── sysfs_create_dir(kobj)
            └── device_add_groups(dev, groups)
                    └── sysfs_create_groups(&dev->kobj, groups)
                            └── sysfs_create_group() per group
                                    └── create_files() for each attr
```
[Advanced]

---

Q: What is the sysfs_emit() function (newer kernels)?
A: Safer replacement for sprintf/scnprintf in sysfs show functions:
```c
return sysfs_emit(buf, "%d\n", value);
```
Automatically handles PAGE_SIZE limit and proper formatting. Not in v3.2 but important to know for modern kernels.
[Advanced]

---

Q: How do you handle the case where procfs/sysfs data depends on module being loaded?
A: Use try_module_get()/module_put() in open/release:
```c
static int my_open(struct inode *inode, struct file *file) {
    if (!try_module_get(THIS_MODULE))
        return -ENODEV;
    return single_open(file, my_show, NULL);
}
static int my_release(struct inode *inode, struct file *file) {
    module_put(THIS_MODULE);
    return single_release(inode, file);
}
```
Or set .owner = THIS_MODULE in file_operations.
[Intermediate]

---

Q: What does setting .owner = THIS_MODULE do in file_operations?
A: Automatically prevents module unload while file is open. VFS calls try_module_get(fops->owner) on open and module_put() on release. Simpler than manual module refcount management.
[Intermediate]

---

Q: (Understanding) When might you NOT set .owner = THIS_MODULE?
A: For core kernel procfs/sysfs entries that aren't in modules, or when you need custom lifetime management. Most module code SHOULD set .owner for safety.
[Intermediate]

---

## Section 7: COMPLETE ✓

---

## Section 8: Advanced Topics and Comparisons

---

Q: Compare procfs, sysfs, debugfs, and configfs - when to use each?
A:
- **procfs**: Process info, system stats, kernel tunables (/proc/sys)
- **sysfs**: Device model, hardware attributes, driver config
- **debugfs**: Developer debugging, internal kernel state, not for production
- **configfs**: User-created kernel objects (like gadget USB configs)
Rule: procfs for processes, sysfs for devices, debugfs for debug, configfs for runtime object creation.
[Intermediate]

---

Q: What is debugfs and how does it differ from procfs/sysfs?
A: Debugfs (/sys/kernel/debug) is for kernel debugging info with no stability guarantees. Unlike procfs/sysfs:
- No ABI stability - format can change anytime
- Often not mounted in production
- Very simple API (debugfs_create_*)
- Used for tracing, internal stats, developer tools
[Intermediate]

---

Q: What is configfs?
A: Configfs (/sys/kernel/config) allows userspace to create/configure kernel objects at runtime. Unlike sysfs (kernel exports objects), configfs lets users mkdir to create objects. Used by USB gadget framework, target (iSCSI), etc.
[Intermediate]

---

Q: (Reverse) This filesystem allows userspace to create kernel objects by making directories.
A: Q: What is configfs?
[Intermediate]

---

Q: What is the key design difference between sysfs and configfs?
A: 
- **sysfs**: Kernel creates objects, exports to userspace (read/sometimes write)
- **configfs**: Userspace creates objects via mkdir, kernel provides attributes
sysfs is "kernel tells user", configfs is "user tells kernel".
[Intermediate]

---

Q: (Misconception) "I should put my driver's debug information in /proc"
A: WRONG for modern kernels. Use debugfs for debug info - it's designed for this purpose with no ABI guarantees. procfs is for stable, documented interfaces. Debug output can change freely in debugfs.
[Intermediate]

---

Q: (Misconception) "Sysfs files can contain multiple values for efficiency"
A: WRONG. Sysfs strictly enforces one value per file. If you need multiple values, use:
- Multiple files
- A debugfs file (if it's debug data)
- An attribute group or subdirectory
Multi-value files violate sysfs design.
[Intermediate]

---

Q: (Misconception) "proc_create() entries persist across module unload"
A: WRONG. When a module is unloaded, its procfs entries must be removed by the module's exit function. Leftover entries cause dangling pointers and crashes. Always pair proc_create() with remove_proc_entry() in cleanup.
[Intermediate]

---

Q: What security considerations apply to procfs/sysfs?
A: 
- Set restrictive permissions (0400, 0600) for sensitive data
- Some info (kallsyms, maps) can aid attackers
- Kernel options: CONFIG_GRKERNSEC, kptr_restrict
- SELinux/AppArmor can restrict /proc and /sys access
- Root-only files still visible to container root in some configs
[Intermediate]

---

Q: What is kptr_restrict and how does it affect procfs?
A: Sysctl `/proc/sys/kernel/kptr_restrict`:
- 0: kernel pointers visible to all
- 1: hidden from unprivileged users
- 2: hidden from everyone (including root)
Affects /proc/kallsyms, module addresses. Security hardening measure.
[Intermediate]

---

Q: What happened to procfs API in kernel 3.10+?
A: Major cleanup:
- `create_proc_entry()` removed - use `proc_create()`
- `create_proc_read_entry()` removed
- `read_proc`/`write_proc` callbacks removed - use file_operations
- `proc_create_data()` for data pointer
v3.2 has both old and new APIs; prefer new ones.
[Intermediate]

---

Q: What is the relationship between /sys and udev rules?
A: udev rules match against sysfs attributes to:
- Set device permissions
- Create symlinks (/dev/disk/by-id, etc.)
- Run programs on device events
Example: `ATTR{vendor}=="0x8086"` matches sysfs vendor file content.
[Intermediate]

---

Q: (Code Interpretation) What does this udev rule do?
```
SUBSYSTEM=="block", ATTR{removable}=="1", MODE="0666"
```
A: For any block device where /sys/.../removable contains "1":
- Sets device file permissions to 0666 (world read/write)
The ATTR match reads the sysfs attribute to filter devices.
[Intermediate]

---

Q: What is /proc/sys/kernel/modprobe?
A: Path to the modprobe binary used for automatic module loading. When kernel needs a module, it runs this program. Usually `/sbin/modprobe`. Rarely changed; example of procfs exposing kernel config.
[Intermediate]

---

Q: How do namespaces affect procfs?
A: Process namespaces affect what's visible in /proc:
- PID namespace: /proc shows only processes in that namespace
- Network namespace: /proc/net shows namespace's network info
- /proc/self varies by namespace (different PID mappings)
Containerization relies heavily on this.
[Advanced]

---

Q: (ASCII Diagram) Summarize the virtual filesystem landscape.
A:
```
Virtual Filesystems in Linux
────────────────────────────

/proc (procfs)              /sys (sysfs)
├── Process info            ├── Device hierarchy
├── System statistics       ├── Bus/class/driver
├── Kernel tunables         ├── Kobject attributes
└── Legacy driver info      └── One value per file

/sys/kernel/debug (debugfs) /sys/kernel/config (configfs)
├── No ABI stability        ├── User creates objects
├── Developer tools         ├── USB gadgets
├── Tracing                 ├── Target (iSCSI)
└── Internal state          └── Subsystem configs

                    VFS
                     │
    ┌────────────────┼────────────────┐
    │                │                │
  procfs          sysfs           debugfs
    │                │                │
 pseudo         pseudo           pseudo
filesystem     filesystem       filesystem
    │                │                │
  kernel          kobject         kernel
  data            model           debug
```
[Intermediate]

---

Q: What are the best practices for driver developers regarding procfs/sysfs?
A: 
1. Use sysfs for device attributes (not procfs)
2. Follow one-value-per-file rule
3. Use debugfs for debug/internal data
4. Document attribute formats
5. Handle concurrent access safely
6. Clean up entries on module exit
7. Set appropriate permissions
8. Use standard helpers (seq_file, DEVICE_ATTR)
[Intermediate]

---

Q: (Understanding) Why is the procfs/sysfs split important for Linux maintainability?
A: Clear separation of concerns:
- procfs: stable, process-focused, general system info
- sysfs: device model, structured hierarchy, discoverable
Without this split, both became dumping grounds (/proc in early kernels). Rules prevent chaos and enable tooling.
[Intermediate]

---

Q: What tools can browse/query sysfs programmatically?
A: 
- `libudev`: C library for device enumeration and monitoring
- `systool` (sysfsutils): CLI browser for sysfs
- `udevadm info`: Query device info and walk sysfs
- Python `pyudev`: Python bindings for libudev
- Direct reads: Standard file I/O works fine
[Basic]

---

## Section 8: COMPLETE ✓

---

## Summary

This flashcard set covers:
- **Section 1**: ProcFS Fundamentals (40 cards)
- **Section 2**: ProcFS Directory Structure (30 cards)
- **Section 3**: ProcFS Implementation Internals (30 cards)
- **Section 4**: SysFS Fundamentals (50 cards)
- **Section 5**: SysFS Directory Structure (20 cards)
- **Section 6**: SysFS Implementation Internals (30 cards)
- **Section 7**: Kernel APIs and Code Patterns (25 cards)
- **Section 8**: Advanced Topics and Comparisons (19 cards)

**Total: ~244 cards**

---

