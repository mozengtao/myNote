# Device Driver Framework Flashcards - Linux Kernel v3.2

> Anki-style flashcards for learning the Linux Device Driver Framework
> Difficulty levels: [Basic], [Intermediate], [Advanced]

---

## Section 1: Kernel Module Fundamentals

Q: What is a Linux kernel module?
A: A kernel module is a piece of code that can be loaded into and unloaded from the kernel at runtime without rebooting. It extends kernel functionality dynamically (e.g., device drivers, filesystems, network protocols).
[Basic]

Q: What are the two essential functions every kernel module must define?
A: 1) An initialization function (called when module loads)
2) A cleanup function (called when module unloads)
These are registered using `module_init()` and `module_exit()` macros.
[Basic]

Q: What is the signature of a module initialization function?
A: `static int __init my_init(void)`
- Returns 0 on success, negative error code on failure
- `__init` marks function to be freed after initialization
- `static` limits scope to the module
[Basic]

Q: What is the signature of a module cleanup function?
A: `static void __exit my_exit(void)`
- Returns nothing (void)
- `__exit` marks function as exit-only (discarded if built-in)
- `static` limits scope to the module
[Basic]

Q: (Cloze) The macro _____ registers the initialization function, and _____ registers the cleanup function.
A: `module_init(func)` registers the initialization function
`module_exit(func)` registers the cleanup function
[Basic]

Q: What does the `__init` macro do?
A: `__init` is a hint to the kernel that the function is only used during initialization. The kernel places it in a special memory section (`.init.text`) that is freed after boot/module load to reclaim memory.
[Intermediate]

Q: What does the `__exit` macro do?
A: `__exit` marks a function as only needed during module unload. If the module is compiled built-in (not loadable), the `__exit` function is discarded entirely since built-in code cannot be unloaded.
[Intermediate]

Q: What is the purpose of `MODULE_LICENSE()` macro?
A: `MODULE_LICENSE("GPL")` declares the license of the module. The kernel uses this to:
1) Determine if the module can use GPL-only symbols
2) Mark the kernel as "tainted" if non-GPL modules load
3) Provide legal clarity for distribution
[Basic]

Q: What happens if a module without `MODULE_LICENSE()` is loaded?
A: The kernel marks itself as "tainted" (flag 'P' for proprietary). This warning appears in logs and oops reports. The module cannot access GPL-only exported symbols (`EXPORT_SYMBOL_GPL`).
[Intermediate]

Q: List common MODULE_* informational macros.
A: - `MODULE_LICENSE("GPL")` - license declaration
- `MODULE_AUTHOR("Name")` - author information
- `MODULE_DESCRIPTION("text")` - module description
- `MODULE_VERSION("1.0")` - version string
- `MODULE_ALIAS("alias")` - alternative names for auto-loading
[Basic]

Q: What is `EXPORT_SYMBOL()` used for?
A: `EXPORT_SYMBOL(symbol_name)` makes a function or variable available to other kernel modules. Without export, symbols have module-local scope only. Exported symbols appear in `/proc/kallsyms`.
[Basic]

Q: What is the difference between `EXPORT_SYMBOL()` and `EXPORT_SYMBOL_GPL()`?
A: - `EXPORT_SYMBOL()` - symbol available to ALL modules regardless of license
- `EXPORT_SYMBOL_GPL()` - symbol ONLY available to GPL-compatible modules
GPL-only symbols enforce that derived works must also be GPL.
[Intermediate]

Q: How do you define a module parameter that can be set at load time?
A: Use `module_param(name, type, perm)`:
```c
static int debug = 0;
module_param(debug, int, 0644);
MODULE_PARM_DESC(debug, "Enable debug mode");
```
Load with: `insmod mymod.ko debug=1`
[Basic]

Q: What are valid types for `module_param()`?
A: - `bool` - boolean (true/false, 1/0)
- `int` - integer
- `uint` - unsigned integer
- `long` / `ulong` - long integers
- `charp` - character pointer (string)
- `short` / `ushort` - short integers
[Intermediate]

Q: What does the permission argument in `module_param()` control?
A: The permission (e.g., `0644`) controls the visibility of the parameter in sysfs at `/sys/module/<modname>/parameters/<param>`:
- `0` - not visible in sysfs
- `0444` - read-only
- `0644` - read-write (allows runtime modification)
[Intermediate]

Q: What is the difference between `insmod` and `modprobe`?
A: - `insmod` - loads a single module file; does NOT resolve dependencies; requires full path
- `modprobe` - loads module by name; automatically resolves and loads dependencies; searches standard module paths; uses `/lib/modules/$(uname -r)/`
[Basic]

Q: How does `modprobe` know about module dependencies?
A: `modprobe` reads `modules.dep` file generated by `depmod`. This file maps module names to their dependencies. Run `depmod -a` to regenerate after installing new modules.
[Intermediate]

Q: What command unloads a kernel module?
A: `rmmod module_name` or `modprobe -r module_name`
- `rmmod` - simple removal, fails if module is in use
- `modprobe -r` - also removes unused dependencies
Module must have usage count of 0 to unload.
[Basic]

Q: How can you check if a module is currently loaded?
A: - `lsmod` - lists all loaded modules with size and use count
- `cat /proc/modules` - raw module list
- `modinfo <module>` - detailed info about a module file
[Basic]

Q: What is module reference counting?
A: The kernel tracks how many users/references a module has. A module can only be unloaded when its reference count reaches zero. Use `try_module_get()` to increment and `module_put()` to decrement.
[Intermediate]

Q: (Code Interpretation) What does this minimal module do?
```c
#include <linux/module.h>
#include <linux/init.h>

static int __init hello_init(void) {
    printk(KERN_INFO "Hello\n");
    return 0;
}
static void __exit hello_exit(void) {
    printk(KERN_INFO "Goodbye\n");
}
module_init(hello_init);
module_exit(hello_exit);
MODULE_LICENSE("GPL");
```
A: This is a minimal "Hello World" module that:
1) Prints "Hello" to kernel log when loaded
2) Prints "Goodbye" when unloaded
3) Declares GPL license
The `__init`/`__exit` markers optimize memory usage.
[Basic]

Q: Where are kernel modules typically installed on a system?
A: `/lib/modules/$(uname -r)/`
Subdirectories include:
- `kernel/` - modules from kernel source
- `extra/` - third-party modules
- `updates/` - updated versions of in-tree modules
[Basic]

Q: What file extension do compiled kernel modules have?
A: `.ko` (kernel object). This replaced the older `.o` extension. The `.ko` file contains ELF object code plus module metadata sections (license, parameters, dependencies, etc.).
[Basic]

---

## Section 2: Kobject Infrastructure

Q: What is a kobject in the Linux kernel?
A: A `kobject` is the fundamental building block of the Linux device model. It provides:
1) Reference counting for object lifetime management
2) Sysfs representation (directory in `/sys`)
3) Hotplug event generation
4) Hierarchical parent-child relationships
Defined in `<linux/kobject.h>`.
[Basic]

Q: What are the key fields in `struct kobject`?
A: ```c
struct kobject {
    const char      *name;      /* sysfs directory name */
    struct list_head entry;     /* links into kset */
    struct kobject  *parent;    /* parent kobject */
    struct kset     *kset;      /* containing kset */
    struct kobj_type *ktype;    /* type descriptor */
    struct sysfs_dirent *sd;    /* sysfs representation */
    struct kref     kref;       /* reference count */
    /* ... */
};
```
[Intermediate]

Q: What is the purpose of `struct kref` inside kobject?
A: `kref` is the reference counting mechanism. It's a simple structure containing an `atomic_t` counter. When the count drops to zero, the object's release function is called. This ensures safe memory management in concurrent environments.
[Intermediate]

Q: How do you initialize a kobject?
A: Use `kobject_init(kobj, ktype)`:
```c
struct kobject *kobj;
kobj = kzalloc(sizeof(*kobj), GFP_KERNEL);
kobject_init(kobj, &my_ktype);
```
This sets refcount to 1 and associates the ktype. Never use an uninitialized kobject.
[Basic]

Q: What is the difference between `kobject_init()` and `kobject_init_and_add()`?
A: - `kobject_init(kobj, ktype)` - only initializes the kobject
- `kobject_init_and_add(kobj, ktype, parent, fmt, ...)` - initializes AND adds to sysfs hierarchy with a name
The latter is a convenience combining `kobject_init()` + `kobject_add()`.
[Intermediate]

Q: What does `kobject_add()` do?
A: `kobject_add(kobj, parent, fmt, ...)` registers the kobject in sysfs:
1) Sets the kobject name (printf-style formatting)
2) Establishes parent relationship (or uses kset's parent)
3) Creates sysfs directory
Returns 0 on success, negative error on failure.
[Intermediate]

Q: What is the kobject lifecycle sequence?
A: 1) `kobject_init()` - initialize, refcount = 1
2) `kobject_add()` - add to hierarchy, create sysfs entry
3) Use the object (refcount managed by get/put)
4) `kobject_del()` - remove from sysfs
5) `kobject_put()` - decrement refcount, triggers release when 0
[Intermediate]

Q: What do `kobject_get()` and `kobject_put()` do?
A: - `kobject_get(kobj)` - increments reference count, returns kobj (or NULL if kobj is NULL)
- `kobject_put(kobj)` - decrements reference count; if count reaches 0, calls ktype->release()
These ensure the kobject isn't freed while in use.
[Basic]

Q: (Cloze) When a kobject's reference count reaches _____, the _____ function is called to free resources.
A: When a kobject's reference count reaches **zero**, the **ktype->release()** function is called to free resources.
[Basic]

Q: What is `struct kobj_type` (ktype)?
A: `kobj_type` defines the behavior of a kobject class:
```c
struct kobj_type {
    void (*release)(struct kobject *kobj);  /* destructor */
    const struct sysfs_ops *sysfs_ops;      /* sysfs read/write */
    struct attribute **default_attrs;        /* default attributes */
};
```
Every kobject must have an associated ktype.
[Intermediate]

Q: Why is the `release` function in ktype mandatory?
A: The `release` function is the destructor that frees memory when refcount hits zero. Without it:
1) Memory would leak
2) The kernel will WARN if release is NULL
It's called from `kobject_put()` when the last reference is dropped.
[Intermediate]

Q: What is a `kset`?
A: A `kset` is a collection of kobjects of the same type. It provides:
1) A container/grouping mechanism
2) A sysfs directory containing member kobjects
3) Hotplug event filtering
4) A common parent for member kobjects
Defined as `struct kset` with an embedded kobject.
[Intermediate]

Q: What are the key fields in `struct kset`?
A: ```c
struct kset {
    struct list_head list;           /* list of kobjects */
    spinlock_t list_lock;            /* protects list */
    struct kobject kobj;             /* embedded kobject */
    const struct kset_uevent_ops *uevent_ops; /* hotplug filter */
};
```
The embedded kobject represents the kset in sysfs.
[Intermediate]

Q: How do you create and register a kset?
A: Use `kset_create_and_add()`:
```c
struct kset *my_kset;
my_kset = kset_create_and_add("my_kset", NULL, kernel_kobj);
```
Parameters: name, uevent_ops (optional), parent kobject
Returns kset pointer or NULL on failure.
[Intermediate]

Q: How do you add a kobject to a kset?
A: Set `kobj->kset` before calling `kobject_add()`:
```c
kobj->kset = my_kset;
kobject_add(kobj, NULL, "myobj");  /* parent from kset */
```
If parent is NULL, the kobject becomes a child of the kset's kobject.
[Intermediate]

Q: What is the relationship between kset and kobject?
A: - A kset CONTAINS a kobject (embedded, not pointer)
- A kset HOLDS a list of member kobjects
- Member kobjects point TO their containing kset
- The kset's embedded kobject appears as a sysfs directory containing members
[Intermediate]

Q: (ASCII Diagram) Show the kobject/kset hierarchy structure.
A: ```
struct kset (my_kset)
├── embedded kobject ──► /sys/.../my_kset/
│   └── list of member kobjects
│       ├── kobject A ──► /sys/.../my_kset/objA/
│       ├── kobject B ──► /sys/.../my_kset/objB/
│       └── kobject C ──► /sys/.../my_kset/objC/
```
The kset provides grouping; each kobject becomes a subdirectory.
[Intermediate]

Q: What is `struct kref` and how is it used independently?
A: `kref` is a standalone reference counter:
```c
struct kref {
    atomic_t refcount;
};
```
APIs: `kref_init()`, `kref_get()`, `kref_put(kref, release_fn)`
Used when you need refcounting without full kobject machinery.
[Intermediate]

Q: How does `kref_put()` work?
A: ```c
int kref_put(struct kref *kref, 
             void (*release)(struct kref *kref));
```
1) Atomically decrements refcount
2) If count becomes 0, calls release function
3) Returns 1 if release was called, 0 otherwise
The release function must free the containing structure.
[Intermediate]

Q: (Code Interpretation) What pattern does this show?
```c
struct my_obj {
    struct kref refcount;
    /* ... data ... */
};

void my_release(struct kref *ref) {
    struct my_obj *obj = container_of(ref, struct my_obj, refcount);
    kfree(obj);
}
```
A: This shows the standard kref release pattern:
1) Embed kref in your structure
2) Define release function that uses `container_of()` to get parent struct
3) Free the containing object
Called automatically when kref_put() drops count to 0.
[Intermediate]

Q: What is `container_of()` macro?
A: `container_of(ptr, type, member)` returns a pointer to the containing structure given a pointer to a member:
```c
struct kobject *kp;
struct device *dev = container_of(kp, struct device, kobj);
```
Essential for working with embedded kobjects and krefs.
[Basic]

Q: What happens if you call `kobject_put()` on an already-freed kobject?
A: Undefined behavior - typically a kernel crash or memory corruption. This is a use-after-free bug. Always ensure proper reference counting: only call `kobject_put()` if you own a reference, and never access the object after putting your last reference.
[Advanced]

Q: What is `kobject_del()` and when should it be called?
A: `kobject_del(kobj)` removes the kobject from sysfs hierarchy:
1) Removes sysfs directory entry
2) Unlinks from parent
3) Does NOT free memory or drop refcount
Call it when you want to hide the object from sysfs but not yet free it.
[Intermediate]

Q: What is the difference between `kobject_del()` and `kobject_put()`?
A: - `kobject_del()` - removes from sysfs, maintains refcount
- `kobject_put()` - decrements refcount, potentially frees object
Typical cleanup: `kobject_del()` then `kobject_put()`. Or use `kobject_put()` alone if you want sysfs removal on final put.
[Intermediate]

Q: What kernel source files implement the kobject subsystem?
A: - `lib/kobject.c` - core kobject implementation
- `include/linux/kobject.h` - public API and structures
- `lib/kref.c` - kref implementation
- `fs/sysfs/` - sysfs filesystem integration
[Intermediate]

---

## Section 3: Sysfs Interface

Q: What is sysfs?
A: Sysfs is a virtual filesystem (typically mounted at `/sys`) that exports kernel objects, their attributes, and relationships to userspace. It provides a unified interface to view and configure kernel subsystems, devices, and drivers.
[Basic]

Q: How is sysfs mounted and what is its typical mount point?
A: Sysfs is mounted at `/sys`:
```bash
mount -t sysfs sysfs /sys
```
Usually mounted automatically at boot by init scripts or systemd. Type is `sysfs`, and it requires no backing block device.
[Basic]

Q: What is the relationship between kobjects and sysfs?
A: Each kobject in the kernel corresponds to a directory in sysfs:
- `kobject_add()` creates a sysfs directory
- `kobject_del()` removes it
- Kobject hierarchy mirrors sysfs directory hierarchy
- Kobject name becomes directory name
[Basic]

Q: What are the main top-level directories in `/sys`?
A: - `/sys/devices/` - all devices in hierarchy (physical layout)
- `/sys/bus/` - bus types with device/driver symlinks
- `/sys/class/` - devices grouped by function
- `/sys/block/` - block devices
- `/sys/kernel/` - kernel subsystem parameters
- `/sys/module/` - loaded module info and parameters
- `/sys/firmware/` - firmware interfaces
[Basic]

Q: What is a sysfs attribute?
A: A sysfs attribute is a file within a kobject's directory that exposes a single kernel value. Reading the file calls a `show` function; writing calls a `store` function. Attributes are the primary way userspace interacts with kernel objects.
[Basic]

Q: What is `struct attribute`?
A: ```c
struct attribute {
    const char *name;    /* filename in sysfs */
    mode_t mode;         /* file permissions */
};
```
Defines metadata for a sysfs file. Doesn't contain show/store - those come from `sysfs_ops` in the ktype.
[Intermediate]

Q: What is `struct sysfs_ops`?
A: ```c
struct sysfs_ops {
    ssize_t (*show)(struct kobject *kobj,
                    struct attribute *attr, char *buf);
    ssize_t (*store)(struct kobject *kobj,
                     struct attribute *attr,
                     const char *buf, size_t count);
};
```
Provides the read/write callbacks for all attributes of a ktype.
[Intermediate]

Q: What is the signature and contract of a sysfs `show` function?
A: ```c
ssize_t show(struct kobject *kobj, struct attribute *attr, char *buf);
```
- Write formatted data to `buf` (PAGE_SIZE max)
- Return number of bytes written
- Use `sprintf()` or `scnprintf()`
- Must not exceed PAGE_SIZE (typically 4096 bytes)
[Intermediate]

Q: What is the signature and contract of a sysfs `store` function?
A: ```c
ssize_t store(struct kobject *kobj, struct attribute *attr, 
              const char *buf, size_t count);
```
- Parse data from `buf` (user input)
- `count` is the number of bytes written by user
- Return bytes consumed (usually `count`) or negative error
- Validate input carefully
[Intermediate]

Q: How do you create a sysfs file for an attribute?
A: Use `sysfs_create_file()`:
```c
struct attribute my_attr = {
    .name = "my_value",
    .mode = 0644,
};
sysfs_create_file(&kobj, &my_attr);
```
Or use default_attrs in ktype for automatic creation.
[Intermediate]

Q: How do you remove a sysfs attribute file?
A: Use `sysfs_remove_file()`:
```c
sysfs_remove_file(&kobj, &my_attr);
```
Call during cleanup, typically before `kobject_del()`.
[Intermediate]

Q: What is `struct attribute_group`?
A: ```c
struct attribute_group {
    const char *name;           /* optional subdirectory */
    struct attribute **attrs;   /* NULL-terminated array */
};
```
Groups multiple attributes together. If `name` is set, creates a subdirectory. Simplifies bulk creation/removal.
[Intermediate]

Q: How do you use attribute groups?
A: ```c
static struct attribute *my_attrs[] = {
    &attr1.attr,
    &attr2.attr,
    NULL,
};
static struct attribute_group my_group = {
    .attrs = my_attrs,
};
sysfs_create_group(&kobj, &my_group);
sysfs_remove_group(&kobj, &my_group);
```
[Intermediate]

Q: What is `struct device_attribute` and `DEVICE_ATTR` macro?
A: `device_attribute` wraps attribute with device-specific show/store:
```c
struct device_attribute {
    struct attribute attr;
    ssize_t (*show)(struct device *dev, 
                    struct device_attribute *attr, char *buf);
    ssize_t (*store)(struct device *dev,
                     struct device_attribute *attr,
                     const char *buf, size_t count);
};
DEVICE_ATTR(name, mode, show_func, store_func);
```
[Intermediate]

Q: (Code Interpretation) What does this create?
```c
static ssize_t foo_show(struct device *dev, 
                        struct device_attribute *attr, char *buf) {
    return sprintf(buf, "%d\n", some_value);
}
static DEVICE_ATTR_RO(foo);
```
A: Creates a read-only device attribute named "foo":
- `DEVICE_ATTR_RO(foo)` expands to `DEVICE_ATTR(foo, 0444, foo_show, NULL)`
- Creates `/sys/.../device_dir/foo`
- Reading returns `some_value` as text
- Writing not permitted (mode 0444)
[Intermediate]

Q: What are the `DEVICE_ATTR_*` convenience macros?
A: - `DEVICE_ATTR(name, mode, show, store)` - full control
- `DEVICE_ATTR_RW(name)` - read-write (0644), expects name_show/name_store
- `DEVICE_ATTR_RO(name)` - read-only (0444), expects name_show
- `DEVICE_ATTR_WO(name)` - write-only (0200), expects name_store
[Intermediate]

Q: What is a binary attribute (`struct bin_attribute`)?
A: Binary attributes allow arbitrary binary data (not just text):
```c
struct bin_attribute {
    struct attribute attr;
    size_t size;           /* file size */
    ssize_t (*read)(struct file *, struct kobject *,
                    struct bin_attribute *, char *, loff_t, size_t);
    ssize_t (*write)(...);
    int (*mmap)(...);
};
```
Used for firmware loading, EEPROM access, etc.
[Advanced]

Q: How do binary attributes differ from regular attributes?
A: | Regular Attribute | Binary Attribute |
|---|---|
| Text-based | Arbitrary binary data |
| PAGE_SIZE max | Can be larger (size field) |
| Simple show/store | read/write with offset |
| No mmap support | Optional mmap support |
| sprintf/sscanf | memcpy-style operations |
[Intermediate]

Q: What is the difference between sysfs and procfs?
A: | sysfs | procfs |
|---|---|
| `/sys` | `/proc` |
| Device model info | Process info (primarily) |
| One value per file | Multi-value files OK |
| Structured hierarchy | Flatter structure |
| Kobject-based | seq_file or custom |
| Preferred for devices | Legacy device files moved out |
[Intermediate]

Q: (Misconception) Can you use `printf()` in sysfs show functions?
A: NO. `printf()` outputs to console, not to the buffer. Use `sprintf()`, `snprintf()`, or `scnprintf()`:
```c
/* Wrong */
printf("%d\n", val);
/* Correct */
return sprintf(buf, "%d\n", val);
```
The show function must write to `buf` and return byte count.
[Basic]

Q: What happens if a sysfs show function writes more than PAGE_SIZE?
A: Buffer overflow and kernel memory corruption. Always use `scnprintf()` with PAGE_SIZE limit:
```c
return scnprintf(buf, PAGE_SIZE, "%s\n", long_string);
```
The PAGE_SIZE limit is typically 4096 bytes.
[Intermediate]

Q: How do you create a symbolic link in sysfs?
A: Use `sysfs_create_link()`:
```c
sysfs_create_link(&kobj, &target_kobj, "link_name");
sysfs_remove_link(&kobj, "link_name");
```
Creates a symlink from kobj's directory pointing to target. Used extensively in `/sys/bus/*/devices/`.
[Intermediate]

Q: What kernel source files implement sysfs?
A: - `fs/sysfs/` - sysfs filesystem implementation
  - `dir.c` - directory operations
  - `file.c` - file operations
  - `symlink.c` - symbolic links
  - `mount.c` - filesystem mount
- `include/linux/sysfs.h` - public API
[Intermediate]

---

## Section 4: Unified Device Model - Core Architecture ⭐

Q: What is the Linux Unified Device Model?
A: The Unified Device Model is a kernel infrastructure that represents all buses, devices, and drivers in a consistent hierarchical structure. Introduced in 2.6, it provides:
1) Consistent device lifecycle management
2) Power management coordination
3) Sysfs representation
4) Hotplug support
[Basic]

Q: What were the problems before the Unified Device Model?
A: Before 2.6:
1) Each bus type had its own device/driver structures
2) No unified power management
3) No consistent userspace interface
4) Difficult to track device dependencies
5) No standard hotplug mechanism
The UDM solved these with abstraction layers.
[Intermediate]

Q: What are the three core abstractions in the Unified Device Model?
A: 1) **Bus** (`struct bus_type`) - communication channel (PCI, USB, platform)
2) **Device** (`struct device`) - physical or virtual entity connected to a bus
3) **Driver** (`struct device_driver`) - software that controls a device
These form a triangle: buses contain devices, drivers bind to devices on buses.
[Basic]

Q: (ASCII Diagram) Show the relationship between bus, device, and driver.
A: ```
         struct bus_type
              /    \
             /      \
    device_list    driver_list
        |              |
        v              v
  +----------+    +-----------+
  | device 1 |<-->| driver A  |  (binding)
  | device 2 |<-->| driver B  |
  | device 3 |    |           |
  +----------+    +-----------+
```
Bus maintains lists; binding connects device↔driver.
[Intermediate]

Q: What is `struct bus_type` and its purpose?
A: `struct bus_type` represents a bus subsystem (PCI, USB, I2C, etc.):
```c
struct bus_type {
    const char *name;                    /* "pci", "usb" */
    struct bus_attribute *bus_attrs;
    struct device_attribute *dev_attrs;
    struct driver_attribute *drv_attrs;
    int (*match)(struct device *, struct device_driver *);
    int (*probe)(struct device *);
    int (*remove)(struct device *);
    /* ... PM callbacks, uevent, etc. */
};
```
[Intermediate]

Q: What are the key fields in `struct bus_type`?
A: - `name` - bus name shown in sysfs
- `match` - determines if driver can handle device
- `probe` - called when binding device to driver
- `remove` - called when unbinding
- `uevent` - adds environment vars for hotplug
- `dev_attrs` - default attributes for devices
- `drv_attrs` - default attributes for drivers
- `pm` - power management operations
[Intermediate]

Q: How do you register a new bus type?
A: Use `bus_register()`:
```c
static struct bus_type my_bus_type = {
    .name = "mybus",
    .match = my_match,
};

int __init my_bus_init(void) {
    return bus_register(&my_bus_type);
}
void __exit my_bus_exit(void) {
    bus_unregister(&my_bus_type);
}
```
[Intermediate]

Q: What happens when `bus_register()` is called?
A: 1) Allocates internal bus structures
2) Creates `/sys/bus/<name>/` directory
3) Creates `/sys/bus/<name>/devices/` subdirectory
4) Creates `/sys/bus/<name>/drivers/` subdirectory
5) Initializes device and driver lists
6) Creates bus attributes in sysfs
[Intermediate]

Q: What is `struct device` and what does it represent?
A: `struct device` is the universal base structure for ALL devices in the kernel. It represents anything that can be bound to a driver: physical hardware, virtual devices, or bus controllers. Every specific device type embeds this structure.
[Basic]

Q: What are the key fields in `struct device`?
A: ```c
struct device {
    struct device *parent;           /* parent device */
    struct kobject kobj;             /* sysfs representation */
    const char *init_name;           /* initial name */
    struct bus_type *bus;            /* bus this device is on */
    struct device_driver *driver;    /* bound driver */
    void *platform_data;             /* platform-specific data */
    struct dev_pm_info power;        /* power management */
    u64 *dma_mask;                   /* DMA mask */
    struct device_node *of_node;     /* device tree node */
    /* ... */
};
```
[Intermediate]

Q: Why does `struct device` embed a kobject?
A: The embedded kobject provides:
1) Reference counting for device lifetime
2) Sysfs directory for the device
3) Parent-child hierarchy in `/sys/devices/`
4) Uevent support for hotplug
Every device IS-A kobject via embedding.
[Intermediate]

Q: What is `struct device_driver` and its purpose?
A: `struct device_driver` represents code that controls devices:
```c
struct device_driver {
    const char *name;                /* driver name */
    struct bus_type *bus;            /* bus this driver is for */
    struct module *owner;            /* owning module */
    int (*probe)(struct device *);   /* bind to device */
    int (*remove)(struct device *);  /* unbind from device */
    void (*shutdown)(struct device *);
    const struct dev_pm_ops *pm;     /* power management */
    /* ... */
};
```
[Intermediate]

Q: What is the relationship between bus's probe and driver's probe?
A: The bus may have a `probe` callback that wraps the driver's probe:
1) Bus `match()` identifies compatible device+driver
2) Core calls bus `probe()` if defined, OR driver `probe()` directly
3) Bus probe can do bus-specific setup then call driver probe
This allows bus-level initialization before driver code runs.
[Advanced]

Q: How do you register a device with the device model?
A: Use `device_register()`:
```c
struct device *dev;
dev = kzalloc(sizeof(*dev), GFP_KERNEL);
dev->bus = &my_bus_type;
dev->parent = parent_dev;
dev_set_name(dev, "mydev%d", id);
device_register(dev);
```
Or use `device_initialize()` + `device_add()` separately.
[Intermediate]

Q: What is the difference between `device_register()` and `device_add()`?
A: `device_register(dev)` = `device_initialize(dev)` + `device_add(dev)`
- `device_initialize()` - initialize device struct, kobject, PM
- `device_add()` - add to bus, create sysfs, trigger probe
Use separately when you need initialization before adding.
[Intermediate]

Q: What happens during `device_add()`?
A: 1) Validate device state
2) Set up device name if not set
3) Add kobject to sysfs hierarchy
4) Create device symlinks on bus
5) Call `bus_probe_device()` to find and bind driver
6) Generate ADD uevent
7) Create default attributes
[Intermediate]

Q: How do you unregister a device?
A: Use `device_unregister()` or `device_del()` + `put_device()`:
```c
/* Option 1: combined */
device_unregister(dev);

/* Option 2: separate */
device_del(dev);      /* remove from sysfs, unbind driver */
put_device(dev);      /* drop reference, may free */
```
[Intermediate]

Q: How do you register a driver?
A: Use `driver_register()`:
```c
static struct device_driver my_driver = {
    .name = "mydriver",
    .bus = &my_bus_type,
    .probe = my_probe,
    .remove = my_remove,
};
driver_register(&my_driver);
/* cleanup: driver_unregister(&my_driver); */
```
[Intermediate]

Q: What happens during `driver_register()`?
A: 1) Add driver to bus's driver list
2) Create `/sys/bus/<bus>/drivers/<name>/` directory
3) Iterate all devices on bus
4) For each device without a driver, try `match()`
5) If match succeeds, attempt probe
6) Create driver attributes in sysfs
[Intermediate]

Q: What is `struct device_type`?
A: `struct device_type` adds type-specific behavior to devices:
```c
struct device_type {
    const char *name;                    /* shown in uevent */
    struct attribute_group **groups;     /* type attributes */
    int (*uevent)(struct device *, struct kobj_uevent_env *);
    void (*release)(struct device *);    /* destructor */
    const struct dev_pm_ops *pm;
};
```
Set via `dev->type`. Allows different behaviors within same bus.
[Advanced]

Q: What is the purpose of `dev_set_name()` and `dev_name()`?
A: - `dev_set_name(dev, fmt, ...)` - sets device name (printf-style)
- `dev_name(dev)` - returns current device name
The name appears in sysfs and is used for driver matching and logging.
```c
dev_set_name(dev, "mydev%d", index);
printk("Device: %s\n", dev_name(dev));
```
[Basic]

Q: How does a subsystem typically define its device structure?
A: Embed `struct device` and add subsystem-specific fields:
```c
struct pci_dev {
    struct device dev;           /* embedded base device */
    struct pci_bus *bus;         /* PCI-specific */
    unsigned int devfn;
    unsigned short vendor;
    unsigned short device;
    /* ... many more PCI fields ... */
};
```
Use `to_pci_dev()` macro to cast from device to pci_dev.
[Intermediate]

Q: What is the `to_*` macro pattern in device model?
A: `to_*` macros convert from base type to derived type:
```c
#define to_pci_dev(d) container_of(d, struct pci_dev, dev)
#define to_usb_device(d) container_of(d, struct usb_device, dev)
```
Used because C has no inheritance; embedding simulates it.
[Intermediate]

Q: (Reverse) Given a `struct device *dev`, how do you get the containing PCI device?
A: Use the `to_pci_dev()` macro:
```c
struct pci_dev *pdev = to_pci_dev(dev);
```
This uses `container_of()` to find the pci_dev structure that embeds the device.
[Intermediate]

Q: What is `get_device()` and `put_device()`?
A: Reference counting for struct device:
- `get_device(dev)` - increment refcount, returns dev
- `put_device(dev)` - decrement refcount, may trigger release
Internally operate on the embedded kobject's kref.
```c
struct device *ref = get_device(dev);
/* use ref */
put_device(ref);
```
[Basic]

Q: What function frees a device structure?
A: The `release` callback in device_type or bus_type:
```c
void my_device_release(struct device *dev) {
    struct my_device *mydev = to_my_device(dev);
    kfree(mydev);
}
dev->release = my_device_release;
/* or set via dev->type->release */
```
Called when last reference is dropped via `put_device()`.
[Intermediate]

Q: What are the key source files for the device model core?
A: - `drivers/base/core.c` - struct device operations
- `drivers/base/bus.c` - struct bus_type operations
- `drivers/base/driver.c` - struct device_driver operations
- `drivers/base/dd.c` - device-driver binding
- `include/linux/device.h` - public API
[Intermediate]

Q: (Cloze) A device's sysfs directory is created during _____ and removed during _____.
A: A device's sysfs directory is created during **device_add()** and removed during **device_del()**.
[Basic]

Q: What is the role of `owner` field in device_driver?
A: `owner` points to the module containing the driver (typically `THIS_MODULE`):
```c
.owner = THIS_MODULE,
```
Used for module reference counting - prevents module unload while driver is bound to devices. The core calls `try_module_get(drv->owner)` during probe.
[Intermediate]

Q: How does the device model handle initialization ordering?
A: Registration order matters:
1) Register bus_type first (provides infrastructure)
2) Register devices (appear on bus)
3) Register drivers (probe existing devices)
Or: Register drivers first, they probe when matching devices appear. The model handles both cases.
[Intermediate]

Q: What is a "bus controller" vs a "bus device"?
A: - **Bus controller** - hardware that implements the bus (e.g., PCI host bridge, USB host controller). It's a device on a parent bus.
- **Bus device** - device attached TO that bus (e.g., PCI card, USB stick)
Controllers create child buses; devices attach to them.
[Intermediate]

Q: (ASCII Diagram) Show how bus controllers nest in device hierarchy.
A: ```
Platform Bus
    |
    +-- pci0000:00 (PCI Host Bridge - device on platform)
            |
            +-- PCI Bus 0
                    |
                    +-- 0000:00:1d.0 (USB Controller - device on PCI)
                            |
                            +-- USB Bus
                                    |
                                    +-- usb1/1-1 (USB device)
```
[Intermediate]

Q: What helper functions iterate over buses, devices, and drivers?
A: - `bus_for_each_dev(bus, start, data, fn)` - iterate devices
- `bus_for_each_drv(bus, start, data, fn)` - iterate drivers
- `driver_for_each_device(drv, start, data, fn)` - iterate driver's devices
- `device_for_each_child(dev, data, fn)` - iterate children
[Intermediate]

Q: What is `bus_find_device()` used for?
A: Finds a device on a bus matching a predicate:
```c
struct device *bus_find_device(struct bus_type *bus,
                               struct device *start,
                               void *data,
                               int (*match)(struct device *, void *));
```
Returns device with incremented refcount, or NULL.
[Intermediate]

---

## Section 5: Unified Device Model - Binding Mechanism ⭐

Q: What is device-driver binding?
A: Binding is the process of associating a device with a driver that can control it. When bound:
1) `dev->driver` points to the driver
2) Driver's probe function is called
3) Device appears in `/sys/bus/<bus>/drivers/<drv>/`
4) Driver can operate the hardware
[Basic]

Q: What triggers the binding process?
A: Binding is triggered by:
1) `device_add()` - new device searches for matching driver
2) `driver_register()` - new driver searches for unbound devices
3) Manual bind via sysfs - write device name to driver's `bind` file
The core proactively matches when either side is registered.
[Basic]

Q: What is the role of the bus `match()` function?
A: The `match()` callback determines if a driver can handle a device:
```c
int (*match)(struct device *dev, struct device_driver *drv);
```
- Returns non-zero (true) if driver can handle device
- Returns 0 if no match
Called for every device-driver pair to find compatible combinations.
[Intermediate]

Q: How do different buses implement match()?
A: Each bus has its own matching strategy:
- **PCI**: Compare vendor/device IDs from driver's pci_device_id table
- **USB**: Compare vendor/product IDs from usb_device_id table
- **Platform**: Compare device name with driver name or of_device_id
- **I2C**: Compare device name or i2c_device_id table
[Intermediate]

Q: (Code Interpretation) What does this match function do?
```c
static int my_bus_match(struct device *dev, 
                        struct device_driver *drv) {
    return !strcmp(dev_name(dev), drv->name);
}
```
A: This is the simplest match strategy: compare device name with driver name. If they're equal (strcmp returns 0), the driver matches. This is similar to how the platform bus matches when no ID tables are used.
[Intermediate]

Q: What is the complete call path when a device is added?
A: ```
device_add()
  └─► bus_probe_device()
        └─► device_attach()
              └─► bus_for_each_drv(..., __device_attach)
                    └─► __device_attach()
                          ├─► driver_match_device() → bus->match()
                          └─► driver_probe_device()
                                └─► really_probe()
                                      └─► drv->probe() or bus->probe()
```
[Advanced]

Q: What is the complete call path when a driver is registered?
A: ```
driver_register()
  └─► bus_add_driver()
        └─► driver_attach()
              └─► bus_for_each_dev(..., __driver_attach)
                    └─► __driver_attach()
                          ├─► driver_match_device() → bus->match()
                          └─► driver_probe_device()
                                └─► really_probe()
                                      └─► drv->probe() or bus->probe()
```
[Advanced]

Q: What does `really_probe()` do?
A: `really_probe()` in `drivers/base/dd.c` performs actual binding:
1) Increment driver module refcount
2) Set `dev->driver = drv`
3) Call `bus->probe()` if defined, else `drv->probe()`
4) If probe fails, clear `dev->driver`, decrement refcount
5) Add device to driver's device list
6) Create driver symlink in device's sysfs
[Advanced]

Q: What is the probe function's responsibility?
A: The probe function initializes the device:
1) Verify device is actually present/functional
2) Allocate driver-specific resources
3) Map I/O memory, request IRQs
4) Initialize hardware
5) Register with subsystem (e.g., create netdev, cdev)
6) Return 0 on success, negative error on failure
[Intermediate]

Q: What happens if probe() returns an error?
A: If probe returns negative:
1) `dev->driver` is set back to NULL
2) Module refcount is decremented
3) Device remains unbound
4) Error code may be logged
5) Device can try binding to other drivers
6) Driver continues probing other devices
[Intermediate]

Q: What is deferred probing (`-EPROBE_DEFER`)?
A: `EPROBE_DEFER` tells the core: "I can't probe yet, try again later."
```c
if (!dependency_ready)
    return -EPROBE_DEFER;
```
Used when a driver depends on another resource (clock, regulator, GPIO) not yet available. The device is added to a deferred list and re-probed later.
[Intermediate]

Q: How does deferred probing work internally?
A: 1) Probe returns `-EPROBE_DEFER`
2) Device added to `deferred_probe_pending_list`
3) When any device successfully probes, deferred devices are re-tried
4) Also retried when new drivers register
5) Async workqueue handles reprobe attempts
Prevents boot ordering dependencies from causing failures.
[Advanced]

Q: What is the `remove()` callback for?
A: `remove()` is the opposite of `probe()`:
```c
int (*remove)(struct device *dev);
```
Called when:
1) Device is unregistered
2) Driver is unregistered
3) Manual unbind via sysfs
Must free all resources allocated in probe.
[Basic]

Q: What is the correct order of cleanup in remove()?
A: Reverse order of initialization:
```c
static int my_remove(struct device *dev) {
    /* 1. Disable device operation */
    /* 2. Unregister from subsystem */
    /* 3. Free IRQs */
    /* 4. Unmap I/O memory */
    /* 5. Free allocated memory */
    return 0;
}
```
Last acquired = first released (LIFO).
[Intermediate]

Q: How do you manually bind a device to a driver via sysfs?
A: Write the device name to the driver's `bind` file:
```bash
echo "0000:00:1f.0" > /sys/bus/pci/drivers/my_driver/bind
```
This triggers `driver_probe_device()` for that specific device.
[Basic]

Q: How do you manually unbind a device from its driver via sysfs?
A: Write the device name to the driver's `unbind` file:
```bash
echo "0000:00:1f.0" > /sys/bus/pci/drivers/my_driver/unbind
```
This calls the driver's `remove()` function and clears `dev->driver`.
[Basic]

Q: What sysfs file shows what driver a device is bound to?
A: The `driver` symlink in the device's directory:
```bash
ls -l /sys/devices/.../my_device/driver
# -> ../../bus/.../drivers/my_driver
```
If no symlink exists, the device is unbound.
[Basic]

Q: What is `device_bind_driver()`?
A: Low-level function to bind device to its currently set driver:
```c
int device_bind_driver(struct device *dev);
```
Assumes `dev->driver` is already set. Used by bus-specific code that handles its own matching. Normally `driver_probe_device()` is preferred.
[Advanced]

Q: What is `device_release_driver()`?
A: Forces unbinding of a device from its driver:
```c
void device_release_driver(struct device *dev);
```
1) Calls driver's `remove()` callback
2) Removes device from driver's list
3) Clears `dev->driver`
4) Removes sysfs symlink
[Intermediate]

Q: What is an ID table and how is it used for matching?
A: ID tables list device identifiers a driver supports:
```c
static const struct pci_device_id my_ids[] = {
    { PCI_DEVICE(0x8086, 0x1234) },
    { PCI_DEVICE(0x8086, 0x5678) },
    { 0, }  /* terminator */
};
MODULE_DEVICE_TABLE(pci, my_ids);
```
Bus `match()` compares device IDs against this table.
[Intermediate]

Q: What is `MODULE_DEVICE_TABLE()` for?
A: `MODULE_DEVICE_TABLE(bus, table)` exports the ID table to userspace:
```c
MODULE_DEVICE_TABLE(pci, my_pci_ids);
```
1) Creates alias entries for module autoloading
2) Embedded in module's .modinfo section
3) `depmod` extracts IDs to modules.alias file
4) Enables automatic module loading when device appears
[Intermediate]

Q: How does automatic module loading work?
A: 1) Device appears (e.g., USB plugged in)
2) Kernel generates uevent with MODALIAS
3) udev/systemd receives event
4) Checks `/lib/modules/.../modules.alias`
5) Finds module matching MODALIAS
6) Runs `modprobe <module>`
7) Module registers driver
8) Driver binds to device
[Intermediate]

Q: What is MODALIAS?
A: MODALIAS is an environment variable in uevents that encodes device identity:
```
MODALIAS=pci:v00008086d00001234sv*sd*bc*sc*i*
MODALIAS=usb:v1234p5678d*dc*dsc*dp*ic*isc*ip*
```
Format is bus-specific. Used for module autoloading - matches against MODULE_DEVICE_TABLE entries.
[Intermediate]

Q: (Misconception) Does a driver's probe() run in the context of device_add()?
A: YES, by default probe runs synchronously in device_add() context. This can cause:
1) Long boot times if probe is slow
2) Deadlocks if probe waits for something
Async probing (`async_probe` flag) defers probe to workqueue.
[Advanced]

Q: What is async probe?
A: Async probe schedules probe() on a workqueue instead of calling synchronously:
```c
drv->probe_type = PROBE_PREFER_ASYNCHRONOUS;
```
Benefits:
1) Faster boot (probes run in parallel)
2) Avoids some deadlock scenarios
Drawback: Ordering dependencies harder to manage.
[Advanced]

Q: What lock protects the binding process?
A: `device_lock(dev)` - a mutex per device:
```c
device_lock(dev);
/* binding operations */
device_unlock(dev);
```
Ensures only one probe/remove runs at a time for a device. Prevents races between bind/unbind operations.
[Advanced]

Q: What is the driver_data field for?
A: `dev_get_drvdata()` / `dev_set_drvdata()` store driver-private data:
```c
struct my_priv *priv = kzalloc(sizeof(*priv), GFP_KERNEL);
dev_set_drvdata(dev, priv);
/* later */
struct my_priv *priv = dev_get_drvdata(dev);
```
Links driver's per-device state to the device struct.
[Intermediate]

Q: What is the typical probe function structure?
A: ```c
static int my_probe(struct device *dev) {
    struct my_priv *priv;
    int ret;
    
    priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
    if (!priv)
        return -ENOMEM;
    
    /* initialize priv, hardware */
    ret = setup_hardware(priv);
    if (ret)
        return ret;
    
    dev_set_drvdata(dev, priv);
    return 0;
}
```
[Intermediate]

Q: Why use `devm_*` functions in probe?
A: `devm_*` (device-managed) functions auto-free resources on remove or probe failure:
```c
ptr = devm_kzalloc(dev, size, GFP_KERNEL);
/* No need to kfree in remove() */
```
Simplifies error handling and prevents leaks. Resources freed in reverse allocation order.
[Intermediate]

Q: What is `device_attach()` vs `driver_attach()`?
A: - `device_attach(dev)` - find driver for a specific device
- `driver_attach(drv)` - find devices for a specific driver
Both iterate and try matching. Used after registration and for re-probing scenarios.
[Intermediate]

---

## Section 6: Unified Device Model - Device Hierarchy ⭐

Q: What is the device hierarchy in Linux?
A: The device hierarchy is a tree structure representing physical and logical device relationships. The root is a virtual device; all other devices have parents. This hierarchy:
1) Reflects physical topology
2) Determines power management order
3) Maps to sysfs `/sys/devices/`
[Basic]

Q: What field in struct device establishes the hierarchy?
A: The `parent` pointer:
```c
struct device {
    struct device *parent;  /* parent device */
    /* ... */
};
```
Set before calling `device_add()`. If NULL, device is a root device (rare) or parented to a bus/virtual device.
[Basic]

Q: What is the root of the device hierarchy?
A: The root is a virtual device that contains top-level buses. In sysfs, `/sys/devices/` shows:
- `system/` - system devices (CPUs, memory)
- `platform/` - platform bus devices
- `pci0000:00/` - PCI domain 0
- `virtual/` - virtual devices (loop, tty)
[Intermediate]

Q: (ASCII Diagram) Show a typical device hierarchy path.
A: ```
/sys/devices/
    └── pci0000:00/                 (PCI domain)
        └── 0000:00:1f.0/           (PCI bridge)
            └── 0000:01:00.0/       (GPU on secondary bus)
                ├── drm/            (DRM subsystem device)
                │   └── card0
                └── driver -> ../../../bus/pci/drivers/nvidia
```
[Intermediate]

Q: How does the hierarchy affect power management?
A: Parent devices must be powered on before children:
- **Suspend**: Children suspend before parents
- **Resume**: Parents resume before children
This ensures a USB device doesn't try to communicate while its hub is suspended.
[Intermediate]

Q: How do you set a device's parent?
A: Set `dev->parent` before registration:
```c
child_dev->parent = parent_dev;
device_register(child_dev);
```
Or pass parent to `device_create()`:
```c
device_create(class, parent, devt, data, "name");
```
[Basic]

Q: What is `device_for_each_child()` used for?
A: Iterates over a device's children:
```c
int device_for_each_child(struct device *parent,
                          void *data,
                          int (*fn)(struct device *, void *));
```
Callback `fn` is called for each child. Returns 0 or first non-zero from callback.
[Intermediate]

Q: What is `device_find_child()`?
A: Finds a child device matching a predicate:
```c
struct device *device_find_child(struct device *parent,
                                 void *data,
                                 int (*match)(struct device *, void *));
```
Returns first child where match returns non-zero, with incremented refcount.
[Intermediate]

Q: How do you traverse up the hierarchy?
A: Use the `parent` pointer:
```c
struct device *ancestor = dev->parent;
while (ancestor) {
    /* process ancestor */
    ancestor = ancestor->parent;
}
```
Or use `dev->parent` directly for immediate parent.
[Basic]

Q: What is `dev_name()` and where does the name come from?
A: `dev_name(dev)` returns the device name string:
```c
const char *dev_name(const struct device *dev);
```
Name set via `dev_set_name()` or `init_name` field. Appears in sysfs as directory name and in kernel messages.
[Basic]

Q: How does `dev_set_name()` work?
A: Printf-style name setting:
```c
int dev_set_name(struct device *dev, const char *fmt, ...);
```
Examples:
```c
dev_set_name(dev, "mydev%d", id);      /* mydev0, mydev1 */
dev_set_name(dev, "%s.%d", "uart", n); /* uart.0, uart.1 */
```
Returns 0 on success.
[Basic]

Q: What naming conventions do different buses use?
A: - **PCI**: `DDDD:BB:SS.F` (domain:bus:slot.function) e.g., `0000:00:1f.3`
- **USB**: `X-Y.Z` (bus-port.port) e.g., `1-1.2`
- **Platform**: arbitrary, often `name.id` e.g., `serial8250.0`
- **I2C**: `N-XXXX` (bus-address) e.g., `0-0050`
[Intermediate]

Q: What is `/sys/bus/<bus>/devices/`?
A: Contains symlinks to all devices on that bus:
```
/sys/bus/pci/devices/
    0000:00:00.0 -> ../../../devices/pci0000:00/0000:00:00.0
    0000:00:1f.0 -> ../../../devices/pci0000:00/0000:00:1f.0
```
Provides flat view for bus-specific tools, while `/sys/devices/` shows hierarchy.
[Intermediate]

Q: What is `/sys/bus/<bus>/drivers/`?
A: Contains directories for each registered driver:
```
/sys/bus/pci/drivers/
    e1000e/
        0000:00:19.0 -> ../../../../devices/.../0000:00:19.0
        bind
        unbind
        new_id
```
Each driver directory has symlinks to bound devices and bind/unbind controls.
[Intermediate]

Q: How are devices represented differently in /sys/devices vs /sys/bus?
A: - `/sys/devices/` - actual device directories in hierarchy
- `/sys/bus/<bus>/devices/` - symlinks to devices, flat list
- `/sys/class/<class>/` - symlinks to devices, grouped by function

Same device, multiple views for different use cases.
[Intermediate]

Q: What is a "virtual" device in the hierarchy?
A: Devices without physical hardware parent go under `/sys/devices/virtual/`:
```
/sys/devices/virtual/
    net/lo           (loopback interface)
    block/loop0      (loop device)
    tty/tty0         (virtual console)
```
Parent is set to NULL or virtual subsystem device.
[Intermediate]

Q: What is `device_move()`?
A: Moves a device to a new parent in the hierarchy:
```c
int device_move(struct device *dev, struct device *new_parent,
                enum dpm_order dpm_order);
```
Updates sysfs hierarchy and power management ordering. Rarely needed; used in special cases like USB hub reorganization.
[Advanced]

Q: What is `device_rename()`?
A: Changes a device's name:
```c
int device_rename(struct device *dev, const char *new_name);
```
Renames sysfs directory. Use sparingly - can break userspace that hardcodes paths. Network interfaces use this during renaming (eth0 → enp0s3).
[Advanced]

Q: How does sysfs represent the device hierarchy?
A: Directory nesting mirrors device parentage:
```
/sys/devices/
    platform/              (platform bus device)
        i2c-0/             (I2C adapter, child of platform)
            0-0050/        (I2C device, child of adapter)
```
`dev->parent` becomes enclosing directory.
[Basic]

Q: What is the relationship between kobject parent and device parent?
A: They mirror each other:
```c
dev->kobj.parent == &dev->parent->kobj
```
Setting `dev->parent` before `device_add()` automatically sets up kobject hierarchy. The sysfs directory structure reflects both.
[Intermediate]

Q: How do you get the device path in sysfs?
A: Use `kobject_get_path()` or `device_path()`:
```c
char *path = kobject_get_path(&dev->kobj, GFP_KERNEL);
/* path = "/devices/pci0000:00/0000:00:1f.0" */
kfree(path);
```
Returns allocated string with full sysfs path.
[Intermediate]

Q: What is `dev_get_parent()` (or equivalent access)?
A: Simply access `dev->parent`:
```c
struct device *parent = dev->parent;
if (parent) {
    /* use parent */
}
```
May need `get_device(dev->parent)` for long-lived references. The parent pointer is valid while device is registered.
[Basic]

Q: What does `device_initialize()` set up for hierarchy?
A: `device_initialize()` prepares device for hierarchy:
1) Initializes kobject
2) Sets up children list
3) Initializes locks
4) Sets up PM fields
Does NOT set parent - you must do that before `device_add()`.
[Intermediate]

Q: How do you count children of a device?
A: Use `device_for_each_child()` with a counting callback:
```c
int count = 0;
device_for_each_child(parent, &count, count_fn);

static int count_fn(struct device *dev, void *data) {
    (*(int *)data)++;
    return 0;
}
```
[Intermediate]

Q: What happens to children when a parent is unregistered?
A: Children become orphaned (parent pointer becomes invalid). Best practice:
1) Unregister all children first
2) Then unregister parent
Some subsystems walk children and unregister them automatically, but explicit cleanup is safer.
[Intermediate]

---

## Section 7: Unified Device Model - Hotplug and Uevent ⭐

Q: What is hotplug in Linux?
A: Hotplug is the mechanism for handling devices that are added or removed while the system is running:
1) Hardware generates interrupt/signal
2) Kernel detects device change
3) Kernel sends uevent to userspace
4) Userspace (udev) responds appropriately
Examples: USB, FireWire, hot-swap SATA, PCI hotplug.
[Basic]

Q: What is a uevent?
A: A uevent (userspace event) is a notification sent from kernel to userspace about device model changes. Contains:
1) Action (add, remove, change, etc.)
2) Device path in sysfs
3) Environment variables with device info
Sent via netlink socket or legacy /sbin/hotplug.
[Basic]

Q: What are the uevent action types?
A: - `KOBJ_ADD` - device/kobject added
- `KOBJ_REMOVE` - device/kobject removed
- `KOBJ_CHANGE` - device state changed
- `KOBJ_MOVE` - device moved in hierarchy
- `KOBJ_ONLINE` - device online (CPU, memory)
- `KOBJ_OFFLINE` - device offline
- `KOBJ_BIND` - driver bound (newer kernels)
- `KOBJ_UNBIND` - driver unbound (newer kernels)
[Intermediate]

Q: What triggers a uevent?
A: Uevents are generated by:
1) `device_add()` → KOBJ_ADD
2) `device_del()` → KOBJ_REMOVE
3) `kobject_uevent()` called explicitly
4) `driver_bound()` → KOBJ_BIND (if enabled)
5) Device state changes (online/offline)
[Intermediate]

Q: What is `kobject_uevent()` function?
A: Sends a uevent for a kobject:
```c
int kobject_uevent(struct kobject *kobj, 
                   enum kobject_action action);
```
Example:
```c
kobject_uevent(&dev->kobj, KOBJ_CHANGE);
```
Used to notify userspace of state changes not tied to add/remove.
[Intermediate]

Q: What is `kobject_uevent_env()`?
A: Sends uevent with custom environment variables:
```c
int kobject_uevent_env(struct kobject *kobj,
                       enum kobject_action action,
                       char *envp_ext[]);
```
Example:
```c
char *envp[] = { "MYVAR=value", NULL };
kobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);
```
[Intermediate]

Q: What environment variables are included in uevents?
A: Standard variables:
- `ACTION=add|remove|change|...`
- `DEVPATH=/devices/pci0000:00/...`
- `SUBSYSTEM=pci|usb|block|...`
- `SEQNUM=1234` (sequence number)

Bus-specific (via uevent callback):
- `MODALIAS=...` (for module loading)
- `DRIVER=...` (bound driver name)
- `PCI_SLOT_NAME=...`, `DEVTYPE=...`, etc.
[Intermediate]

Q: What is the bus `uevent()` callback for?
A: Adds bus-specific environment variables:
```c
static int my_bus_uevent(struct device *dev,
                         struct kobj_uevent_env *env) {
    add_uevent_var(env, "MYBUS_ID=%d", dev->id);
    add_uevent_var(env, "MODALIAS=mybus:%s", dev_name(dev));
    return 0;
}
```
Called during uevent generation to customize notification.
[Intermediate]

Q: What is `struct kobj_uevent_env`?
A: Structure holding uevent environment data:
```c
struct kobj_uevent_env {
    char *envp[UEVENT_NUM_ENVP];  /* env var pointers */
    int envp_idx;                  /* next index */
    char buf[UEVENT_BUFFER_SIZE]; /* string storage */
    int buflen;                    /* buffer used */
};
```
Passed to `add_uevent_var()` to build environment.
[Intermediate]

Q: How do you add custom environment variables to a uevent?
A: Use `add_uevent_var()`:
```c
int add_uevent_var(struct kobj_uevent_env *env,
                   const char *format, ...);
```
Example:
```c
add_uevent_var(env, "DEVTYPE=%s", dev->type->name);
add_uevent_var(env, "MAJOR=%u", MAJOR(dev->devt));
add_uevent_var(env, "MINOR=%u", MINOR(dev->devt));
```
[Intermediate]

Q: How does the kernel deliver uevents to userspace?
A: Via netlink socket:
1) Kernel creates netlink message with uevent data
2) Broadcasts on `NETLINK_KOBJECT_UEVENT` socket
3) udev/systemd listens on this socket
4) Receives and processes events
Alternative: Legacy `/sbin/hotplug` (deprecated)
[Intermediate]

Q: What is the legacy hotplug mechanism?
A: Before netlink uevents, kernel ran `/sbin/hotplug`:
1) Kernel forks and execs `/sbin/hotplug`
2) Environment variables passed to script
3) Script handles device setup
Slow (fork per event) and synchronous. Replaced by netlink + udev.
[Intermediate]

Q: What is udev?
A: udev is the userspace device manager:
1) Listens for kernel uevents
2) Creates/removes device nodes in `/dev`
3) Runs rules to configure devices
4) Sets permissions, symlinks, triggers scripts
Modern systems use systemd-udevd.
[Basic]

Q: What happens when a USB device is plugged in?
A: 1) USB hub detects device (hardware interrupt)
2) Hub driver reads device descriptors
3) Creates `struct usb_device`, calls `device_add()`
4) Kernel sends ADD uevent with MODALIAS
5) udev receives event
6) udev loads appropriate module
7) Driver probes device
8) udev creates /dev nodes, runs rules
[Intermediate]

Q: (ASCII Diagram) Show the hotplug event flow.
A: ```
[Hardware]
    │ Device inserted
    ▼
[Kernel Driver] ──► device_add()
    │
    ▼
[Device Core] ──► kobject_uevent(KOBJ_ADD)
    │
    ▼
[Netlink] ──────► UEVENT broadcast
    │
    ▼
[udev] ◄─────────── Receives event
    │
    ├──► modprobe (load driver)
    ├──► Create /dev node
    └──► Run udev rules
```
[Intermediate]

Q: What is coldplug?
A: Coldplug handles devices present at boot before udev starts:
1) Kernel discovers devices during boot
2) Generates uevents but no one listening yet
3) udev starts, triggers "coldplug" scan
4) Reads `/sys` and resynthesizes events
5) Creates /dev nodes for pre-existing devices
[Intermediate]

Q: How does udev handle coldplug?
A: udev triggers event replay:
```bash
udevadm trigger --action=add
```
Or automatically at startup:
1) Walk `/sys/devices/` tree
2) Read `uevent` file to get ADD event data
3) Process as if device just appeared
The `uevent` sysfs file allows replaying device's ADD event.
[Intermediate]

Q: What is the `uevent` sysfs file?
A: Each device has `/sys/.../<device>/uevent`:
- **Reading**: Shows environment variables for ADD event
- **Writing**: Triggers a new uevent
```bash
cat /sys/class/net/eth0/uevent
echo add > /sys/class/net/eth0/uevent
```
Used for coldplug and debugging.
[Intermediate]

Q: What is `struct kset_uevent_ops`?
A: Hooks for kset-level uevent filtering:
```c
struct kset_uevent_ops {
    int (*filter)(struct kset *kset, struct kobject *kobj);
    const char *(*name)(struct kset *kset, struct kobject *kobj);
    int (*uevent)(struct kset *kset, struct kobject *kobj,
                  struct kobj_uevent_env *env);
};
```
`filter` can suppress uevents; `uevent` adds variables.
[Advanced]

Q: How can you suppress uevents for specific kobjects?
A: Via kset's filter callback:
```c
static int my_filter(struct kset *kset, struct kobject *kobj) {
    /* return 0 to suppress, 1 to send */
    if (should_hide(kobj))
        return 0;
    return 1;
}
```
Or set `dev->uevent_suppress = 1` temporarily.
[Advanced]

Q: What is `dev_uevent_filter()`?
A: Internal function that determines if a device uevent should be sent:
1) Check `dev->uevent_suppress` flag
2) Check bus filter callback
3) Check device type
Returns 0 to suppress event.
[Advanced]

Q: How do you suppress uevents during device setup?
A: Use `dev_set_uevent_suppress()`:
```c
dev_set_uevent_suppress(dev, 1);  /* suppress */
/* do setup that would trigger uevents */
dev_set_uevent_suppress(dev, 0);  /* re-enable */
kobject_uevent(&dev->kobj, KOBJ_ADD); /* send now */
```
Useful for batching or delaying notifications.
[Advanced]

Q: What kernel config enables uevent helper?
A: `CONFIG_UEVENT_HELPER` enables `/sbin/hotplug` support:
```
CONFIG_UEVENT_HELPER=y
CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
```
Deprecated - modern systems use netlink only. Can be set at runtime via `/sys/kernel/uevent_helper`.
[Intermediate]

Q: What is `udevadm monitor` used for?
A: Displays kernel uevents in real-time:
```bash
udevadm monitor --kernel --property
```
Shows:
- Device path
- Action (add/remove/change)
- Environment variables
Essential debugging tool for hotplug issues.
[Basic]

Q: How does MODALIAS enable automatic driver loading?
A: 1) Device ADD uevent contains `MODALIAS=bustype:...`
2) udev matches against `/lib/modules/.../modules.alias`
3) Alias file has: `alias modalias_pattern module_name`
4) udev runs `modprobe module_name`
5) Module registers driver, binds to device
[Intermediate]

Q: (Cloze) Uevents are delivered to userspace via _____ socket with group _____.
A: Uevents are delivered to userspace via **netlink** socket with group **NETLINK_KOBJECT_UEVENT**.
[Intermediate]

---

## Section 8: Unified Device Model - Device Classes ⭐

Q: What is a device class?
A: A device class groups devices by function rather than connection type:
- **Bus**: How device is connected (PCI, USB)
- **Class**: What device does (network, block, input)
Examples: All network interfaces are in "net" class regardless of whether they're PCI, USB, or virtual.
[Basic]

Q: Where do classes appear in sysfs?
A: `/sys/class/` contains one directory per class:
```
/sys/class/
    net/
        eth0 -> ../../devices/pci.../net/eth0
        lo   -> ../../devices/virtual/net/lo
    block/
        sda  -> ../../devices/pci.../block/sda
    tty/
        tty0 -> ../../devices/virtual/tty/tty0
```
Contains symlinks to actual device locations.
[Basic]

Q: What is `struct class`?
A: Represents a device class:
```c
struct class {
    const char *name;                    /* class name */
    struct class_attribute *class_attrs; /* class-level attrs */
    struct device_attribute *dev_attrs;  /* device attrs */
    int (*dev_uevent)(struct device *, struct kobj_uevent_env *);
    void (*class_release)(struct class *);
    void (*dev_release)(struct device *);
    /* ... PM, namespace callbacks ... */
};
```
[Intermediate]

Q: How do you create a device class?
A: Use `class_create()`:
```c
struct class *my_class;
my_class = class_create(THIS_MODULE, "myclass");
if (IS_ERR(my_class))
    return PTR_ERR(my_class);
/* creates /sys/class/myclass/ */
```
Or `class_register()` for pre-initialized struct.
[Intermediate]

Q: How do you destroy a device class?
A: Use `class_destroy()`:
```c
class_destroy(my_class);
```
Or `class_unregister()` for registered classes. Must be done after all devices in the class are removed.
[Intermediate]

Q: How do you create a device in a class?
A: Use `device_create()`:
```c
struct device *dev;
dev = device_create(my_class, parent, devt, drvdata, "mydev%d", n);
```
Parameters:
- `class` - the device class
- `parent` - parent device (can be NULL)
- `devt` - device number (MKDEV) or 0
- `drvdata` - driver data
- `fmt...` - device name
[Intermediate]

Q: What does `device_create()` do internally?
A: 1) Allocates struct device
2) Sets `dev->class = class`
3) Sets parent, devt, name
4) Calls `device_register()`
5) Creates `/sys/class/<class>/<name>` symlink
6) If devt != 0, adds `dev` attribute for mknod
[Intermediate]

Q: How do you remove a class device?
A: Use `device_destroy()`:
```c
device_destroy(my_class, devt);
```
Finds device by class + devt and unregisters it. Or use `device_unregister()` directly if you have the device pointer.
[Intermediate]

Q: What is the relationship between class and bus?
A: Orthogonal categorizations:
- **Bus**: Physical/logical connection
- **Class**: Functional category
A USB network adapter:
- Bus: USB (how it's connected)
- Class: net (what it does)
Device belongs to one bus but may be in a class.
[Intermediate]

Q: (ASCII Diagram) Show how a device relates to both bus and class.
A: ```
                 struct device
                    /     \
                   /       \
         dev->bus          dev->class
            │                   │
            ▼                   ▼
     /sys/bus/usb/       /sys/class/net/
      devices/             eth0 ──┐
        1-1 ─────────────────────┘
```
Same device, different organizational views.
[Intermediate]

Q: What is `class_for_each_device()`?
A: Iterates all devices in a class:
```c
int class_for_each_device(struct class *class,
                          struct device *start,
                          void *data,
                          int (*fn)(struct device *, void *));
```
Useful for finding or operating on all class members.
[Intermediate]

Q: What is `class_find_device()`?
A: Finds a device in a class matching criteria:
```c
struct device *class_find_device(struct class *class,
                                 struct device *start,
                                 void *data,
                                 int (*match)(struct device *, void *));
```
Returns device with incremented refcount, or NULL.
[Intermediate]

Q: What are some common device classes in Linux?
A: - `block` - block devices (sda, loop0)
- `net` - network interfaces (eth0, wlan0)
- `tty` - terminal devices (tty0, ttyS0)
- `input` - input devices (event0, mouse0)
- `sound` - ALSA sound devices
- `drm` - display/GPU devices
- `scsi_host`, `scsi_device` - SCSI layer
[Basic]

Q: How does `dev->class` interact with sysfs?
A: When `dev->class` is set:
1) `device_add()` creates symlink in `/sys/class/<classname>/`
2) Symlink points to device's actual location
3) Class's dev_attrs are added to device
4) Class's uevent callback adds SUBSYSTEM=classname
[Intermediate]

Q: What is the `devt` field and how do classes use it?
A: `devt` is the device number (major:minor) for char/block devices:
```c
dev->devt = MKDEV(major, minor);
```
If set:
- Creates `dev` attribute in sysfs (shows "M:m")
- Enables `device_create()`/`device_destroy()` lookup
- udev uses it to create /dev nodes
[Intermediate]

Q: What is `class_interface`?
A: Hooks for notification when devices join/leave a class:
```c
struct class_interface {
    struct class *class;
    int (*add_dev)(struct device *, struct class_interface *);
    void (*remove_dev)(struct device *, struct class_interface *);
};
class_interface_register(&my_interface);
```
Enables observer pattern for class membership changes.
[Advanced]

Q: What is the difference between class_create and class_register?
A: - `class_create(owner, name)` - dynamically allocates and registers
- `class_register(class)` - registers pre-defined static struct class
```c
/* Dynamic */
cls = class_create(THIS_MODULE, "foo");

/* Static */
static struct class my_class = { .name = "foo", ... };
class_register(&my_class);
```
[Intermediate]

Q: What class attribute files exist by default?
A: Classes can have class-level attributes in `/sys/class/<name>/`:
```c
static CLASS_ATTR_RO(version);  /* read-only */
static CLASS_ATTR_RW(config);   /* read-write */
```
Creates files like `/sys/class/myclass/version`.
[Intermediate]

Q: What is the `dev_release` callback in struct class?
A: Called when last reference to a class device is dropped:
```c
void my_dev_release(struct device *dev) {
    struct my_dev *mydev = to_my_dev(dev);
    kfree(mydev);
}
my_class->dev_release = my_dev_release;
```
Default destructor for devices created with `device_create()`.
[Intermediate]

Q: How do classes help udev create device nodes?
A: 1) Device added to class with devt set
2) Uevent includes MAJOR, MINOR, SUBSYSTEM
3) udev rule matches: `SUBSYSTEM=="myclass"`
4) udev creates `/dev/myclass/mydev0`
5) Permissions set by udev rules
Classes provide SUBSYSTEM for rule matching.
[Intermediate]

---

## Section 9: Platform Devices and Drivers

Q: What is a platform device?
A: A platform device is a device that is NOT discoverable via standard enumeration (unlike PCI/USB). It's:
1) Connected directly to the CPU or system bus
2) Described statically in board files or device tree
3) Often SOC-integrated peripherals
Examples: on-chip UART, GPIO controllers, I2C controllers.
[Basic]

Q: Why is the platform bus needed?
A: Non-enumerable devices need a way to participate in the device model. The platform bus:
1) Provides bus_type for these devices
2) Enables standard probe/remove lifecycle
3) Allows resource management (memory, IRQ)
4) Integrates with power management
5) Works with device tree
[Basic]

Q: What is `struct platform_device`?
A: Represents a platform device:
```c
struct platform_device {
    const char *name;             /* device name for matching */
    int id;                       /* instance ID, -1 if single */
    struct device dev;            /* embedded base device */
    u32 num_resources;            /* number of resources */
    struct resource *resource;    /* I/O mem, IRQ resources */
    const struct platform_device_id *id_entry;
    /* ... */
};
```
[Intermediate]

Q: What is `struct platform_driver`?
A: Represents a platform driver:
```c
struct platform_driver {
    int (*probe)(struct platform_device *);
    int (*remove)(struct platform_device *);
    void (*shutdown)(struct platform_device *);
    int (*suspend)(struct platform_device *, pm_message_t);
    int (*resume)(struct platform_device *);
    struct device_driver driver;       /* embedded base driver */
    const struct platform_device_id *id_table;
};
```
[Intermediate]

Q: How do you register a platform driver?
A: Use `platform_driver_register()`:
```c
static struct platform_driver my_driver = {
    .probe = my_probe,
    .remove = my_remove,
    .driver = {
        .name = "my-device",
        .owner = THIS_MODULE,
    },
};
platform_driver_register(&my_driver);
/* cleanup: platform_driver_unregister(&my_driver); */
```
[Basic]

Q: What is `module_platform_driver()` macro?
A: Convenience macro that generates init/exit boilerplate:
```c
module_platform_driver(my_driver);
/* Expands to module_init/exit calling 
   platform_driver_register/unregister */
```
Simplest way to create a platform driver module.
[Intermediate]

Q: How does platform bus match devices to drivers?
A: Multiple matching methods (checked in order):
1) Device tree `compatible` property vs `of_match_table`
2) ACPI matching via `acpi_match_table`
3) `id_table` matching by name
4) Simple name match: `pdev->name` vs `drv->driver.name`
[Intermediate]

Q: What is `struct resource` in platform devices?
A: Describes a hardware resource:
```c
struct resource {
    resource_size_t start;   /* start address */
    resource_size_t end;     /* end address (inclusive) */
    const char *name;
    unsigned long flags;     /* IORESOURCE_MEM, IORESOURCE_IRQ */
    /* ... */
};
```
Used for memory regions, I/O ports, IRQs, DMA channels.
[Intermediate]

Q: What are common resource types?
A: - `IORESOURCE_MEM` - memory-mapped I/O region
- `IORESOURCE_IO` - I/O port region (x86)
- `IORESOURCE_IRQ` - interrupt line
- `IORESOURCE_DMA` - DMA channel
- `IORESOURCE_BUS` - bus number range
[Intermediate]

Q: How do you get resources in a platform driver probe?
A: Use `platform_get_resource()`:
```c
struct resource *res;
res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
if (!res)
    return -ENODEV;
/* res->start, res->end now available */
```
Third argument is index (0 = first resource of type).
[Intermediate]

Q: How do you get an IRQ in a platform driver?
A: Use `platform_get_irq()`:
```c
int irq = platform_get_irq(pdev, 0);
if (irq < 0)
    return irq;  /* error code */
request_irq(irq, my_handler, 0, "mydev", data);
```
Returns IRQ number or negative error.
[Intermediate]

Q: What is `platform_get_resource_byname()`?
A: Gets resource by name instead of index:
```c
struct resource *res;
res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "regs");
```
Useful when device has multiple resources and order isn't fixed.
[Intermediate]

Q: What is `devm_platform_ioremap_resource()`?
A: Device-managed combined resource get + ioremap:
```c
void __iomem *base;
base = devm_platform_ioremap_resource(pdev, 0);
if (IS_ERR(base))
    return PTR_ERR(base);
```
Automatically requests region, remaps, and cleans up on remove/error.
[Intermediate]

Q: How do you statically create a platform device (board file)?
A: Define and register in board code:
```c
static struct resource my_resources[] = {
    { .start = 0x10000000, .end = 0x10000fff,
      .flags = IORESOURCE_MEM },
    { .start = 42, .end = 42, .flags = IORESOURCE_IRQ },
};
static struct platform_device my_pdev = {
    .name = "my-device",
    .id = 0,
    .resource = my_resources,
    .num_resources = ARRAY_SIZE(my_resources),
};
platform_device_register(&my_pdev);
```
[Intermediate]

Q: What is `platform_device_alloc()` and `platform_device_add()`?
A: Dynamic platform device creation:
```c
struct platform_device *pdev;
pdev = platform_device_alloc("my-device", 0);
platform_device_add_resources(pdev, res, num_res);
platform_device_add_data(pdev, &pdata, sizeof(pdata));
platform_device_add(pdev);
/* cleanup: platform_device_unregister(pdev); */
```
[Intermediate]

Q: What is platform_data?
A: Driver-specific configuration passed via device:
```c
struct my_platform_data {
    int option1;
    const char *name;
};
pdev->dev.platform_data = &my_pdata;

/* In driver probe: */
struct my_platform_data *pdata = dev_get_platdata(&pdev->dev);
```
Legacy mechanism; device tree preferred for new code.
[Intermediate]

Q: How does device tree integrate with platform devices?
A: Device tree nodes become platform devices:
1) Kernel parses device tree at boot
2) `of_platform_populate()` creates platform_devices
3) Driver's `of_match_table` enables matching
4) `of_device_id.compatible` matches DT `compatible` property
5) Resources extracted from DT (reg, interrupts)
[Intermediate]

Q: What is `of_match_table` in platform drivers?
A: Device tree matching table:
```c
static const struct of_device_id my_of_match[] = {
    { .compatible = "vendor,my-device" },
    { .compatible = "vendor,my-device-v2" },
    { },
};
MODULE_DEVICE_TABLE(of, my_of_match);

static struct platform_driver my_driver = {
    .driver = {
        .of_match_table = my_of_match,
    },
};
```
[Intermediate]

Q: How do you get device tree properties in probe?
A: Use of_* functions:
```c
struct device_node *np = pdev->dev.of_node;
u32 value;
of_property_read_u32(np, "my-property", &value);
/* or device property API: */
device_property_read_u32(&pdev->dev, "my-property", &value);
```
[Intermediate]

Q: What is `platform_device_id` table?
A: Name-based matching with driver data:
```c
static const struct platform_device_id my_ids[] = {
    { "my-device-v1", (kernel_ulong_t)&v1_data },
    { "my-device-v2", (kernel_ulong_t)&v2_data },
    { },
};
/* Access in probe: */
const struct platform_device_id *id = platform_get_device_id(pdev);
void *data = (void *)id->driver_data;
```
[Intermediate]

Q: What is the sysfs structure for platform devices?
A: Platform devices appear at:
```
/sys/devices/platform/
    my-device.0/
        driver -> ../../../bus/platform/drivers/my-device
        modalias
        uevent
/sys/bus/platform/
    devices/
        my-device.0 -> ../../../devices/platform/my-device.0
    drivers/
        my-device/
```
[Basic]

Q: What is the key difference between platform devices and PCI/USB?
A: | Platform | PCI/USB |
|----------|---------|
| Not enumerable | Hardware enumeration |
| Static description | Dynamic discovery |
| Board file / DT | Bus scan |
| Resources predefined | Resources queried |
| No hotplug (usually) | Hotplug capable |
| SOC peripherals | Expansion cards |
[Intermediate]

Q: What are early platform devices?
A: Platform devices needed very early in boot (before normal driver init):
```c
early_platform_driver_register(&my_early_driver, "earlyprintk");
early_platform_driver_probe("earlyprintk", 1, 0);
```
Used for early console output. Limited functionality.
[Advanced]

---

## Section 10: Character Device Drivers

Q: What is a character device?
A: A character device provides byte-stream access (like a file):
1) Data accessed sequentially (usually)
2) No block buffering by kernel
3) Examples: serial ports, keyboards, /dev/null, custom devices
4) Accessed via /dev node with major:minor number
[Basic]

Q: What is the difference between character and block devices?
A: | Character Device | Block Device |
|-----------------|--------------|
| Byte stream | Fixed-size blocks |
| No buffering | Block buffer cache |
| Sequential access | Random access |
| read()/write() | Request queue |
| TTY, serial, input | Disk, SSD, loop |
[Basic]

Q: What is a device number (dev_t)?
A: `dev_t` is a 32-bit number encoding major and minor:
```c
dev_t devno;
int major = MAJOR(devno);   /* upper 12 bits */
int minor = MINOR(devno);   /* lower 20 bits */
devno = MKDEV(major, minor);
```
Major identifies driver; minor identifies specific device.
[Basic]

Q: How do you allocate device numbers?
A: Static or dynamic allocation:
```c
/* Static: specify major number */
register_chrdev_region(MKDEV(major, 0), count, "mydev");

/* Dynamic: kernel assigns major */
alloc_chrdev_region(&devno, 0, count, "mydev");
major = MAJOR(devno);
```
Dynamic preferred to avoid conflicts.
[Intermediate]

Q: How do you release device numbers?
A: Use `unregister_chrdev_region()`:
```c
unregister_chrdev_region(MKDEV(major, 0), count);
```
Call during cleanup after removing cdev.
[Basic]

Q: What is `struct cdev`?
A: Kernel's representation of a character device:
```c
struct cdev {
    struct kobject kobj;
    struct module *owner;
    const struct file_operations *ops;
    struct list_head list;
    dev_t dev;              /* first device number */
    unsigned int count;     /* number of devices */
};
```
Links device numbers to file_operations.
[Intermediate]

Q: How do you initialize and add a cdev?
A: ```c
struct cdev my_cdev;

cdev_init(&my_cdev, &my_fops);
my_cdev.owner = THIS_MODULE;
cdev_add(&my_cdev, devno, 1);
/* cleanup: cdev_del(&my_cdev); */
```
`cdev_add()` makes device live - ready for open().
[Intermediate]

Q: What is the alternative `cdev_alloc()` approach?
A: Dynamic allocation:
```c
struct cdev *my_cdev = cdev_alloc();
my_cdev->ops = &my_fops;
my_cdev->owner = THIS_MODULE;
cdev_add(my_cdev, devno, 1);
/* cleanup: cdev_del(my_cdev); kfree is automatic */
```
cdev_alloc sets up kobject for auto-free on last put.
[Intermediate]

Q: What is `struct file_operations`?
A: Defines file operations for a character device:
```c
struct file_operations {
    struct module *owner;
    loff_t (*llseek)(struct file *, loff_t, int);
    ssize_t (*read)(struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *);
    int (*open)(struct inode *, struct file *);
    int (*release)(struct inode *, struct file *);
    long (*unlocked_ioctl)(struct file *, unsigned int, unsigned long);
    int (*mmap)(struct file *, struct vm_area_struct *);
    unsigned int (*poll)(struct file *, struct poll_table_struct *);
    /* ... many more ... */
};
```
[Intermediate]

Q: What is the `open` callback for?
A: Called when userspace opens the device file:
```c
int my_open(struct inode *inode, struct file *filp) {
    struct my_dev *dev = container_of(inode->i_cdev, 
                                       struct my_dev, cdev);
    filp->private_data = dev;
    return 0;
}
```
Initialize per-file state; `inode->i_cdev` points to cdev.
[Intermediate]

Q: What is the `release` callback for?
A: Called when last reference to open file is closed:
```c
int my_release(struct inode *inode, struct file *filp) {
    struct my_dev *dev = filp->private_data;
    /* cleanup per-file resources */
    return 0;
}
```
Note: Called once when ALL fds to same open are closed.
[Intermediate]

Q: What is `filp->private_data` used for?
A: Driver-private pointer in struct file:
```c
/* In open: */
filp->private_data = my_device_struct;
/* In read/write/etc: */
struct my_dev *dev = filp->private_data;
```
Links file handle to your device state.
[Basic]

Q: What is the read callback signature and contract?
A: ```c
ssize_t my_read(struct file *filp, char __user *buf, 
                size_t count, loff_t *f_pos);
```
- Copy data to `buf` using `copy_to_user()`
- Update `*f_pos` with new position
- Return bytes read, 0 for EOF, negative for error
- `__user` annotation marks userspace pointer
[Intermediate]

Q: What is the write callback signature and contract?
A: ```c
ssize_t my_write(struct file *filp, const char __user *buf,
                 size_t count, loff_t *f_pos);
```
- Copy from `buf` using `copy_from_user()`
- Update `*f_pos`
- Return bytes written, negative for error
- Must handle partial writes correctly
[Intermediate]

Q: Why must you use copy_to_user/copy_from_user?
A: Userspace pointers cannot be dereferenced directly:
1) Different address space (virtual memory)
2) Page may be swapped out
3) Pointer may be invalid/malicious
These functions safely copy and return bytes NOT copied (0 = success).
[Intermediate]

Q: (Code Example) Show safe read implementation:
A: ```c
ssize_t
my_read(struct file *filp, char __user *buf, 
        size_t count, loff_t *f_pos)
{
    struct my_dev *dev = filp->private_data;
    size_t avail = dev->size - *f_pos;
    
    if(*f_pos >= dev->size)
        return 0;  /* EOF */
    if(count > avail)
        count = avail;
    if(copy_to_user(buf, dev->data + *f_pos, count))
        return -EFAULT;
    *f_pos += count;
    return count;
}
```
[Intermediate]

Q: What is `unlocked_ioctl` and how does it differ from old `ioctl`?
A: - Old `ioctl` held Big Kernel Lock (BKL) - removed
- `unlocked_ioctl` runs without BKL
- Driver must handle its own locking
```c
long my_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
```
Returns 0 on success, negative error or positive value.
[Intermediate]

Q: How do you define ioctl command numbers?
A: Use macros from `<linux/ioctl.h>`:
```c
#define MY_IOC_MAGIC 'k'
#define MY_IOCTL_RESET    _IO(MY_IOC_MAGIC, 0)
#define MY_IOCTL_GET_VAL  _IOR(MY_IOC_MAGIC, 1, int)
#define MY_IOCTL_SET_VAL  _IOW(MY_IOC_MAGIC, 2, int)
#define MY_IOCTL_XFER     _IOWR(MY_IOC_MAGIC, 3, struct my_data)
```
Encodes direction, type, number, and size.
[Intermediate]

Q: What does the poll callback do?
A: Enables select()/poll()/epoll() on device:
```c
unsigned int my_poll(struct file *filp, poll_table *wait) {
    struct my_dev *dev = filp->private_data;
    unsigned int mask = 0;
    
    poll_wait(filp, &dev->read_queue, wait);
    if(data_available(dev))
        mask |= POLLIN | POLLRDNORM;
    if(can_write(dev))
        mask |= POLLOUT | POLLWRNORM;
    return mask;
}
```
[Intermediate]

Q: What is llseek for?
A: Implements lseek() positioning:
```c
loff_t my_llseek(struct file *filp, loff_t offset, int whence) {
    loff_t newpos;
    switch(whence) {
        case SEEK_SET: newpos = offset; break;
        case SEEK_CUR: newpos = filp->f_pos + offset; break;
        case SEEK_END: newpos = dev->size + offset; break;
        default: return -EINVAL;
    }
    if(newpos < 0) return -EINVAL;
    filp->f_pos = newpos;
    return newpos;
}
```
[Intermediate]

Q: What is `noop_llseek` and `no_llseek`?
A: - `noop_llseek` - allows lseek but does nothing (always returns current position)
- `no_llseek` - returns error on lseek attempt
Use when seek doesn't make sense:
```c
.llseek = no_llseek,  /* stream devices */
```
[Intermediate]

Q: How do you create the /dev node for a character device?
A: Options:
1) **Manual**: `mknod /dev/mydev c MAJOR MINOR`
2) **udev**: Register with class, udev creates automatically
```c
class = class_create(THIS_MODULE, "myclass");
device_create(class, NULL, devno, NULL, "mydev%d", n);
/* creates /dev/mydev0 */
```
Modern approach uses udev.
[Intermediate]

Q: What is `struct inode` vs `struct file`?
A: - `struct inode` - represents file on disk/filesystem; one per device file
- `struct file` - represents open file handle; many per inode (multiple opens)
```
/dev/mydev (inode) → open() → struct file (fd 3)
                   → open() → struct file (fd 4)
```
[Intermediate]

Q: How do you get cdev from inode in open?
A: Use `container_of`:
```c
int my_open(struct inode *inode, struct file *filp) {
    struct my_dev *dev;
    dev = container_of(inode->i_cdev, struct my_dev, cdev);
    filp->private_data = dev;
    return 0;
}
```
`inode->i_cdev` points to your cdev structure.
[Intermediate]

---

## Section 11: Memory and I/O for Drivers

Q: What is `kmalloc()` and when to use it?
A: Allocates physically contiguous kernel memory:
```c
void *ptr = kmalloc(size, GFP_KERNEL);
kfree(ptr);
```
- Fast allocation from slab cache
- Limited to ~128KB typically
- Use for small, short-lived allocations
- `GFP_KERNEL` can sleep; `GFP_ATOMIC` for interrupt context
[Basic]

Q: What are common GFP (Get Free Pages) flags?
A: - `GFP_KERNEL` - normal allocation, can sleep
- `GFP_ATOMIC` - can't sleep (interrupt context)
- `GFP_DMA` - DMA-capable memory (ISA)
- `GFP_NOWAIT` - don't wait, fail quickly
- `__GFP_ZERO` - zero the allocated memory
- `GFP_HIGHUSER` - user pages, high memory OK
[Intermediate]

Q: What is `kzalloc()`?
A: Allocates zeroed memory:
```c
void *ptr = kzalloc(size, GFP_KERNEL);
```
Equivalent to:
```c
ptr = kmalloc(size, GFP_KERNEL);
memset(ptr, 0, size);
```
Safer - no uninitialized data exposure.
[Basic]

Q: What is `vmalloc()` and how does it differ from `kmalloc()`?
A: | kmalloc | vmalloc |
|---------|---------|
| Physically contiguous | Virtually contiguous |
| Limited size (~128KB) | Can be very large |
| Fast | Slower (page table setup) |
| For DMA | NOT for DMA |
| From slab | From page allocator |
```c
void *ptr = vmalloc(large_size);
vfree(ptr);
```
[Intermediate]

Q: What is `ioremap()` used for?
A: Maps device memory into kernel virtual address space:
```c
void __iomem *base = ioremap(phys_addr, size);
/* use readl/writel to access */
iounmap(base);
```
Device registers at physical addresses aren't directly accessible; ioremap creates a mapping.
[Basic]

Q: What is the `__iomem` annotation?
A: Sparse checker annotation marking I/O memory pointers:
```c
void __iomem *regs;
```
Prevents accidentally using normal pointer operations. Reminds you to use `readl`/`writel` accessors.
[Basic]

Q: What are the I/O memory accessor functions?
A: ```c
/* Read from I/O memory */
u8  val = readb(addr);    /* 8-bit */
u16 val = readw(addr);    /* 16-bit */
u32 val = readl(addr);    /* 32-bit */
u64 val = readq(addr);    /* 64-bit */

/* Write to I/O memory */
writeb(val, addr);
writew(val, addr);
writel(val, addr);
writeq(val, addr);
```
[Basic]

Q: Why not use direct pointer dereference for MMIO?
A: Direct access bypasses:
1) Memory barriers (ordering not guaranteed)
2) Cache coherency requirements
3) Architecture differences (endianness)
4) Compiler optimization prevention
`readl`/`writel` handle all these correctly.
[Intermediate]

Q: What is `request_mem_region()`?
A: Claims exclusive access to a memory-mapped I/O region:
```c
if (!request_mem_region(base, size, "mydriver"))
    return -EBUSY;
/* use the region */
release_mem_region(base, size);
```
Prevents other drivers from using same addresses. Shows in `/proc/iomem`.
[Intermediate]

Q: What is `devm_ioremap_resource()`?
A: Device-managed request + remap combination:
```c
res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
void __iomem *base = devm_ioremap_resource(&pdev->dev, res);
if (IS_ERR(base))
    return PTR_ERR(base);
```
Automatically releases on remove or error.
[Intermediate]

Q: What are memory barriers?
A: Prevent compiler/CPU reordering of memory operations:
```c
mb();   /* full barrier (read + write) */
rmb();  /* read barrier */
wmb();  /* write barrier */
smp_mb(), smp_rmb(), smp_wmb();  /* SMP versions */
```
Essential for device register access ordering.
[Intermediate]

Q: What is Port I/O vs Memory-Mapped I/O?
A: | Port I/O (x86) | Memory-Mapped I/O |
|----------------|-------------------|
| Separate address space | Same as RAM |
| `inb/outb` | `readb/writeb` |
| I/O instructions | Memory instructions |
| Limited space (64KB) | Full address space |
| x86 specific | Universal |
[Intermediate]

Q: What are Port I/O functions?
A: ```c
u8  val = inb(port);     /* read 8-bit from port */
u16 val = inw(port);     /* read 16-bit */
u32 val = inl(port);     /* read 32-bit */

outb(val, port);         /* write 8-bit */
outw(val, port);
outl(val, port);

/* string versions */
insb(port, buf, count);
outsb(port, buf, count);
```
[Intermediate]

Q: What is DMA and why is it used?
A: Direct Memory Access - hardware transfers data without CPU:
1) CPU sets up transfer (source, dest, length)
2) DMA controller moves data
3) CPU notified when complete (interrupt)
Benefits: Frees CPU, higher throughput, lower latency.
[Basic]

Q: What is coherent DMA?
A: CPU and device always see same data:
```c
void *cpu_addr;
dma_addr_t dma_addr;
cpu_addr = dma_alloc_coherent(dev, size, &dma_addr, GFP_KERNEL);
/* cpu_addr for CPU, dma_addr for device */
dma_free_coherent(dev, size, cpu_addr, dma_addr);
```
Hardware or software cache coherency maintained.
[Intermediate]

Q: What is streaming DMA?
A: One-time transfers with explicit cache management:
```c
dma_addr = dma_map_single(dev, buf, size, DMA_TO_DEVICE);
/* device uses dma_addr */
dma_unmap_single(dev, dma_addr, size, DMA_TO_DEVICE);
```
Directions: `DMA_TO_DEVICE`, `DMA_FROM_DEVICE`, `DMA_BIDIRECTIONAL`
[Intermediate]

Q: What is scatter-gather DMA?
A: Transfer multiple non-contiguous regions in one operation:
```c
struct scatterlist sg[N];
sg_init_table(sg, N);
sg_set_buf(&sg[0], buf0, len0);
sg_set_buf(&sg[1], buf1, len1);
dma_map_sg(dev, sg, N, DMA_TO_DEVICE);
```
Efficient for fragmented data.
[Advanced]

Q: What is `dma_set_mask()`?
A: Declares device's DMA addressing capability:
```c
if (dma_set_mask(dev, DMA_BIT_MASK(32)))
    return -EIO;  /* can't do 32-bit DMA */
```
`DMA_BIT_MASK(64)` for 64-bit capable devices. Required before DMA allocation.
[Intermediate]

Q: What are `devm_*` memory functions?
A: Device-managed allocations (auto-freed):
```c
devm_kzalloc(dev, size, GFP_KERNEL);
devm_ioremap(dev, phys_addr, size);
devm_ioremap_resource(dev, res);
devm_request_irq(dev, irq, handler, flags, name, data);
```
Freed when driver detaches - simplifies error paths.
[Intermediate]

Q: (Misconception) Can you use kmalloc memory for DMA?
A: MAYBE - depends on architecture. `kmalloc` doesn't guarantee DMA-ability. Always use:
```c
dma_alloc_coherent()  /* for coherent buffers */
dma_map_single()      /* to map existing buffers */
```
Or verify with `dma_set_mask()` first.
[Intermediate]

---

## Section 12: Interrupt Handling

Q: What is an interrupt in kernel context?
A: An interrupt is an asynchronous signal from hardware:
1) Device signals CPU via interrupt line
2) CPU suspends current execution
3) Kernel runs interrupt handler
4) Handler services device, clears interrupt
5) CPU resumes previous execution
[Basic]

Q: What is `request_irq()`?
A: Registers an interrupt handler:
```c
int request_irq(unsigned int irq,
                irq_handler_t handler,
                unsigned long flags,
                const char *name,
                void *dev_id);
```
Returns 0 on success, negative on error.
[Basic]

Q: What is the interrupt handler signature?
A: ```c
irqreturn_t my_handler(int irq, void *dev_id)
{
    /* handle interrupt */
    return IRQ_HANDLED;  /* or IRQ_NONE */
}
```
- `irq` - interrupt number
- `dev_id` - pointer passed to request_irq
- Returns `IRQ_HANDLED` or `IRQ_NONE`
[Basic]

Q: What are IRQ handler return values?
A: - `IRQ_NONE` - interrupt wasn't from this device
- `IRQ_HANDLED` - interrupt handled successfully
- `IRQ_WAKE_THREAD` - wake threaded handler
Used by kernel to track spurious interrupts and for shared IRQs.
[Basic]

Q: What is `free_irq()` for?
A: Releases an interrupt handler:
```c
free_irq(irq, dev_id);
```
Must use same `dev_id` as registration. Waits for running handlers to complete. Call in remove/cleanup.
[Basic]

Q: What is `IRQF_SHARED` flag?
A: Allows multiple handlers on same IRQ line:
```c
request_irq(irq, handler, IRQF_SHARED, "mydev", dev_ptr);
```
Requirements:
- All handlers on line must use IRQF_SHARED
- `dev_id` must be unique (not NULL)
- Handler must check if interrupt is from its device
[Intermediate]

Q: What are common IRQ flags?
A: - `IRQF_SHARED` - share IRQ with other devices
- `IRQF_TRIGGER_RISING` - rising edge trigger
- `IRQF_TRIGGER_FALLING` - falling edge trigger
- `IRQF_TRIGGER_HIGH` - high level trigger
- `IRQF_TRIGGER_LOW` - low level trigger
- `IRQF_ONESHOT` - don't re-enable until thread completes
[Intermediate]

Q: What is "top half" vs "bottom half"?
A: **Top half** (hardirq):
- Runs in interrupt context
- Must be fast, no sleeping
- Does minimum work (ack interrupt, schedule bottom half)

**Bottom half** (softirq/tasklet/workqueue):
- Runs later in safer context
- Does bulk of processing
- Can sleep (workqueue only)
[Intermediate]

Q: What restrictions exist in interrupt context?
A: Cannot:
1) Sleep or schedule (`GFP_ATOMIC` only)
2) Call functions that might sleep
3) Access user space memory
4) Take long time (blocks other interrupts)
Must minimize time in handler.
[Intermediate]

Q: How do you check if code runs in interrupt context?
A: ```c
if (in_interrupt())    /* hardirq or softirq */
if (in_irq())          /* hardirq only */
if (in_softirq())      /* softirq only */
if (in_atomic())       /* atomic (no sleeping) */
```
Use to assert correct context or select behavior.
[Intermediate]

Q: What is a tasklet?
A: Deferred work mechanism for bottom half:
```c
void my_tasklet_fn(unsigned long data) { /* work */ }
DECLARE_TASKLET(my_tasklet, my_tasklet_fn, 0);

/* In handler: */
tasklet_schedule(&my_tasklet);
```
Runs in softirq context - can't sleep but can be preempted.
[Intermediate]

Q: What is a workqueue?
A: Deferred work in process context (can sleep):
```c
struct work_struct my_work;
INIT_WORK(&my_work, my_work_fn);

void my_work_fn(struct work_struct *work) {
    /* can sleep here */
}

/* In handler: */
schedule_work(&my_work);
```
[Intermediate]

Q: When to use tasklet vs workqueue?
A: **Tasklet**:
- When work is quick
- No sleeping needed
- Lower latency

**Workqueue**:
- When work might sleep (mutex, I/O)
- Long-running processing
- Need process context
[Intermediate]

Q: What is a threaded IRQ?
A: IRQ handler runs in kernel thread context:
```c
request_threaded_irq(irq, hardirq_fn, thread_fn,
                     IRQF_ONESHOT, "name", dev);
```
- `hardirq_fn` - quick top half (can be NULL)
- `thread_fn` - runs in thread, can sleep
- `IRQF_ONESHOT` - IRQ disabled until thread completes
[Intermediate]

Q: What is `devm_request_irq()`?
A: Device-managed IRQ request:
```c
ret = devm_request_irq(dev, irq, handler, flags, name, data);
```
Automatically freed when device is removed. Simplifies error handling and cleanup.
[Intermediate]

Q: What is IRQ affinity?
A: Controls which CPUs can handle an IRQ:
```bash
cat /proc/irq/<N>/smp_affinity
echo 0f > /proc/irq/<N>/smp_affinity  # CPUs 0-3
```
Useful for balancing load or pinning to specific cores.
[Intermediate]

Q: What is `/proc/interrupts`?
A: Shows interrupt statistics:
```
           CPU0   CPU1   
  0:         45      0   IO-APIC   timer
  1:       2142      0   IO-APIC   i8042
 18:          0      0   IO-APIC   ehci_hcd
```
Columns: IRQ number, count per CPU, type, registered handlers.
[Basic]

Q: What is `disable_irq()` and `enable_irq()`?
A: Disable/enable an IRQ line:
```c
disable_irq(irq);     /* waits for running handlers */
disable_irq_nosync(irq); /* doesn't wait */
enable_irq(irq);
```
Use sparingly - nested disable/enable is counted.
[Intermediate]

Q: What are local IRQ operations?
A: Control interrupts on current CPU only:
```c
local_irq_disable();
/* critical section, interrupts disabled */
local_irq_enable();

/* save/restore version: */
unsigned long flags;
local_irq_save(flags);
/* critical section */
local_irq_restore(flags);
```
[Intermediate]

Q: What is spurious interrupt handling?
A: Kernel tracks interrupts where no handler returns IRQ_HANDLED:
1) Too many spurious → IRQ disabled
2) Warning logged
3) Prevents runaway interrupt storms
Always return `IRQ_NONE` if interrupt isn't from your device.
[Intermediate]

Q: (Code Example) Show typical top/bottom half pattern:
A: ```c
irqreturn_t
my_handler(int irq, void *dev_id)
{
    struct my_dev *dev = dev_id;
    
    if(!my_device_interrupted(dev))
        return IRQ_NONE;
    
    /* acknowledge HW interrupt */
    clear_device_irq(dev);
    
    /* schedule bottom half */
    tasklet_schedule(&dev->tasklet);
    return IRQ_HANDLED;
}

void
my_tasklet_fn(unsigned long data)
{
    struct my_dev *dev = (struct my_dev *)data;
    /* do the real work */
}
```
[Intermediate]

Q: What is `irq_set_handler_data()`?
A: Sets private data for low-level IRQ handling:
```c
irq_set_handler_data(irq, data);
```
Used by IRQ chip drivers, not typically in device drivers. Device drivers use `dev_id` in `request_irq()`.
[Advanced]

Q: What is an IRQ chip and IRQ domain?
A: Low-level interrupt controller abstractions:
- **IRQ chip** - hardware interrupt controller driver (GIC, APIC)
- **IRQ domain** - maps hardware IRQs to Linux IRQ numbers
Most device drivers don't interact with these directly.
[Advanced]

---

## Section 13: Synchronization Primitives

Q: What is a spinlock?
A: A busy-wait lock for short critical sections:
```c
spinlock_t lock;
spin_lock_init(&lock);

spin_lock(&lock);
/* critical section */
spin_unlock(&lock);
```
Holder cannot sleep. Use for short, fast critical sections.
[Basic]

Q: When should you use spinlocks?
A: Use spinlocks when:
1) Critical section is very short
2) Code may run in interrupt context
3) Holding the lock for minimal time
4) SMP protection needed

Don't use when you might sleep.
[Intermediate]

Q: What is `spin_lock_irqsave()`?
A: Spinlock + disable local interrupts:
```c
unsigned long flags;
spin_lock_irqsave(&lock, flags);
/* critical section - interrupts disabled */
spin_unlock_irqrestore(&lock, flags);
```
Use when lock may be taken in interrupt handler - prevents deadlock.
[Intermediate]

Q: What is the difference between spin_lock variants?
A: ```c
spin_lock(&lock);            /* basic lock */
spin_lock_irq(&lock);        /* + disable local IRQs */
spin_lock_irqsave(&lock, fl); /* + save IRQ state */
spin_lock_bh(&lock);         /* + disable softirqs */
```
Choose based on context that might also acquire the lock.
[Intermediate]

Q: What is a mutex?
A: A sleeping lock for longer critical sections:
```c
struct mutex lock;
mutex_init(&lock);

mutex_lock(&lock);      /* may sleep */
/* critical section */
mutex_unlock(&lock);
```
Can only be used in process context (can sleep).
[Basic]

Q: When should you use mutexes vs spinlocks?
A: **Mutex**:
- Critical section might sleep
- Holding lock for longer time
- Only process context

**Spinlock**:
- Very short critical section
- May be used in interrupt context
- Cannot sleep while holding
[Intermediate]

Q: What is `mutex_trylock()`?
A: Non-blocking mutex acquisition:
```c
if (mutex_trylock(&lock)) {
    /* got the lock */
    mutex_unlock(&lock);
} else {
    /* lock held by someone else */
}
```
Returns 1 if acquired, 0 if not. Doesn't sleep.
[Intermediate]

Q: What is a semaphore?
A: Counting synchronization primitive (legacy):
```c
struct semaphore sem;
sema_init(&sem, 1);     /* count = 1 for mutex-like */

down(&sem);             /* decrement, may sleep */
/* critical section */
up(&sem);               /* increment */
```
Prefer mutex for binary semaphore. Semaphores allow count > 1.
[Intermediate]

Q: What are atomic operations?
A: Operations that complete without interruption:
```c
atomic_t counter;
atomic_set(&counter, 0);
atomic_inc(&counter);           /* counter++ */
atomic_dec(&counter);           /* counter-- */
int val = atomic_read(&counter);
atomic_add(5, &counter);
```
No lock needed - hardware guarantees atomicity.
[Basic]

Q: What is `atomic_dec_and_test()`?
A: Decrement and check for zero:
```c
if (atomic_dec_and_test(&refcount)) {
    /* count reached zero */
    free_resource();
}
```
Used in reference counting. Returns true if result is zero.
[Intermediate]

Q: What is RCU (Read-Copy-Update)?
A: Lock-free synchronization for read-mostly data:
- Readers: No locks, just `rcu_read_lock()`
- Writers: Copy data, modify copy, atomically swap pointer
- Old data freed after grace period
Extremely fast reads, designed for scalability.
[Advanced]

Q: What is a completion?
A: Synchronization for one-time events:
```c
struct completion done;
init_completion(&done);

/* Waiting thread: */
wait_for_completion(&done);

/* Signaling thread: */
complete(&done);     /* wake one waiter */
complete_all(&done); /* wake all waiters */
```
[Intermediate]

Q: What is a wait queue?
A: Queue for threads waiting for a condition:
```c
wait_queue_head_t wq;
init_waitqueue_head(&wq);

/* Wait: */
wait_event(wq, condition);
wait_event_interruptible(wq, condition);

/* Wake: */
wake_up(&wq);
wake_up_interruptible(&wq);
```
[Intermediate]

Q: What is the difference between wake_up variants?
A: - `wake_up(&wq)` - wake all TASK_UNINTERRUPTIBLE and TASK_INTERRUPTIBLE
- `wake_up_interruptible(&wq)` - wake only TASK_INTERRUPTIBLE
- `wake_up_all(&wq)` - wake ALL waiters
- `wake_up_nr(&wq, n)` - wake N waiters
[Intermediate]

Q: What is a reader-writer lock (rwlock)?
A: Allows multiple readers OR one writer:
```c
rwlock_t lock;
rwlock_init(&lock);

read_lock(&lock);
/* read data */
read_unlock(&lock);

write_lock(&lock);
/* modify data */
write_unlock(&lock);
```
[Intermediate]

Q: What is a seqlock?
A: Optimized for read-mostly with occasional writes:
```c
seqlock_t lock;
seqlock_init(&lock);

/* Writer: */
write_seqlock(&lock);
/* modify */
write_sequnlock(&lock);

/* Reader: */
unsigned seq;
do {
    seq = read_seqbegin(&lock);
    /* read data */
} while (read_seqretry(&lock, seq));
```
[Advanced]

Q: What is the deadlock rule for nested locks?
A: Always acquire locks in consistent order:
```c
/* Thread 1: */          /* Thread 2: */
lock(A);                 lock(B);
lock(B);  /* deadlock */ lock(A); /* deadlock */
```
Define a lock ordering and always follow it.
[Intermediate]

Q: What is `lockdep`?
A: Kernel lock validator that detects:
1) Potential deadlocks (lock ordering violations)
2) Incorrect lock usage (wrong context)
3) Circular dependencies
Enable with `CONFIG_PROVE_LOCKING`. Reports issues at runtime.
[Intermediate]

Q: What is preemption and how does it relate to locking?
A: Preemption allows one task to interrupt another:
```c
preempt_disable();
/* cannot be preempted */
preempt_enable();
```
Spinlocks implicitly disable preemption. Needed for per-CPU data access.
[Intermediate]

Q: (Summary Table) When to use each primitive?
A: | Primitive | Sleeps | Context | Use Case |
|-----------|--------|---------|----------|
| Spinlock | No | Any | Short critical section |
| Mutex | Yes | Process | Longer critical section |
| Semaphore | Yes | Process | Resource counting |
| Atomic | No | Any | Simple counters |
| RCU | No | Any | Read-heavy data |
| Completion | Yes | Process | One-shot sync |
[Intermediate]

---

## Section 14: PCI Subsystem

Q: What is PCI?
A: Peripheral Component Interconnect - a standard bus for expansion cards:
1) Self-describing (enumerable)
2) Devices have configuration space with IDs
3) Supports multiple memory/IO regions
4) Interrupt support (legacy INTx and MSI)
5) Plug and play capable
[Basic]

Q: How does PCI device identification work?
A: Vendor ID + Device ID uniquely identify device type:
- **Vendor ID**: 16-bit, assigned by PCI-SIG (e.g., 0x8086 = Intel)
- **Device ID**: 16-bit, assigned by vendor
- **Subsystem Vendor/Device**: Further differentiation
- **Class code**: Device category (network, storage, etc.)
[Basic]

Q: What is `struct pci_dev`?
A: Represents a PCI device:
```c
struct pci_dev {
    struct device dev;          /* base device */
    unsigned int devfn;         /* device + function */
    unsigned short vendor;
    unsigned short device;
    unsigned short subsystem_vendor;
    unsigned short subsystem_device;
    unsigned int class;         /* class code */
    struct resource resource[PCI_NUM_RESOURCES];
    unsigned int irq;
    /* ... */
};
```
[Intermediate]

Q: What is `struct pci_driver`?
A: Represents a PCI driver:
```c
struct pci_driver {
    struct list_head node;
    const char *name;
    const struct pci_device_id *id_table;  /* device IDs */
    int (*probe)(struct pci_dev *, const struct pci_device_id *);
    void (*remove)(struct pci_dev *);
    void (*shutdown)(struct pci_dev *);
    struct device_driver driver;
    /* ... PM callbacks ... */
};
```
[Intermediate]

Q: What is `struct pci_device_id`?
A: Matching table entry:
```c
struct pci_device_id {
    u32 vendor, device;           /* or PCI_ANY_ID */
    u32 subvendor, subdevice;     /* or PCI_ANY_ID */
    u32 class, class_mask;
    kernel_ulong_t driver_data;   /* private data */
};
```
Kernel matches against this to find driver.
[Intermediate]

Q: How do you define a PCI device ID table?
A: ```c
static const struct pci_device_id my_pci_ids[] = {
    { PCI_DEVICE(0x8086, 0x1234) },
    { PCI_DEVICE(0x8086, 0x5678) },
    { PCI_DEVICE_CLASS(PCI_CLASS_NETWORK_ETHERNET << 8, ~0) },
    { 0, }  /* terminator */
};
MODULE_DEVICE_TABLE(pci, my_pci_ids);
```
[Intermediate]

Q: How do you register a PCI driver?
A: Use `pci_register_driver()`:
```c
static struct pci_driver my_driver = {
    .name = "my_pci_driver",
    .id_table = my_pci_ids,
    .probe = my_probe,
    .remove = my_remove,
};
pci_register_driver(&my_driver);
/* or module_pci_driver(my_driver); */
```
[Basic]

Q: What is `module_pci_driver()` macro?
A: Convenience macro generating init/exit:
```c
module_pci_driver(my_driver);
```
Expands to `module_init/exit` calling `pci_register_driver/pci_unregister_driver`.
[Basic]

Q: What is `pci_enable_device()`?
A: Enables a PCI device:
```c
int ret = pci_enable_device(pdev);
```
Must be called before accessing resources:
1) Wakes device from D3
2) Enables I/O and memory space
3) Sets bus master if needed
[Intermediate]

Q: What is the typical PCI probe sequence?
A: ```c
int my_probe(struct pci_dev *pdev, const struct pci_device_id *id) {
    pci_enable_device(pdev);
    pci_request_regions(pdev, "mydrv");
    base = pci_iomap(pdev, 0, 0);  /* BAR 0 */
    pci_set_master(pdev);          /* for DMA */
    /* initialize device */
    pci_set_drvdata(pdev, priv);
    return 0;
}
```
[Intermediate]

Q: What is a BAR (Base Address Register)?
A: BARs define PCI resource regions:
- BAR 0-5 in configuration space
- Each maps memory or I/O range
- Size programmed by system BIOS
```c
resource_size_t base = pci_resource_start(pdev, bar);
resource_size_t len = pci_resource_len(pdev, bar);
unsigned long flags = pci_resource_flags(pdev, bar);
```
[Intermediate]

Q: How do you access PCI memory regions?
A: ```c
/* Request exclusive access */
pci_request_region(pdev, bar, "mydrv");

/* Map into kernel address space */
void __iomem *base = pci_iomap(pdev, bar, 0);

/* Access via readl/writel */
u32 val = readl(base + REG_OFFSET);
writel(val, base + REG_OFFSET);

/* Cleanup */
pci_iounmap(pdev, base);
pci_release_region(pdev, bar);
```
[Intermediate]

Q: What is `pci_set_master()`?
A: Enables PCI bus mastering (DMA):
```c
pci_set_master(pdev);
```
Sets the Bus Master Enable bit. Required before device can initiate DMA transfers.
[Intermediate]

Q: How do you read/write PCI configuration space?
A: ```c
u8 val8;
u16 val16;
u32 val32;

pci_read_config_byte(pdev, offset, &val8);
pci_read_config_word(pdev, offset, &val16);
pci_read_config_dword(pdev, offset, &val32);

pci_write_config_byte(pdev, offset, val8);
pci_write_config_word(pdev, offset, val16);
pci_write_config_dword(pdev, offset, val32);
```
[Intermediate]

Q: What is MSI (Message Signaled Interrupts)?
A: Modern interrupt mechanism:
- Interrupts via memory writes (no IRQ lines)
- Can have multiple interrupt vectors
- Better performance than legacy INTx
```c
pci_enable_msi(pdev);       /* single MSI */
pci_enable_msix_range(pdev, entries, min, max); /* MSI-X */
```
[Intermediate]

Q: How do you enable MSI-X interrupts?
A: ```c
struct msix_entry entries[N];
int i;
for (i = 0; i < N; i++)
    entries[i].entry = i;

int nvec = pci_enable_msix_range(pdev, entries, 1, N);
if (nvec < 0)
    return nvec;

/* Request each vector */
for (i = 0; i < nvec; i++)
    request_irq(entries[i].vector, handler, 0, "mydrv", data);
```
[Advanced]

Q: What is the typical PCI remove sequence?
A: ```c
void my_remove(struct pci_dev *pdev) {
    struct my_priv *priv = pci_get_drvdata(pdev);
    
    /* Disable device operations */
    /* Free IRQs */
    free_irq(pdev->irq, priv);
    pci_disable_msi(pdev);
    
    /* Unmap and release regions */
    pci_iounmap(pdev, priv->base);
    pci_release_regions(pdev);
    pci_disable_device(pdev);
    
    kfree(priv);
}
```
[Intermediate]

Q: What is PCI device naming convention?
A: `DDDD:BB:SS.F`:
- **DDDD** - Domain (usually 0000)
- **BB** - Bus number (00-FF)
- **SS** - Slot/Device (00-1F)
- **F** - Function (0-7)
Example: `0000:00:1f.3` = domain 0, bus 0, slot 31, function 3
[Basic]

Q: Where do PCI devices appear in sysfs?
A: ```
/sys/devices/pci0000:00/
    0000:00:1f.0/
        vendor          (0x8086)
        device          (0x1234)
        class           (0x020000)
        resource        (memory regions)
        driver -> ../../../bus/pci/drivers/my_driver
/sys/bus/pci/
    devices/
        0000:00:1f.0 -> ...
    drivers/
        my_driver/
```
[Basic]

Q: What is `/proc/bus/pci` and `lspci`?
A: PCI information interfaces:
- `/proc/bus/pci/` - raw config space access (legacy)
- `lspci` - command to list PCI devices
```bash
lspci -v              # verbose listing
lspci -nn             # show vendor/device IDs
lspci -s 00:1f.0 -xxx # hex dump config space
```
[Basic]

---

## Section 15: USB Subsystem

Q: What is USB?
A: Universal Serial Bus - host-controlled external bus:
1) Enumerable (host discovers devices)
2) Tiered star topology (hubs)
3) Hot-pluggable
4) Multiple speeds (Low/Full/High/Super)
5) Standardized device classes
[Basic]

Q: What is `struct usb_device`?
A: Represents a USB device:
```c
struct usb_device {
    int devnum;                    /* address on bus */
    struct usb_device *parent;     /* hub */
    struct usb_bus *bus;
    struct device dev;             /* embedded device */
    struct usb_device_descriptor descriptor;
    struct usb_host_config *config;
    /* ... */
};
```
[Intermediate]

Q: What is `struct usb_driver`?
A: USB device driver structure:
```c
struct usb_driver {
    const char *name;
    int (*probe)(struct usb_interface *intf,
                 const struct usb_device_id *id);
    void (*disconnect)(struct usb_interface *intf);
    const struct usb_device_id *id_table;
    struct device_driver driver;
    /* ... suspend/resume ... */
};
```
Note: Binds to interface, not device.
[Intermediate]

Q: What is a USB interface vs configuration?
A: - **Configuration**: Device operating mode (usually one active)
- **Interface**: Logical function within configuration
- **Endpoint**: Communication channel within interface

Device → Configuration(s) → Interface(s) → Endpoint(s)
Drivers bind to interfaces, not whole devices.
[Intermediate]

Q: What is `struct usb_device_id`?
A: Matching table entry:
```c
struct usb_device_id {
    u16 match_flags;
    u16 idVendor, idProduct;
    u16 bcdDevice_lo, bcdDevice_hi;
    u8 bDeviceClass, bDeviceSubClass, bDeviceProtocol;
    u8 bInterfaceClass, bInterfaceSubClass, bInterfaceProtocol;
    kernel_ulong_t driver_info;
};
```
[Intermediate]

Q: How do you define a USB device ID table?
A: ```c
static const struct usb_device_id my_ids[] = {
    { USB_DEVICE(0x1234, 0x5678) },          /* vendor, product */
    { USB_DEVICE_INFO(class, subclass, proto) },
    { USB_INTERFACE_INFO(class, subclass, proto) },
    { }  /* terminator */
};
MODULE_DEVICE_TABLE(usb, my_ids);
```
[Intermediate]

Q: How do you register a USB driver?
A: ```c
static struct usb_driver my_driver = {
    .name = "my_usb_driver",
    .id_table = my_ids,
    .probe = my_probe,
    .disconnect = my_disconnect,
};
usb_register(&my_driver);
/* or module_usb_driver(my_driver); */
```
[Basic]

Q: What is a URB (USB Request Block)?
A: The fundamental USB I/O unit:
```c
struct urb {
    struct usb_device *dev;
    unsigned int pipe;      /* endpoint descriptor */
    void *transfer_buffer;
    u32 transfer_buffer_length;
    usb_complete_t complete; /* completion callback */
    void *context;          /* private data */
    int status;             /* result */
    /* ... */
};
```
[Intermediate]

Q: What are the USB transfer types?
A: - **Control**: Configuration/commands (endpoint 0)
- **Bulk**: Large, reliable data (printers, storage)
- **Interrupt**: Small, periodic (keyboards, mice)
- **Isochronous**: Streaming, no retry (audio, video)
[Basic]

Q: How do you create and submit a URB?
A: ```c
struct urb *urb = usb_alloc_urb(0, GFP_KERNEL);

usb_fill_bulk_urb(urb, dev, pipe,
                  buffer, len,
                  complete_fn, context);

usb_submit_urb(urb, GFP_KERNEL);
/* completion callback called when done */

/* cleanup: */
usb_free_urb(urb);
```
[Intermediate]

Q: What is a USB pipe?
A: Encoded endpoint address and type:
```c
unsigned int pipe;
pipe = usb_sndbulkpipe(dev, ep_addr);  /* bulk out */
pipe = usb_rcvbulkpipe(dev, ep_addr);  /* bulk in */
pipe = usb_sndctrlpipe(dev, 0);        /* control out */
pipe = usb_rcvctrlpipe(dev, 0);        /* control in */
pipe = usb_sndintpipe(dev, ep_addr);   /* interrupt out */
pipe = usb_rcvintpipe(dev, ep_addr);   /* interrupt in */
```
[Intermediate]

Q: What are synchronous USB helpers?
A: Simpler API without explicit URBs:
```c
usb_control_msg(dev, pipe, request, type, value, index,
                data, size, timeout);
usb_bulk_msg(dev, pipe, data, len, &actual, timeout);
usb_interrupt_msg(dev, pipe, data, len, &actual, timeout);
```
Block until complete - use for simple cases.
[Intermediate]

Q: What is USB device naming convention?
A: `X-Y.Z...`:
- `X` - bus number
- `Y` - port on root hub
- `.Z` - port on hub (chained)
Example: `1-2.4` = bus 1, root hub port 2, hub port 4
Interface: `1-2.4:1.0` (config 1, interface 0)
[Basic]

Q: Where do USB devices appear in sysfs?
A: ```
/sys/devices/pci0000:00/.../usb1/
    1-2/                    (device)
        idVendor
        idProduct
        1-2:1.0/            (interface)
            driver -> .../drivers/my_driver
/sys/bus/usb/
    devices/
    drivers/
```
[Basic]

Q: What is `lsusb` command?
A: Lists USB devices:
```bash
lsusb                    # brief listing
lsusb -v                 # verbose
lsusb -t                 # tree view
lsusb -d 1234:5678       # specific device
lsusb -s 001:002         # bus:device
```
[Basic]

---

## Section 16: Power Management

Q: What is device power management?
A: Managing device power states to save energy:
1) System sleep (suspend to RAM/disk)
2) Runtime PM (idle device suspension)
3) Clock/regulator gating
4) Device-specific power states
Integrated with device model hierarchy.
[Basic]

Q: What are the standard power states?
A: - **D0**: Full power, fully operational
- **D1, D2**: Intermediate low-power (optional)
- **D3hot**: Low power, context may be lost
- **D3cold**: Off, no power, context lost

Higher number = less power, more latency to wake.
[Intermediate]

Q: What is `struct dev_pm_ops`?
A: Power management callbacks:
```c
struct dev_pm_ops {
    int (*prepare)(struct device *dev);
    void (*complete)(struct device *dev);
    int (*suspend)(struct device *dev);
    int (*resume)(struct device *dev);
    int (*freeze)(struct device *dev);
    int (*thaw)(struct device *dev);
    int (*runtime_suspend)(struct device *dev);
    int (*runtime_resume)(struct device *dev);
    int (*runtime_idle)(struct device *dev);
    /* ... */
};
```
[Intermediate]

Q: How do you provide PM ops in a driver?
A: Via bus-specific or dev_pm_ops:
```c
static const struct dev_pm_ops my_pm_ops = {
    .suspend = my_suspend,
    .resume = my_resume,
    .runtime_suspend = my_runtime_suspend,
    .runtime_resume = my_runtime_resume,
};

static struct platform_driver my_driver = {
    .driver = {
        .pm = &my_pm_ops,
    },
};
```
[Intermediate]

Q: What is the suspend callback responsible for?
A: Prepare device for system sleep:
```c
int my_suspend(struct device *dev) {
    struct my_priv *priv = dev_get_drvdata(dev);
    
    disable_irq(priv->irq);      /* stop interrupts */
    /* save device state */
    /* put device in low power state */
    return 0;
}
```
Return 0 on success, negative on error.
[Intermediate]

Q: What is the resume callback responsible for?
A: Restore device after system sleep:
```c
int my_resume(struct device *dev) {
    struct my_priv *priv = dev_get_drvdata(dev);
    
    /* restore device state */
    /* re-initialize hardware */
    enable_irq(priv->irq);
    return 0;
}
```
[Intermediate]

Q: What is Runtime PM?
A: Per-device power management while system runs:
1) Idle devices automatically suspend
2) Resume on access
3) Controlled via pm_runtime_* API
4) Independent of system sleep
[Intermediate]

Q: What are key Runtime PM functions?
A: ```c
pm_runtime_enable(dev);         /* enable runtime PM */
pm_runtime_disable(dev);        /* disable */

pm_runtime_get(dev);            /* increment usage, may resume */
pm_runtime_get_sync(dev);       /* sync version */
pm_runtime_put(dev);            /* decrement usage, may suspend */
pm_runtime_put_sync(dev);

pm_runtime_set_active(dev);     /* mark as active */
pm_runtime_set_autosuspend_delay(dev, ms);
```
[Intermediate]

Q: How does Runtime PM usage counting work?
A: Reference-counting model:
- `pm_runtime_get()` - increment count, wake if needed
- `pm_runtime_put()` - decrement count, suspend if zero
```c
pm_runtime_get_sync(dev);
/* use device */
pm_runtime_put(dev);
```
Keep count > 0 while device needed.
[Intermediate]

Q: What is autosuspend in Runtime PM?
A: Delayed automatic suspension:
```c
pm_runtime_set_autosuspend_delay(dev, 2000); /* 2 sec */
pm_runtime_use_autosuspend(dev);

/* Instead of put: */
pm_runtime_put_autosuspend(dev);
```
Device stays active for delay period after last put.
[Intermediate]

Q: What sysfs files control Runtime PM?
A: In `/sys/devices/.../power/`:
```
control     - "auto" or "on" (enable/disable runtime PM)
runtime_status - "active", "suspended", "suspending"
autosuspend_delay_ms - autosuspend timeout
```
[Basic]

Q: What is the PM callback order during suspend?
A: 1) `prepare()` - prepare device (can return error)
2) `suspend()` - suspend device
3) `suspend_late()` - late suspend
4) `suspend_noirq()` - no-IRQ stage (IRQs disabled)
Children suspend before parents.
[Intermediate]

Q: What is the PM callback order during resume?
A: 1) `resume_noirq()` - no-IRQ stage
2) `resume_early()` - early resume
3) `resume()` - resume device
4) `complete()` - cleanup
Parents resume before children.
[Intermediate]

Q: What are `SIMPLE_DEV_PM_OPS` and related macros?
A: Convenience macros for common patterns:
```c
SIMPLE_DEV_PM_OPS(my_pm, my_suspend, my_resume);
/* creates struct dev_pm_ops with suspend/resume */

SET_SYSTEM_SLEEP_PM_OPS(suspend, resume)
SET_RUNTIME_PM_OPS(suspend, resume, idle)
```
[Intermediate]

Q: (Cloze) In the device hierarchy, _____ suspend before parents and parents _____ before children.
A: In the device hierarchy, **children** suspend before parents and parents **resume** before children.
[Basic]

---

## Section 17: Error Handling and Debugging

Q: What is `printk()` and its log levels?
A: Kernel's printf - outputs to kernel log:
```c
printk(KERN_ERR "Error: %d\n", err);
printk(KERN_INFO "Info message\n");
printk(KERN_DEBUG "Debug: val=%d\n", val);
```
Levels: EMERG, ALERT, CRIT, ERR, WARNING, NOTICE, INFO, DEBUG
[Basic]

Q: What are the `pr_*` convenience macros?
A: Simplified printk with level prefix:
```c
pr_err("Error: %d\n", err);    /* KERN_ERR */
pr_warn("Warning\n");           /* KERN_WARNING */
pr_info("Info\n");              /* KERN_INFO */
pr_debug("Debug\n");            /* KERN_DEBUG */
pr_cont("continued...");        /* continue line */
```
Defined in `<linux/printk.h>`.
[Basic]

Q: What are the `dev_*` device macros?
A: Device-aware logging (prefixes with device name):
```c
dev_err(dev, "Failed: %d\n", err);
dev_warn(dev, "Warning\n");
dev_info(dev, "Info\n");
dev_dbg(dev, "Debug\n");
```
Output: `mydevice 0000:00:1f.0: Failed: -5`
[Basic]

Q: When should you use dev_* vs pr_* vs printk?
A: - `dev_*` - in driver code with device reference (preferred)
- `pr_*` - module/subsystem code without device
- Raw `printk` - rarely needed
`dev_*` includes device path, making logs easier to trace.
[Basic]

Q: How do you enable DEBUG level messages?
A: Multiple ways:
```c
/* In source file, before includes: */
#define DEBUG

/* Or compile with: */
CFLAGS += -DDEBUG

/* Or enable dynamic debug: */
echo 'module mymod +p' > /sys/kernel/debug/dynamic_debug/control
```
[Intermediate]

Q: What is the error pointer convention?
A: Encode errors in pointers:
```c
void *ptr = some_alloc_function();
if (IS_ERR(ptr)) {
    int err = PTR_ERR(ptr);
    return err;
}
/* ptr is valid */

/* To return error: */
return ERR_PTR(-ENOMEM);
```
[Intermediate]

Q: What are `IS_ERR`, `PTR_ERR`, `ERR_PTR`?
A: Error pointer macros:
```c
void *ERR_PTR(long error);      /* int → error pointer */
long PTR_ERR(const void *ptr);  /* error pointer → int */
bool IS_ERR(const void *ptr);   /* check if error */
bool IS_ERR_OR_NULL(ptr);       /* error OR null */
```
Valid pointers have top bits clear; error pointers don't.
[Intermediate]

Q: What is `WARN_ON()` and `BUG_ON()`?
A: Assertion macros:
```c
WARN_ON(condition);    /* log warning + stack trace if true */
WARN_ON_ONCE(cond);    /* warn only first time */

BUG_ON(condition);     /* panic if true - use sparingly */
BUG();                 /* unconditional panic */
```
`WARN_ON` preferred over `BUG_ON` - doesn't crash system.
[Intermediate]

Q: What is a kernel oops?
A: Error condition that doesn't crash kernel:
- NULL pointer dereference
- Invalid memory access
- Reports CPU state, registers, call trace
- Process killed, kernel continues (maybe unstable)
```
Oops: 0002 [#1] SMP
...
Call Trace:
 my_function+0x42/0x100
```
[Basic]

Q: What is a kernel panic?
A: Unrecoverable error - system halts:
- Triggered by `panic()` or critical oops
- BUG_ON() can cause panic
- System unusable, requires reboot
Configure via `panic=` boot parameter.
[Basic]

Q: What is `/proc/interrupts` for?
A: Shows interrupt statistics:
```
           CPU0       CPU1
  0:         45          0   IO-APIC-edge      timer
  8:          0          0   IO-APIC-edge      rtc0
 16:      12394          0   IO-APIC-fasteoi   ehci_hcd
```
Per-CPU counts, type, registered handlers.
[Basic]

Q: What is `/proc/iomem` and `/proc/ioports`?
A: Show I/O resource allocation:
```
/proc/iomem - memory-mapped I/O regions
00000000-00000fff : reserved
e0000000-efffffff : PCI Bus 0000:00
  e0000000-e0ffffff : 0000:00:02.0

/proc/ioports - I/O port regions (x86)
0000-0cf7 : PCI Bus 0000:00
  0060-0060 : keyboard
```
[Basic]

Q: What is dynamic debug?
A: Runtime control of debug messages:
```bash
# Enable all debug in module
echo 'module mymod +p' > /sys/kernel/debug/dynamic_debug/control

# Enable in specific file
echo 'file myfile.c +p' > /sys/kernel/debug/dynamic_debug/control

# Disable
echo 'module mymod -p' > ...
```
No recompile needed. Requires `CONFIG_DYNAMIC_DEBUG`.
[Intermediate]

Q: What kernel config options help debugging drivers?
A: ```
CONFIG_DEBUG_KERNEL=y           # enable debug features
CONFIG_DEBUG_INFO=y             # debug symbols
CONFIG_DYNAMIC_DEBUG=y          # dynamic debug
CONFIG_PROVE_LOCKING=y          # lockdep
CONFIG_DEBUG_OBJECTS=y          # object debugging
CONFIG_KASAN=y                  # address sanitizer
CONFIG_DEBUG_DRIVER=y           # driver core debug
```
[Intermediate]

Q: What is ftrace for driver debugging?
A: Function tracer built into kernel:
```bash
# Trace function calls
echo function > /sys/kernel/debug/tracing/current_tracer
echo my_driver_* > /sys/kernel/debug/tracing/set_ftrace_filter
echo 1 > /sys/kernel/debug/tracing/tracing_on
cat /sys/kernel/debug/tracing/trace
```
Shows call sequences, timing.
[Advanced]

---

## Summary

This flashcard set covers the Linux Kernel v3.2 Device Driver Framework:
- **Foundations**: Modules, kobjects, sysfs
- **Unified Device Model**: Bus/device/driver, binding, hierarchy, uevent, classes
- **Device Types**: Platform, character devices
- **Hardware Access**: Memory, I/O, interrupts, DMA
- **Synchronization**: Locks, atomics, wait queues
- **Subsystems**: PCI, USB
- **Power & Debug**: PM, error handling, debugging tools

Total cards: ~380

