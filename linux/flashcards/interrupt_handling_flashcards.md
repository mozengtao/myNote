# Linux Kernel Interrupt Handling Flashcards (v3.2)

A comprehensive collection of Anki-style flashcards covering interrupt handling in the Linux kernel version 3.2.

---

## Section 1: Interrupt Fundamentals

Q: What is an interrupt in the context of computer systems?
A: An interrupt is an asynchronous signal from hardware or software that causes the CPU to stop its current execution, save its state, and jump to a predefined handler routine to service the event. After handling, the CPU resumes the interrupted task.
[Basic]

Q: What are the two fundamental approaches for a CPU to detect external events?
A: 1) **Polling**: CPU continuously checks device status in a loop (wastes CPU cycles)
2) **Interrupts**: Device signals the CPU only when attention is needed (efficient, event-driven)
[Basic]

Q: Why are interrupts preferred over polling for I/O operations?
A: Interrupts allow the CPU to perform useful work instead of busy-waiting. The CPU is notified only when an event occurs, improving system throughput and reducing power consumption. Polling wastes CPU cycles checking devices that may have nothing to report.
[Basic]

Q: {{c1::Synchronous}} interrupts are caused by the CPU itself during instruction execution, while {{c2::asynchronous}} interrupts are generated by external hardware devices.
A: Synchronous (exceptions) - triggered by CPU errors or special instructions; Asynchronous (hardware interrupts) - triggered by external devices independent of CPU execution.
[Basic]

Q: What is the difference between a hardware interrupt and a software interrupt (exception)?
A: **Hardware interrupt**: Generated by external devices (keyboard, disk, NIC) asynchronously to CPU execution.
**Software interrupt/Exception**: Generated synchronously by the CPU itself due to errors (page fault, divide by zero) or explicit instructions (INT, SYSCALL).
[Basic]

Q: What is an IRQ (Interrupt Request)?
A: An IRQ is a hardware signal sent by a device to the interrupt controller to request the CPU's attention. Each IRQ line is assigned a number that maps to a specific interrupt vector, which determines which handler routine to execute.
[Basic]

Q: What is an interrupt vector?
A: An interrupt vector is an index into the Interrupt Descriptor Table (IDT) that identifies which handler routine should be invoked for a specific interrupt. On x86, vectors 0-255 are available, with 0-31 reserved for CPU exceptions.
[Basic]

Q: What is the Interrupt Descriptor Table (IDT)?
A: The IDT is a CPU data structure that maps interrupt vector numbers to their corresponding handler addresses. When an interrupt occurs, the CPU uses the vector number as an index into the IDT to find and jump to the appropriate handler.
[Basic]

Q: Describe the basic CPU-level flow when a hardware interrupt occurs.
A: 1) Device asserts IRQ line
2) Interrupt controller signals CPU
3) CPU finishes current instruction
4) CPU pushes EFLAGS, CS, EIP onto stack
5) CPU clears IF flag (disables further interrupts)
6) CPU reads vector from interrupt controller
7) CPU looks up handler in IDT
8) CPU jumps to handler entry point
[Intermediate]

Q: What registers are automatically saved by the x86 CPU when an interrupt occurs?
A: The CPU automatically pushes onto the stack:
- EFLAGS (processor flags)
- CS (code segment)
- EIP (instruction pointer)
- Error code (for some exceptions only)
If a privilege level change occurs, SS and ESP are also saved.
[Intermediate]

Q: What is interrupt context in the Linux kernel?
A: Interrupt context is the execution environment when the kernel is running an interrupt handler. Code running in interrupt context:
- Cannot sleep or block
- Cannot call schedule()
- Has no backing process (current is undefined/borrowed)
- Must execute quickly
- Uses a separate interrupt stack
[Basic]

Q: What is process context in the Linux kernel?
A: Process context is when the kernel executes on behalf of a specific process (via system call or exception). Code in process context:
- Can sleep and block
- Can access current process's address space
- current macro points to the running task
- Can use full kernel APIs including blocking functions
[Basic]

Q: Why must interrupt handlers execute as quickly as possible?
A: 1) Interrupts preempt other code, including other interrupt handlers
2) While in interrupt context, the interrupted process cannot run
3) Long handlers increase interrupt latency for other devices
4) Sleeping is forbidden, limiting available operations
5) System responsiveness degrades with long handlers
[Basic]

Q: What is interrupt latency?
A: Interrupt latency is the time between when a device asserts an interrupt and when the corresponding handler begins executing. It includes: interrupt controller propagation delay, CPU instruction completion time, context save time, and any time interrupts were disabled.
[Basic]

Q: Can an interrupt handler sleep? Why or why not?
A: No, interrupt handlers cannot sleep because:
1) There's no process context to schedule away from
2) The `current` pointer doesn't represent a schedulable entity
3) Sleeping would leave the interrupt in an undefined state
4) The scheduler cannot safely switch away from interrupt context
[Basic]

Q: What is the "top half" of interrupt handling?
A: The top half is the interrupt handler registered with request_irq() that runs immediately in response to the hardware interrupt. It runs with interrupts disabled (or at elevated priority), must be fast, and typically acknowledges the hardware and schedules deferred work.
[Basic]

Q: What is the "bottom half" of interrupt handling?
A: The bottom half is deferred work scheduled by the top half to be executed later in a safer context. It handles time-consuming processing that doesn't need to run immediately. Mechanisms include softirqs, tasklets, and workqueues.
[Basic]

Q: Why is interrupt handling split into top half and bottom half?
A: To minimize time spent with interrupts disabled. The top half quickly acknowledges hardware and captures essential data, then schedules the bottom half. This reduces interrupt latency for other devices and improves system responsiveness.
[Intermediate]

Q: What happens if an interrupt handler takes too long to execute?
A: 1) Other interrupts may be delayed (increased latency)
2) System responsiveness degrades
3) Watchdog timers may trigger
4) Real-time deadlines may be missed
5) In extreme cases, data loss from missed interrupts
[Intermediate]

Q: What is interrupt nesting?
A: Interrupt nesting occurs when a higher-priority interrupt preempts a currently executing interrupt handler. Linux traditionally allowed nesting on x86 (by re-enabling interrupts), but modern kernels tend toward running handlers with interrupts disabled to simplify locking.
[Intermediate]

Q: What does the term "interrupt storm" mean?
A: An interrupt storm is when a device generates interrupts at an extremely high rate, consuming most or all CPU time servicing interrupts. This can starve user processes and other kernel work, potentially making the system unresponsive. Common causes include misconfigured hardware or driver bugs.
[Intermediate]

Q: Draw an ASCII diagram showing the basic interrupt flow from device to handler.
A:
```
  Device          Interrupt         CPU              Memory
    |             Controller         |                  |
    |---IRQ line--->|                |                  |
    |               |--INT signal--->|                  |
    |               |                |--save context--->|
    |               |<--ACK/vector---|                  |
    |               |                |--read IDT------->|
    |               |                |<--handler addr---|
    |               |                |                  |
    |               |                |==jump to handler=|
```
[Basic]

Q: What is the relationship between IRQ numbers and interrupt vectors on x86?
A: IRQ numbers (from the interrupt controller) are mapped to interrupt vectors (IDT indices). Vectors 0-31 are reserved for CPU exceptions. Hardware IRQs are typically mapped starting at vector 32. The mapping can be configured by the interrupt controller setup.
[Intermediate]

Q: What is an edge-triggered interrupt?
A: An edge-triggered interrupt is signaled by a transition (rising or falling edge) on the IRQ line. The interrupt controller latches the event when the edge occurs. If the handler doesn't clear the interrupt source, subsequent edges will still trigger new interrupts.
[Intermediate]

Q: What is a level-triggered interrupt?
A: A level-triggered interrupt is signaled by holding the IRQ line at a particular logic level (usually low). The interrupt remains asserted as long as the line is held. The handler must clear the interrupt source in the device, or the interrupt will immediately re-trigger.
[Intermediate]

Q: Compare edge-triggered vs level-triggered interrupts.
A: **Edge-triggered**:
- Triggered on signal transition
- Can miss interrupts if line stays asserted
- Easier interrupt sharing issues
**Level-triggered**:
- Triggered while signal held at level
- Self-correcting (re-triggers if not cleared)
- Better for shared interrupts
- Requires device acknowledgment
[Intermediate]

---

## Section 2: x86 Interrupt Architecture

Q: What is the structure of an IDT entry (gate descriptor) on x86?
A: An IDT gate descriptor is 8 bytes containing:
- Offset (bits 0-15, 48-63): Handler address
- Segment Selector (bits 16-31): Code segment for handler
- Type (bits 40-43): Gate type (interrupt/trap/task)
- DPL (bits 45-46): Descriptor Privilege Level
- P (bit 47): Present bit
[Intermediate]

Q: What are the three types of gates in the x86 IDT?
A: 1) **Interrupt Gate**: Clears IF flag (disables interrupts) on entry
2) **Trap Gate**: Does NOT clear IF flag (interrupts remain enabled)
3) **Task Gate**: Causes a hardware task switch (rarely used in Linux)
Linux uses interrupt gates for hardware interrupts and trap gates for most exceptions.
[Intermediate]

Q: What is the key difference between an interrupt gate and a trap gate?
A: An interrupt gate automatically clears the IF (Interrupt Flag) in EFLAGS when entered, disabling further maskable interrupts. A trap gate leaves IF unchanged, allowing nested interrupts. Linux uses interrupt gates for hardware IRQs.
[Intermediate]

Q: What is the 8259A PIC (Programmable Interrupt Controller)?
A: The 8259A is the legacy interrupt controller used in original IBM PCs. It provides 8 IRQ lines per chip, with two cascaded chips providing 15 usable IRQs (IRQ2 used for cascade). It has fixed priority levels and is programmed via I/O ports 0x20-0x21 and 0xA0-0xA1.
[Intermediate]

Q: Draw an ASCII diagram of the cascaded 8259A PIC architecture.
A:
```
                 Master PIC              Slave PIC
                 (8259A)                 (8259A)
IRQ0 (Timer)  -->|        |    IRQ8  -->|        |
IRQ1 (Keyboard)->|        |    IRQ9  -->|        |
IRQ2 (Cascade)-->|  INT   |<---|  INT   |<--IRQ10
IRQ3 (COM2)   -->|        |    IRQ11 -->|        |
IRQ4 (COM1)   -->|  to    |    IRQ12 -->|        |
IRQ5 (LPT2)   -->|  CPU   |    IRQ13 -->|        |
IRQ6 (Floppy) -->|        |    IRQ14 -->|        |
IRQ7 (LPT1)   -->|        |    IRQ15 -->|        |
```
[Intermediate]

Q: What is APIC and why was it introduced?
A: APIC (Advanced Programmable Interrupt Controller) replaced the 8259A to support SMP systems. It provides:
- More interrupt lines (24+ per I/O APIC)
- Per-CPU local APICs (LAPIC)
- Programmable interrupt routing to specific CPUs
- Inter-Processor Interrupts (IPI)
- MSI support
[Intermediate]

Q: What is the difference between LAPIC and I/O APIC?
A: **LAPIC (Local APIC)**: Built into each CPU core, handles:
- Local timer interrupts
- IPI reception/transmission
- Interrupt prioritization
**I/O APIC**: External chip on motherboard, handles:
- External device IRQ routing
- Distributing interrupts to LAPICs
[Intermediate]

Q: What is the LAPIC timer used for in Linux?
A: The LAPIC timer provides a per-CPU local timer interrupt used for:
- Scheduler tick on each CPU
- Local timer events
- CPU-specific timing needs
It's programmed via memory-mapped registers and can operate in one-shot or periodic mode.
[Intermediate]

Q: What are Inter-Processor Interrupts (IPIs)?
A: IPIs are interrupts that one CPU sends to another CPU in an SMP system. Used for:
- TLB shootdowns (invalidate remote TLB entries)
- Rescheduling notifications
- Function call requests (smp_call_function)
- System halt/reboot
Sent via the LAPIC.
[Intermediate]

Q: How does the I/O APIC route interrupts to specific CPUs?
A: Each I/O APIC pin has a 64-bit redirection table entry specifying:
- Destination mode (physical or logical)
- Destination CPU(s) - APIC ID or logical group
- Delivery mode (fixed, lowest priority, NMI, etc.)
- Vector number
- Trigger mode (edge/level)
[Advanced]

Q: What is the EFLAGS IF (Interrupt Flag) bit?
A: The IF bit in the EFLAGS register controls whether the CPU responds to maskable hardware interrupts:
- IF=1: Interrupts enabled (can be interrupted)
- IF=0: Interrupts disabled (masked)
NMI and exceptions are not affected by IF.
[Basic]

Q: What do the CLI and STI x86 instructions do?
A: **CLI** (Clear Interrupt Flag): Sets IF=0, disabling maskable interrupts
**STI** (Set Interrupt Flag): Sets IF=1, enabling maskable interrupts
These are privileged instructions (ring 0 only). Linux wraps them in local_irq_disable()/local_irq_enable().
[Basic]

Q: {{c1::CLI}} disables interrupts by clearing the IF flag, while {{c2::STI}} enables interrupts by setting the IF flag.
A: CLI = Clear Interrupt Flag (disable), STI = Set Interrupt Flag (enable)
[Basic]

Q: What interrupt vectors are reserved for CPU exceptions on x86?
A: Vectors 0-31 are reserved for CPU exceptions:
- 0: Divide Error
- 6: Invalid Opcode
- 8: Double Fault
- 13: General Protection Fault
- 14: Page Fault
Hardware IRQs are mapped starting at vector 32 or higher.
[Intermediate]

Q: What is the typical IRQ-to-vector mapping for legacy PIC mode?
A: In legacy PIC mode:
- IRQ 0-7 → Vectors 32-39 (Master PIC)
- IRQ 8-15 → Vectors 40-47 (Slave PIC)
This avoids conflict with vectors 0-31 (CPU exceptions).
[Intermediate]

Q: How does interrupt priority work with the 8259A PIC?
A: The 8259A has fixed priorities: IRQ0 is highest, IRQ7 lowest on master; IRQ8 highest, IRQ15 lowest on slave. Lower-priority interrupts are masked while servicing higher-priority ones. An EOI (End Of Interrupt) must be sent to allow lower-priority interrupts.
[Intermediate]

Q: What is an EOI (End Of Interrupt) and why is it needed?
A: EOI is a command sent to the interrupt controller to signal completion of interrupt handling. Without EOI:
- PIC: Lower/same priority interrupts remain blocked
- APIC: The in-service register bit stays set
Linux sends EOI after handler completion to allow subsequent interrupts.
[Intermediate]

Q: What is the difference between specific EOI and non-specific EOI?
A: **Non-specific EOI**: Clears the highest-priority bit in the In-Service Register (ISR). Simpler but may have race conditions.
**Specific EOI**: Explicitly specifies which IRQ to acknowledge. More precise control. APIC typically uses specific EOI.
[Advanced]

Q: What is MSI (Message Signaled Interrupts)?
A: MSI is a method where devices signal interrupts by writing to a special memory address instead of using dedicated IRQ lines. Benefits:
- No shared interrupt lines
- More available interrupts
- Reduced latency
- No need for I/O APIC routing
Requires PCIe and APIC support.
[Intermediate]

Q: What is MSI-X and how does it differ from MSI?
A: MSI-X is an extended version of MSI that supports:
- Up to 2048 interrupt vectors per device (vs 32 for MSI)
- Independent configuration of each vector
- Per-vector masking capability
- Better suited for multi-queue devices (NICs, storage)
[Advanced]

---

## Section 3: Key Data Structures

Q: What is `struct irq_desc` and what is its purpose?
A: `struct irq_desc` is the main per-IRQ descriptor that holds all state and metadata for an interrupt line:
- Handler chain (irqaction list)
- Interrupt controller chip (irq_chip)
- Flow handler function
- IRQ status flags
- Statistics (counts per CPU)
- Lock for synchronization
Defined in `include/linux/irqdesc.h`.
[Intermediate]

Q: What are the key fields in `struct irq_desc`?
A: Key fields include:
- `irq_data`: Per-IRQ data (hwirq, chip, chip_data)
- `handle_irq`: Flow handler function pointer
- `action`: Linked list of irqaction handlers
- `status_use_accessors`: IRQ status flags
- `depth`: Disable depth counter
- `irq_count`: Interrupt occurrence counter
- `lock`: Spinlock for descriptor access
[Intermediate]

Q: What is `struct irq_chip` and what does it represent?
A: `struct irq_chip` is an abstraction for interrupt controller hardware. It provides callback functions to control the hardware:
- `irq_enable`/`irq_disable`: Enable/disable IRQ line
- `irq_ack`: Acknowledge interrupt
- `irq_mask`/`irq_unmask`: Mask/unmask IRQ
- `irq_eoi`: End of interrupt
- `irq_set_affinity`: Set CPU affinity
Each interrupt controller driver implements its own irq_chip.
[Intermediate]

Q: List the main callback functions in `struct irq_chip`.
A:
```c
struct irq_chip {
    const char *name;
    void (*irq_enable)(struct irq_data *data);
    void (*irq_disable)(struct irq_data *data);
    void (*irq_ack)(struct irq_data *data);
    void (*irq_mask)(struct irq_data *data);
    void (*irq_unmask)(struct irq_data *data);
    void (*irq_eoi)(struct irq_data *data);
    int  (*irq_set_affinity)(...);
    int  (*irq_set_type)(...);
    /* ... more callbacks ... */
};
```
[Intermediate]

Q: What is `struct irqaction` and how is it used?
A: `struct irqaction` represents a registered interrupt handler. Multiple irqaction structures can be chained for shared interrupts:
- `handler`: The actual ISR function pointer
- `flags`: IRQ flags (IRQF_SHARED, etc.)
- `name`: Handler name (shown in /proc/interrupts)
- `dev_id`: Device identifier for shared IRQs
- `next`: Pointer to next handler in chain
[Intermediate]

Q: Show the key fields of `struct irqaction`.
A:
```c
struct irqaction {
    irq_handler_t handler;      /* Handler function */
    unsigned long flags;        /* IRQ flags */
    void *dev_id;              /* Device ID for shared IRQs */
    struct irqaction *next;    /* Next handler in chain */
    int irq;                   /* IRQ number */
    irq_handler_t thread_fn;   /* Threaded handler */
    struct task_struct *thread;/* Handler thread */
    const char *name;          /* Name in /proc/interrupts */
};
```
[Intermediate]

Q: What is `struct irq_data` and why was it introduced?
A: `struct irq_data` was introduced to decouple per-IRQ data from the irq_chip callbacks, enabling cleaner interrupt controller abstractions:
- `irq`: Linux IRQ number
- `hwirq`: Hardware IRQ number
- `chip`: Pointer to irq_chip
- `chip_data`: Controller-private data
- `handler_data`: Per-handler data
This separation supports interrupt domains and hierarchical IRQ chips.
[Intermediate]

Q: What is the relationship between `irq_desc`, `irq_data`, and `irq_chip`?
A:
```
struct irq_desc
    |
    +-- struct irq_data
    |       |-- irq (Linux IRQ number)
    |       |-- hwirq (hardware IRQ)
    |       +-- struct irq_chip* (controller ops)
    |               |-- irq_ack()
    |               |-- irq_mask()
    |               +-- irq_eoi()
    |
    +-- struct irqaction* (handler chain)
            |-- handler function
            |-- dev_id
            +-- next (for shared IRQs)
```
[Intermediate]

Q: What is `struct pt_regs`?
A: `struct pt_regs` holds the CPU register state saved when entering the kernel (on interrupt, exception, or syscall). Architecture-specific, on x86 it includes: EAX-EDX, ESI, EDI, EBP, ESP, EIP, EFLAGS, segment registers. Passed to interrupt handlers for context inspection.
[Intermediate]

Q: How is the `irq_desc` array organized in Linux?
A: Historically, `irq_desc[NR_IRQS]` was a static array indexed by IRQ number. Modern kernels (including 3.2) support CONFIG_SPARSE_IRQ which allocates irq_desc dynamically using a radix tree, allowing for more IRQs without wasting memory.
[Intermediate]

Q: What is `NR_IRQS` and how is it determined?
A: `NR_IRQS` defines the maximum number of IRQ descriptors in the system. It's architecture-dependent and set at compile time:
- x86 with APIC: typically 256 or more
- With CONFIG_SPARSE_IRQ: can be much larger (thousands)
Defined in arch-specific headers.
[Intermediate]

Q: What is the purpose of the `depth` field in `struct irq_desc`?
A: The `depth` field is a disable nesting counter:
- Incremented by `disable_irq()` calls
- Decremented by `enable_irq()` calls
- IRQ is only enabled when depth reaches 0
This allows nested disable/enable calls to work correctly.
[Intermediate]

Q: What IRQ status flags are commonly found in `irq_desc`?
A: Common status flags (accessed via macros):
- `IRQ_DISABLED`: IRQ is disabled
- `IRQ_INPROGRESS`: Handler is executing
- `IRQ_PENDING`: IRQ pending but masked
- `IRQ_MASKED`: IRQ is masked at hardware
- `IRQ_LEVEL`: Level-triggered IRQ
- `IRQ_PER_CPU`: Per-CPU IRQ
- `IRQ_NOPROBE`: IRQ not for autoprobing
[Intermediate]

Q: What is an IRQ domain in Linux?
A: An IRQ domain maps hardware IRQ numbers to Linux IRQ numbers. It provides a namespace for interrupt controllers, allowing multiple controllers to use overlapping hardware IRQ numbers. Each domain has a `struct irq_domain` with translation operations.
[Advanced]

Q: Why are IRQ domains necessary?
A: IRQ domains are needed because:
1) Multiple interrupt controllers may have overlapping HW IRQ numbers
2) Hierarchical interrupt routing (IRQ → controller → parent controller)
3) Device tree systems need dynamic IRQ allocation
4) Cleanly separate hardware numbering from Linux's IRQ space
[Advanced]

Q: What is the `struct irq_domain` structure used for?
A: `struct irq_domain` represents a namespace for mapping hardware IRQs:
- `ops`: Translation operations (xlate, map)
- `host_data`: Controller-private data
- `revmap_*`: Reverse mapping structures
- `parent`: Parent domain for hierarchy
Introduced to handle complex interrupt controller topologies.
[Advanced]

Q: How do you obtain the `irq_desc` for a given IRQ number?
A: Use `irq_to_desc(irq)` which returns the `struct irq_desc*` for the given IRQ number. With CONFIG_SPARSE_IRQ, this does a radix tree lookup. Without it, it's a simple array index: `&irq_desc[irq]`.
[Intermediate]

Q: What is `irq_data_get_irq_chip()` used for?
A: `irq_data_get_irq_chip(struct irq_data *d)` returns the `irq_chip` pointer associated with the given irq_data. This is the preferred way to access the chip from modern interrupt code, rather than accessing irq_desc->chip directly.
[Intermediate]

Q: What is the `irq_set_chip_and_handler()` function?
A: `irq_set_chip_and_handler(irq, chip, handle)` sets both the interrupt controller chip and the flow handler for an IRQ in one call. This is commonly used during interrupt controller initialization:
```c
irq_set_chip_and_handler(irq, &my_chip, handle_level_irq);
```
[Intermediate]

Q: Draw an ASCII diagram showing the data structure relationships for interrupt handling.
A:
```
  irq_desc[n]                         Interrupt
  +------------------+                Controller
  | irq_data --------|--------------> irq_chip
  |   .irq           |                +----------+
  |   .hwirq         |                | name     |
  |   .chip ---------|---+            | irq_ack  |
  | handle_irq()     |   |            | irq_mask |
  | action ----------|---|-+          | irq_eoi  |
  | depth            |   | |          +----------+
  | lock             |   | |
  +------------------+   | |
                         | |
                         | v
                         | irqaction (handler chain)
                         | +---------+   +---------+
                         | | handler |-->| handler |-->NULL
                         | | dev_id  |   | dev_id  |
                         | | name    |   | name    |
                         | +---------+   +---------+
                         |   (dev A)       (dev B)
                         |    shared IRQ handlers
```
[Intermediate]

Q: What is `generic_handle_irq()` and when is it used?
A: `generic_handle_irq(irq)` invokes the flow handler for the specified IRQ. It's called by architecture-specific interrupt entry code or by parent interrupt controllers to dispatch to child controllers. It calls `desc->handle_irq(irq, desc)`.
[Intermediate]

Q: What is a "flow handler" in the context of irq_desc?
A: A flow handler is the function stored in `irq_desc->handle_irq` that implements the interrupt acknowledge/mask/unmask sequence for a specific interrupt type. Examples: `handle_level_irq`, `handle_edge_irq`, `handle_fasteoi_irq`. It calls the registered device handlers (irqaction chain).
[Intermediate]

Q: What is `irq_set_handler_data()` used for?
A: `irq_set_handler_data(irq, data)` sets the `handler_data` field in the IRQ's irq_data structure. This allows passing controller-specific data to flow handlers, useful when one flow handler is shared by multiple IRQ lines that need different configurations.
[Advanced]

Q: What does `irq_get_irq_data()` return?
A: `irq_get_irq_data(irq)` returns a pointer to the `struct irq_data` embedded in the irq_desc for the given IRQ number. This is used to access per-IRQ data without going through the full irq_desc structure.
[Intermediate]

---

## Section 4: Interrupt Handler Registration

Q: What is the function signature of `request_irq()`?
A:
```c
int request_irq(unsigned int irq,
                irq_handler_t handler,
                unsigned long flags,
                const char *name,
                void *dev_id);
```
Returns 0 on success, negative error code on failure.
[Basic]

Q: What are the parameters of `request_irq()`?
A: - `irq`: IRQ number to request
- `handler`: Function pointer to interrupt handler
- `flags`: Bitmask of IRQF_* flags (IRQF_SHARED, etc.)
- `name`: ASCII name shown in /proc/interrupts
- `dev_id`: Unique identifier passed to handler (required for shared IRQs)
[Basic]

Q: What is the function signature of an interrupt handler?
A:
```c
irqreturn_t handler(int irq, void *dev_id);
```
- `irq`: IRQ number that triggered
- `dev_id`: Same pointer passed to request_irq()
- Returns `irqreturn_t` (IRQ_NONE, IRQ_HANDLED, IRQ_WAKE_THREAD)
[Basic]

Q: What are the possible return values from an interrupt handler?
A: - `IRQ_NONE`: Interrupt was not from this device (for shared IRQs)
- `IRQ_HANDLED`: Interrupt was handled successfully
- `IRQ_WAKE_THREAD`: Wake the threaded handler (for threaded IRQs)
Defined in `include/linux/irqreturn.h`.
[Basic]

Q: Why is `dev_id` mandatory for shared interrupts?
A: When IRQF_SHARED is set, multiple handlers share one IRQ line. The kernel walks the handler chain calling each handler. `dev_id` allows:
1) Handler to identify if the interrupt is from its device
2) `free_irq()` to identify which handler to remove
Must be unique and non-NULL for shared IRQs.
[Intermediate]

Q: What is the IRQF_SHARED flag used for?
A: IRQF_SHARED indicates this handler can share the IRQ line with other handlers. All handlers on a shared IRQ must specify IRQF_SHARED. When the interrupt fires, all handlers are called in sequence until one returns IRQ_HANDLED.
[Basic]

Q: What does the IRQF_DISABLED flag do? (deprecated in v3.2)
A: IRQF_DISABLED requested that the handler run with interrupts disabled on the local CPU. In kernel 3.2, this flag was being deprecated - all handlers run with interrupts disabled by default. It was removed in later kernels (2.6.35+).
[Intermediate]

Q: List the common IRQF_* flags and their purposes.
A: - `IRQF_SHARED`: IRQ can be shared with other handlers
- `IRQF_TRIGGER_*`: Specify trigger type (RISING, FALLING, HIGH, LOW)
- `IRQF_ONESHOT`: Keep IRQ disabled until thread handler completes
- `IRQF_NO_SUSPEND`: Don't disable during suspend
- `IRQF_NOBALANCING`: Exclude from IRQ balancing
- `IRQF_IRQPOLL`: Used for IRQ polling
[Intermediate]

Q: How do you free/unregister an interrupt handler?
A:
```c
void free_irq(unsigned int irq, void *dev_id);
```
The `dev_id` must match what was passed to `request_irq()`. For shared IRQs, only that specific handler is removed; the IRQ stays enabled if other handlers remain.
[Basic]

Q: What happens internally when `request_irq()` is called?
A: 1) Allocate struct irqaction
2) Validate parameters (flags compatibility)
3) Acquire irq_desc lock
4) Add irqaction to handler chain
5) If first handler, enable the IRQ line
6) Release lock
7) Return success or error code
[Intermediate]

Q: What is `request_threaded_irq()` and how does it differ from `request_irq()`?
A:
```c
int request_threaded_irq(unsigned int irq,
                         irq_handler_t handler,      /* primary/hardirq */
                         irq_handler_t thread_fn,    /* threaded handler */
                         unsigned long flags,
                         const char *name,
                         void *dev_id);
```
Registers both a quick primary handler and a threaded handler that can sleep.
[Intermediate]

Q: When should you use `request_threaded_irq()` instead of `request_irq()`?
A: Use `request_threaded_irq()` when:
- Interrupt processing needs to sleep (I2C, SPI communication)
- Processing is time-consuming
- Need to acquire mutexes or semaphores
- Working with RT-PREEMPT systems
The primary handler does quick work; thread_fn handles the rest.
[Intermediate]

Q: What error codes can `request_irq()` return?
A: Common error codes:
- `-EINVAL`: Invalid parameters (bad IRQ, incompatible flags)
- `-EBUSY`: IRQ already in use (non-shared) or flag mismatch
- `-ENOMEM`: Memory allocation failed
- `-ENOSYS`: IRQ not available on this platform
[Intermediate]

Q: Write a typical `request_irq()` call for a PCI device driver.
A:
```c
ret = request_irq(pdev->irq,
                  my_device_isr,
                  IRQF_SHARED,
                  "my_device",
                  dev);
if (ret) {
    dev_err(&pdev->dev, "Failed to request IRQ %d\n", pdev->irq);
    return ret;
}
```
[Basic]

Q: What is the correct order of operations when initializing a device with interrupts?
A: 1) Initialize device hardware
2) Set up internal data structures
3) Register interrupt handler with `request_irq()`
4) Enable interrupts on the device
Reverse order for cleanup: disable device IRQs, free_irq(), cleanup structures.
[Intermediate]

Q: What happens if you call `request_irq()` with IRQF_SHARED but another handler doesn't have IRQF_SHARED?
A: The request fails with `-EBUSY`. All handlers sharing an IRQ must specify IRQF_SHARED. If any existing handler lacks this flag, new shared handlers cannot be added.
[Intermediate]

Q: Can you register multiple handlers for the same device on one IRQ?
A: Yes, but each registration needs a unique `dev_id`. However, this is unusual - typically one device has one handler. Multiple handlers on one IRQ is designed for different devices sharing a hardware IRQ line.
[Intermediate]

Q: What is the `devm_request_irq()` function?
A: `devm_request_irq()` is a device-managed version of `request_irq()`. The handler is automatically freed when the device is removed or the driver is unbound. Part of the devres (device resource management) framework.
```c
int devm_request_irq(struct device *dev, unsigned int irq, ...);
```
[Intermediate]

Q: What is the advantage of using `devm_request_irq()`?
A: - Automatic cleanup on device removal (no need for explicit free_irq)
- Prevents resource leak bugs
- Simplifies error handling paths
- Resources freed in correct order during unbind
- Reduces boilerplate code in drivers
[Intermediate]

Q: What is `synchronize_irq()` and when should it be used?
A:
```c
void synchronize_irq(unsigned int irq);
```
Waits for any executing handlers for this IRQ to complete. Use before freeing resources accessed by the handler. `free_irq()` calls this internally, but useful for partial cleanup.
[Intermediate]

Q: Show a complete example of registering and freeing an interrupt handler.
A:
```c
/* In probe function */
priv->irq = pdev->irq;
ret = request_irq(priv->irq, my_isr, IRQF_SHARED, "mydev", priv);
if (ret)
    goto err_free;

/* In remove function */
free_irq(priv->irq, priv);  /* dev_id must match! */
```
[Basic]

---

## Section 5: Top Half - Interrupt Handlers

Q: What code runs in the "top half" of interrupt handling?
A: The top half is the handler function registered with `request_irq()`. It runs immediately when the interrupt occurs, in interrupt context. It should:
1) Acknowledge the interrupt at the device
2) Read/write essential data from/to device
3) Schedule bottom half if more work needed
4) Return quickly
[Basic]

Q: What are the key restrictions when running in interrupt context?
A: Code in interrupt context CANNOT:
- Sleep or call schedule()
- Call any function that might sleep (kmalloc without GFP_ATOMIC, mutex_lock, etc.)
- Access user space memory
- Call functions that may block (down(), wait_event(), etc.)
Must use GFP_ATOMIC for allocations.
[Basic]

Q: What does the `in_interrupt()` macro return?
A: `in_interrupt()` returns non-zero if currently executing in:
- Hardirq context (interrupt handler)
- Softirq context (bottom half)
Returns 0 in process context. Used to check if sleeping is safe.
[Basic]

Q: What is the difference between `in_interrupt()`, `in_irq()`, and `in_softirq()`?
A: - `in_interrupt()`: True in hardirq OR softirq context
- `in_irq()`: True ONLY in hardirq (interrupt handler) context
- `in_softirq()`: True ONLY in softirq/bottom-half context
All return 0 in normal process context.
[Intermediate]

Q: {{c1::in_irq()}} returns true only in hardirq context, while {{c2::in_softirq()}} returns true only in softirq context.
A: in_irq() = hardirq only, in_softirq() = softirq only, in_interrupt() = either
[Intermediate]

Q: How does the kernel track whether code is in interrupt context?
A: The kernel uses the `preempt_count` field in thread_info. Different bits indicate:
- HARDIRQ_OFFSET: Currently in hardirq
- SOFTIRQ_OFFSET: Currently in softirq
- PREEMPT_MASK: Preemption disable count
The in_*() macros test these bits.
[Intermediate]

Q: What is the `current` macro in interrupt context?
A: In interrupt context, `current` still points to the task_struct of the process that was running when the interrupt occurred. However, this process has no relationship to the interrupt - it was simply interrupted. You cannot sleep because you'd be sleeping on behalf of an unrelated process.
[Intermediate]

Q: Why can't interrupt handlers sleep even though `current` is valid?
A: Although `current` points to a valid task_struct, that process has nothing to do with the interrupt. Sleeping would:
1) Block an unrelated process
2) Leave device in undefined state
3) Potentially cause deadlock if that process holds resources the handler needs
The interrupt should complete and return to let the original process continue.
[Intermediate]

Q: Can interrupt handlers be preempted?
A: No, traditional interrupt handlers cannot be preempted by the scheduler. However:
- Higher-priority interrupts CAN preempt (interrupt nesting, if enabled)
- With CONFIG_PREEMPT_RT, handlers run as threads and CAN be preempted
Standard handlers run to completion with preemption disabled.
[Intermediate]

Q: What happens to preemption when entering an interrupt handler?
A: When entering interrupt context:
1) `preempt_count` is incremented (HARDIRQ_OFFSET)
2) This implicitly disables preemption
3) On exit, `preempt_count` is decremented
4) If it reaches 0 and rescheduling is needed, schedule() is called
[Intermediate]

Q: How should you allocate memory in an interrupt handler?
A:
```c
ptr = kmalloc(size, GFP_ATOMIC);
```
Use `GFP_ATOMIC` flag which:
- Never sleeps
- Uses emergency memory reserves if needed
- May fail under memory pressure
Prefer pre-allocated buffers when possible.
[Basic]

Q: What is the typical structure of a well-designed interrupt handler?
A:
```c
static irqreturn_t
my_handler(int irq, void *dev_id)
{
    struct my_device *dev = dev_id;
    u32 status;

    /* Read interrupt status */
    status = readl(dev->regs + IRQ_STATUS);
    if (!(status & MY_IRQ_PENDING))
        return IRQ_NONE;  /* Not our interrupt */

    /* Acknowledge interrupt */
    writel(status, dev->regs + IRQ_ACK);

    /* Handle critical work */
    /* ... minimal work here ... */

    /* Schedule bottom half for more work */
    tasklet_schedule(&dev->tasklet);

    return IRQ_HANDLED;
}
```
[Intermediate]

Q: What does "acknowledge the interrupt" mean and why is it necessary?
A: Acknowledging an interrupt tells the device (and sometimes interrupt controller) that the interrupt has been noticed. Without acknowledgment:
- Level-triggered: IRQ remains asserted, immediately re-triggers
- Edge-triggered: May miss subsequent interrupts
Device-specific; typically involves reading status register or writing to ack register.
[Basic]

Q: Can the same interrupt handler run concurrently on multiple CPUs?
A: For the same IRQ: No, the kernel serializes execution per IRQ line (using the irq_desc lock and IRQ_INPROGRESS flag). Different IRQs: Yes, handlers for different IRQs can run in parallel on different CPUs.
[Intermediate]

Q: What is the IRQ_INPROGRESS flag used for?
A: `IRQ_INPROGRESS` indicates a handler is currently executing for this IRQ. It's set before calling the handler and cleared after. Used to:
1) Prevent re-entry of same handler on another CPU
2) Let `synchronize_irq()` know to wait
3) Help with debugging and diagnostics
[Intermediate]

Q: Why should interrupt handlers avoid holding spinlocks for long periods?
A: Spinlocks held in interrupt handlers:
1) Block other CPUs spinning for the lock
2) May be held when the interrupted process also needs it (potential deadlock)
3) Extend the time interrupts are disabled
4) Increase overall system latency
Keep critical sections minimal.
[Intermediate]

Q: What is the relationship between interrupt handlers and per-CPU variables?
A: Per-CPU variables are safe to use in interrupt handlers because:
1) Handlers run on the CPU that received the interrupt
2) Same handler won't run simultaneously on this CPU
3) No need for locking when accessing this_cpu_* data
But beware: data may be stale from another CPU's perspective.
[Intermediate]

Q: How do you safely access per-CPU data in an interrupt handler?
A:
```c
/* Safe - we're already in interrupt context, no preemption */
this_cpu_inc(my_counter);

/* Or using explicit CPU: */
per_cpu(my_data, smp_processor_id()).field = value;
```
No need for get_cpu()/put_cpu() since preemption is already disabled.
[Intermediate]

Q: What is the "interrupt stack" and why does it exist?
A: The interrupt stack is a separate, per-CPU stack used for interrupt handling (on x86). Benefits:
1) Protects process kernel stacks from overflow (IRQs can nest)
2) Fixed size, easier to monitor
3) Reduces kernel stack requirements for each task
Typically 4KB-8KB per CPU.
[Intermediate]

Q: What happens if an interrupt handler returns IRQ_NONE for all handlers on a shared IRQ?
A: If all handlers return IRQ_NONE (no device claimed the interrupt):
1) Kernel logs a "spurious interrupt" message
2) The spurious interrupt counter increments
3) After threshold (~100,000), IRQ may be disabled
4) Indicates hardware problem or driver bug
[Intermediate]

---

## Section 6: Bottom Half Mechanisms Overview

Q: Why do bottom half mechanisms exist in Linux?
A: Bottom halves exist to defer non-critical interrupt work to a safer context:
1) Minimize time with interrupts disabled
2) Allow more flexible execution (some can sleep)
3) Improve system responsiveness
4) Enable better CPU utilization
The top half does urgent work; bottom half does the rest.
[Basic]

Q: What are the main bottom half mechanisms in Linux kernel 3.2?
A: 1) **Softirqs**: Lowest latency, compile-time defined, can run in parallel
2) **Tasklets**: Built on softirqs, dynamically allocatable, serialized per-tasklet
3) **Workqueues**: Run in process context, can sleep, most flexible
4) (Historical: BH and task queues - removed)
[Basic]

Q: What was the evolution of bottom half mechanisms in Linux?
A: Timeline:
- **BH (Bottom Halves)**: Original, global lock, removed in 2.5
- **Task Queues**: Early deferred work, replaced by workqueues
- **Softirqs**: Introduced 2.3, fast, limited number
- **Tasklets**: Softirq-based, easier to use, dynamic
- **Workqueues**: Process context, can sleep, introduced 2.5
[Intermediate]

Q: Compare softirqs, tasklets, and workqueues in terms of context.
A: - **Softirqs**: Softirq context (interrupts enabled, preemption disabled)
- **Tasklets**: Softirq context (same as softirqs)
- **Workqueues**: Process context (can sleep, preemption possible)
Only workqueues can call sleeping functions.
[Basic]

Q: Compare softirqs, tasklets, and workqueues in terms of concurrency.
A: - **Softirqs**: Same softirq can run on multiple CPUs simultaneously
- **Tasklets**: Same tasklet is serialized (never concurrent with itself)
- **Workqueues**: Depends on configuration (single-thread or per-CPU)
[Intermediate]

Q: Which bottom half mechanism should you use if you need to sleep?
A: Use **workqueues**. They're the only standard bottom half mechanism that runs in process context and can safely call sleeping functions like:
- `mutex_lock()`
- `kmalloc()` with GFP_KERNEL
- `msleep()`, `schedule()`
- I/O operations that may block
[Basic]

Q: When should you choose softirqs over tasklets?
A: Use softirqs when:
- You need maximum performance (high-frequency events)
- You can handle parallel execution on multiple CPUs
- You have a well-defined, limited-scope use case
In practice, only core kernel subsystems (networking, block) use softirqs. Drivers typically use tasklets or workqueues.
[Intermediate]

Q: When should you choose tasklets over workqueues?
A: Choose tasklets when:
- You need low latency (tasklets run sooner than workqueues)
- You don't need to sleep
- Per-tasklet serialization is acceptable or desired
- Work is short-duration
Choose workqueues if you need to sleep or work is long-running.
[Intermediate]

Q: Create a comparison table of bottom half mechanisms.
A:
```
Feature          | Softirq    | Tasklet    | Workqueue
-----------------|------------|------------|------------
Context          | Softirq    | Softirq    | Process
Can sleep?       | No         | No         | Yes
Parallel on CPUs | Yes (same) | No (same)  | Configurable
Dynamic alloc?   | No         | Yes        | Yes
Latency          | Lowest     | Low        | Higher
Complexity       | High       | Medium     | Low
Typical use      | Network,   | Drivers    | Drivers,
                 | Block I/O  |            | filesystems
```
[Intermediate]

Q: What happens if a bottom half takes too long to execute?
A: Long-running bottom halves:
- Softirqs/tasklets: May be moved to ksoftirqd thread to prevent starving other work
- Workqueues: May delay other queued work items
- All: Increase overall latency, may trigger soft lockup warnings
Design for short execution time or use workqueues for long work.
[Intermediate]

Q: What is ksoftirqd and when does it run?
A: `ksoftirqd` is a per-CPU kernel thread that processes softirqs when:
1) Softirqs have been pending too long
2) Too many softirqs executed in `do_softirq()` (prevents monopolizing)
3) Need to give user processes a chance to run
It runs at nice 19 (low priority) to ensure fairness.
[Intermediate]

Q: What is the latency order of bottom half mechanisms from fastest to slowest?
A: Fastest → Slowest:
1) **Softirqs**: Run immediately after hardirq, in softirq context
2) **Tasklets**: Also softirq context, tiny overhead over raw softirqs
3) **Workqueues**: Require context switch to worker thread, can be preempted
For latency-critical work (networking), softirqs are preferred.
[Intermediate]

Q: Can bottom halves be preempted?
A: - **Softirqs/Tasklets**: Cannot be preempted by scheduler (run with preempt disabled), but CAN be interrupted by hardware IRQs
- **Workqueues**: Run in normal process context, CAN be preempted
With RT patches, softirqs can be threaded and preempted.
[Intermediate]

Q: What is "softirq starvation" and how does Linux prevent it?
A: Softirq starvation occurs when continuous softirq processing prevents user processes from running. Linux prevents this by:
1) Limiting softirq loops in `do_softirq()` (MAX_SOFTIRQ_RESTART)
2) Moving excess softirqs to ksoftirqd
3) ksoftirqd runs at low priority, yielding to other processes
[Advanced]

Q: Draw an ASCII diagram showing the relationship between top half and bottom half mechanisms.
A:
```
Hardware Interrupt
       |
       v
+------------------+
| Top Half (ISR)   |  <- Interrupt context, fast
| - ACK hardware   |
| - Grab data      |
| - Schedule BH    |
+------------------+
       |
       | raise_softirq() / tasklet_schedule() / schedule_work()
       v
+------------------+
| Bottom Half      |  <- Softirq or process context
| - Softirqs       |
| - Tasklets       |
| - Workqueues     |
| - Heavy lifting  |
+------------------+
```
[Basic]

---

## Section 7: Softirqs

Q: What is a softirq in Linux?
A: A softirq is a statically defined, high-priority deferred work mechanism. Softirqs:
- Are defined at compile time (fixed set)
- Can run concurrently on multiple CPUs
- Execute in softirq context (interrupts enabled, preemption disabled)
- Provide the lowest-latency bottom half processing
[Basic]

Q: Why are softirqs statically defined rather than dynamically allocated?
A: Softirqs are statically defined because:
1) Performance: Fixed array lookup, no allocation overhead
2) Limited number keeps complexity manageable
3) Concurrency: Parallel execution requires careful design
4) Only core subsystems need this level of performance
Tasklets provide dynamic allocation for drivers.
[Intermediate]

Q: What is the `struct softirq_action` structure?
A:
```c
struct softirq_action {
    void (*action)(struct softirq_action *);
};
```
It contains a single function pointer - the handler to execute when this softirq is raised. The `softirq_vec[]` array holds one for each softirq type.
[Intermediate]

Q: What is the `softirq_vec[]` array?
A: `softirq_vec[NR_SOFTIRQS]` is a static array of `struct softirq_action`. Each element corresponds to one softirq type (HI_SOFTIRQ, NET_TX_SOFTIRQ, etc.). Defined in `kernel/softirq.c`.
[Intermediate]

Q: List the built-in softirq types in Linux kernel 3.2.
A:
```c
enum {
    HI_SOFTIRQ=0,       /* High-priority tasklets */
    TIMER_SOFTIRQ,      /* Timer bottom half */
    NET_TX_SOFTIRQ,     /* Network transmit */
    NET_RX_SOFTIRQ,     /* Network receive */
    BLOCK_SOFTIRQ,      /* Block device */
    BLOCK_IOPOLL_SOFTIRQ,
    TASKLET_SOFTIRQ,    /* Normal tasklets */
    SCHED_SOFTIRQ,      /* Scheduler */
    HRTIMER_SOFTIRQ,    /* High-res timers */
    RCU_SOFTIRQ,        /* RCU callbacks */
    NR_SOFTIRQS
};
```
[Intermediate]

Q: What is the priority order of softirqs?
A: Lower index = higher priority. Softirqs are processed in order from HI_SOFTIRQ (0) to RCU_SOFTIRQ (highest index). This means high-priority tasklets (HI_SOFTIRQ) run before network processing (NET_*_SOFTIRQ), which runs before normal tasklets (TASKLET_SOFTIRQ).
[Intermediate]

Q: How do you register a softirq handler?
A:
```c
void open_softirq(int nr, void (*action)(struct softirq_action *));
```
Example:
```c
open_softirq(NET_RX_SOFTIRQ, net_rx_action);
```
This is called once during kernel initialization. Drivers should NOT add new softirqs.
[Intermediate]

Q: How do you raise (trigger) a softirq?
A: Use `raise_softirq(nr)` or `raise_softirq_irqoff(nr)`:
```c
raise_softirq(NET_RX_SOFTIRQ);      /* Safe, handles IRQ state */
raise_softirq_irqoff(NET_RX_SOFTIRQ); /* Faster, IRQs already off */
```
This sets the corresponding bit in the per-CPU pending bitmask.
[Basic]

Q: What is the difference between `raise_softirq()` and `raise_softirq_irqoff()`?
A: - `raise_softirq()`: Disables local IRQs, sets pending bit, restores IRQs. Safe to call from any context.
- `raise_softirq_irqoff()`: Assumes IRQs already disabled, just sets the bit. Faster but caller must ensure IRQs are off.
Use `_irqoff` variant in interrupt handlers where IRQs are already disabled.
[Intermediate]

Q: Where is the pending softirq bitmask stored?
A: The pending softirq bitmask is stored in a per-CPU variable `irq_stat[cpu].__softirq_pending` (architecture-dependent). Each bit corresponds to one softirq type. Accessed via `local_softirq_pending()` macro.
[Intermediate]

Q: When are pending softirqs processed?
A: Softirqs are processed at these points:
1) After returning from a hardware interrupt handler (`irq_exit()`)
2) In the `ksoftirqd` kernel thread
3) When explicitly calling `do_softirq()` (rare)
4) When re-enabling softirqs via `local_bh_enable()`
[Intermediate]

Q: What does `do_softirq()` do?
A: `do_softirq()` processes pending softirqs:
1) Check if already in interrupt context (skip if so)
2) Save IRQ state and disable BH
3) Loop through pending softirq bits
4) Call each pending softirq's action function
5) Repeat if new softirqs raised (up to MAX_SOFTIRQ_RESTART)
6) Wake ksoftirqd if still pending
[Intermediate]

Q: What is the `__do_softirq()` function?
A: `__do_softirq()` is the core softirq processing loop called by `do_softirq()`:
```c
asmlinkage void __do_softirq(void)
{
    while ((softirq_bit = ffs(pending))) {
        h = softirq_vec + softirq_bit - 1;
        h->action(h);
        pending >>= softirq_bit;
    }
    /* ... restart logic, ksoftirqd wakeup ... */
}
```
[Advanced]

Q: What is MAX_SOFTIRQ_RESTART and why does it exist?
A: `MAX_SOFTIRQ_RESTART` (typically 10) limits how many times `do_softirq()` restarts when new softirqs are raised during processing. After this limit:
1) Remaining softirqs are deferred to ksoftirqd
2) Prevents softirq processing from monopolizing the CPU
3) Ensures user processes get to run
[Intermediate]

Q: What is ksoftirqd?
A: `ksoftirqd/N` (where N is CPU number) is a per-CPU kernel thread that processes softirqs. It runs when:
1) `do_softirq()` exceeds restart limit
2) Softirqs pending for too long
Benefits: Prevents live-lock, ensures fairness with user processes.
Runs at nice 19 (low priority).
[Intermediate]

Q: Can the same softirq run concurrently on multiple CPUs?
A: Yes! This is a key difference from tasklets. The same softirq handler can execute simultaneously on different CPUs. The handler must be designed for this:
- Use per-CPU data structures
- Use appropriate locking for shared data
- Network and block subsystems are designed this way
[Intermediate]

Q: What is softirq context?
A: Softirq context is the execution environment during softirq processing:
- Interrupts are ENABLED (can be interrupted by hardware IRQs)
- Preemption is DISABLED (cannot be preempted by scheduler)
- `in_softirq()` returns true
- Cannot sleep or call blocking functions
- `current` points to interrupted process (or ksoftirqd)
[Intermediate]

Q: How do you disable softirq processing?
A:
```c
local_bh_disable();  /* Disable softirqs on this CPU */
/* ... critical section ... */
local_bh_enable();   /* Re-enable, may process pending softirqs */
```
"bh" stands for "bottom half". These increment/decrement preempt_count's SOFTIRQ bits.
[Basic]

Q: What is the relationship between `local_bh_disable()` and softirqs?
A: `local_bh_disable()` prevents softirq execution on the current CPU:
- Increments preempt_count softirq field
- Softirqs won't run until count reaches 0
- Nesting is supported (counter-based)
- `local_bh_enable()` may trigger `do_softirq()` if softirqs pending
[Intermediate]

Q: Why would process context code call `local_bh_disable()`?
A: To prevent softirq handlers from preempting a critical section that shares data with softirqs. For example, networking code in process context disabling BH while manipulating socket queues that NET_RX_SOFTIRQ also accesses.
[Intermediate]

Q: What is the flow of softirq execution after a hardware interrupt?
A:
```
Hardware IRQ fires
      |
      v
do_IRQ() -> handle_irq() -> device handler
      |
      v
irq_exit()
      |
      +-- if (local_softirq_pending() && !in_interrupt())
      |         |
      v         v
return    invoke_softirq()
 to              |
user             v
            do_softirq() / __do_softirq()
                 |
                 v
            process softirq_vec[]
```
[Intermediate]

Q: How does NET_RX_SOFTIRQ work for network packet processing?
A: 1) NIC interrupt handler (top half) puts packets in queue
2) Handler calls `napi_schedule()` which raises NET_RX_SOFTIRQ
3) `net_rx_action()` runs in softirq context
4) Calls driver's NAPI poll function to process packets
5) Packets move up the network stack
This allows high-throughput packet processing.
[Advanced]

Q: What locking considerations apply when writing softirq handlers?
A: - Same softirq can run on multiple CPUs: need per-CPU data or locking
- Softirqs can interrupt process context: process code needs `local_bh_disable()` if sharing data
- Hardirqs can interrupt softirqs: use `spin_lock_irqsave()` for data shared with hardirq
- Can't sleep: no mutexes, use spinlocks only
[Advanced]

Q: What does `raise_softirq_irqoff(TASKLET_SOFTIRQ)` do?
A: It marks the TASKLET_SOFTIRQ as pending on the current CPU. When softirqs are next processed, the `tasklet_action()` handler will run, executing all scheduled tasklets. This is called internally by `tasklet_schedule()`.
[Intermediate]

Q: Can you add a new softirq type in a loadable module?
A: No. Softirq types are:
1) Defined at compile time in an enum
2) Limited in number (around 10 types)
3) Require core kernel changes to add
Drivers should use tasklets (built on softirqs) or workqueues instead.
[Intermediate]

---

## Section 8: Tasklets

Q: What is a tasklet in Linux?
A: A tasklet is a dynamically allocatable bottom-half mechanism built on top of softirqs. Key properties:
- Runs in softirq context (cannot sleep)
- Same tasklet never runs concurrently on multiple CPUs
- Different tasklets can run in parallel
- Simpler to use than raw softirqs
[Basic]

Q: What is the `struct tasklet_struct` structure?
A:
```c
struct tasklet_struct {
    struct tasklet_struct *next;  /* Next in list */
    unsigned long state;          /* TASKLET_STATE_* flags */
    atomic_t count;               /* Disable count (0=enabled) */
    void (*func)(unsigned long);  /* Handler function */
    unsigned long data;           /* Argument to handler */
};
```
[Intermediate]

Q: What are the tasklet state flags?
A: - `TASKLET_STATE_SCHED`: Tasklet is scheduled (on a CPU's list)
- `TASKLET_STATE_RUN`: Tasklet is currently running (SMP only)
These flags ensure a tasklet doesn't run concurrently with itself and isn't scheduled multiple times.
[Intermediate]

Q: How do you statically declare a tasklet?
A:
```c
/* Enabled tasklet */
DECLARE_TASKLET(name, func, data);

/* Disabled tasklet (must enable before use) */
DECLARE_TASKLET_DISABLED(name, func, data);
```
Example:
```c
DECLARE_TASKLET(my_tasklet, my_tasklet_handler, 0);
```
[Basic]

Q: How do you dynamically initialize a tasklet?
A:
```c
void tasklet_init(struct tasklet_struct *t,
                  void (*func)(unsigned long),
                  unsigned long data);
```
Example:
```c
struct tasklet_struct my_tasklet;
tasklet_init(&my_tasklet, my_handler, (unsigned long)dev);
```
[Basic]

Q: How do you schedule a tasklet for execution?
A:
```c
tasklet_schedule(&my_tasklet);      /* Normal priority */
tasklet_hi_schedule(&my_tasklet);   /* High priority */
```
Normal tasklets run via TASKLET_SOFTIRQ; high-priority via HI_SOFTIRQ.
[Basic]

Q: What is the difference between `tasklet_schedule()` and `tasklet_hi_schedule()`?
A: - `tasklet_schedule()`: Uses TASKLET_SOFTIRQ, runs after NET_*, TIMER_*, and BLOCK_* softirqs
- `tasklet_hi_schedule()`: Uses HI_SOFTIRQ, runs first among all softirqs
Use hi_schedule only when low latency is critical (e.g., audio drivers).
[Intermediate]

Q: What happens internally when `tasklet_schedule()` is called?
A: 1) Test-and-set TASKLET_STATE_SCHED flag
2) If already scheduled, return (prevents duplicates)
3) Add tasklet to per-CPU tasklet_vec list
4) Raise TASKLET_SOFTIRQ
5) When softirq runs, `tasklet_action()` processes the list
[Intermediate]

Q: What is the function signature of a tasklet handler?
A:
```c
void my_tasklet_handler(unsigned long data);
```
The `data` parameter is the value passed during tasklet initialization. Commonly used to pass a pointer to device-specific data (cast from unsigned long).
[Basic]

Q: How does the kernel ensure a tasklet doesn't run concurrently with itself?
A: Using the TASKLET_STATE_RUN flag:
1) Before running, `test_and_set_bit(TASKLET_STATE_RUN, &t->state)`
2) If already set (running on another CPU), reschedule for later
3) After completion, clear the RUN flag
4) This serializes the same tasklet across CPUs
[Intermediate]

Q: Write a complete example of using a tasklet in a driver.
A:
```c
static void my_tasklet_func(unsigned long data)
{
    struct my_device *dev = (struct my_device *)data;
    /* Process deferred work */
}

static DECLARE_TASKLET(my_tasklet, my_tasklet_func, 0);

static irqreturn_t my_irq_handler(int irq, void *dev_id)
{
    struct my_device *dev = dev_id;
    /* Quick hardware handling */
    my_tasklet.data = (unsigned long)dev;
    tasklet_schedule(&my_tasklet);
    return IRQ_HANDLED;
}

static void cleanup(void)
{
    tasklet_kill(&my_tasklet);
}
```
[Intermediate]

Q: How do you disable a tasklet?
A:
```c
tasklet_disable(&my_tasklet);      /* Wait if running, then disable */
tasklet_disable_nosync(&my_tasklet); /* Disable immediately, don't wait */
```
Increments the count field. When count > 0, tasklet won't run even if scheduled.
[Basic]

Q: How do you re-enable a disabled tasklet?
A:
```c
tasklet_enable(&my_tasklet);
```
Decrements the count field. If count reaches 0 and tasklet is scheduled, it will run on next softirq opportunity.
[Basic]

Q: What does `tasklet_kill()` do?
A: `tasklet_kill(&t)` ensures a tasklet is not scheduled and will not run:
1) Clears TASKLET_STATE_SCHED flag
2) Waits for any running instance to complete
3) Must be called before freeing tasklet memory
4) Cannot be called from interrupt context (may sleep)
[Intermediate]

Q: Why must you call `tasklet_kill()` before unloading a module?
A: If a tasklet is scheduled when the module is unloaded, the handler function no longer exists. When softirq tries to call it, the system crashes. `tasklet_kill()` ensures the tasklet is fully stopped before the module's code is removed.
[Intermediate]

Q: What is the difference between `tasklet_disable()` and `tasklet_kill()`?
A: - `tasklet_disable()`: Temporarily prevents execution, can be re-enabled
- `tasklet_kill()`: Permanently removes from scheduling, for cleanup
Use disable/enable for temporary suspension during reconfiguration. Use kill before freeing resources.
[Intermediate]

Q: Can tasklets sleep or call blocking functions?
A: No. Tasklets run in softirq context where:
- Preemption is disabled
- Sleeping would cause undefined behavior
- Must use GFP_ATOMIC for memory allocation
- Can only use spinlocks, not mutexes
If you need to sleep, use workqueues instead.
[Basic]

Q: What per-CPU lists hold scheduled tasklets?
A: Two per-CPU lists:
- `tasklet_vec`: Normal-priority tasklets (TASKLET_SOFTIRQ)
- `tasklet_hi_vec`: High-priority tasklets (HI_SOFTIRQ)
Each CPU maintains its own lists; tasklets run on the CPU that scheduled them.
[Intermediate]

Q: How does `tasklet_action()` process the tasklet list?
A:
```c
static void tasklet_action(struct softirq_action *a)
{
    /* Grab this CPU's tasklet list */
    list = __get_cpu_var(tasklet_vec).head;
    
    while (list) {
        t = list;
        list = list->next;
        
        if (tasklet_trylock(t)) {  /* Check STATE_RUN */
            if (!atomic_read(&t->count)) {  /* Enabled? */
                clear_bit(TASKLET_STATE_SCHED, &t->state);
                t->func(t->data);
                tasklet_unlock(t);
                continue;
            }
            tasklet_unlock(t);
        }
        /* Couldn't run, reschedule */
    }
}
```
[Advanced]

Q: What happens if you schedule a tasklet that is already scheduled?
A: Nothing additional. The TASKLET_STATE_SCHED bit is already set, so the scheduling attempt returns immediately without adding a duplicate. The tasklet will run once when softirqs are processed.
[Intermediate]

Q: Compare tasklet context restrictions with workqueue context.
A: **Tasklet (softirq context)**:
- Cannot sleep
- Cannot use mutexes
- Must use GFP_ATOMIC
- Preemption disabled
**Workqueue (process context)**:
- Can sleep
- Can use mutexes
- Can use GFP_KERNEL
- Can be preempted
[Basic]

---

## Section 9: Workqueues

Q: What is a workqueue in Linux?
A: A workqueue is a mechanism for deferring work to be executed in process context by kernel threads. Unlike softirqs and tasklets, workqueue handlers CAN:
- Sleep and block
- Use mutexes and semaphores
- Call any kernel function
- Allocate memory with GFP_KERNEL
[Basic]

Q: What is `struct work_struct`?
A:
```c
struct work_struct {
    atomic_long_t data;           /* Work flags and list pointers */
    struct list_head entry;       /* Linked list entry */
    work_func_t func;             /* Work function */
};
```
Represents a single unit of work to be executed by a workqueue.
[Intermediate]

Q: What is `struct workqueue_struct`?
A: `struct workqueue_struct` represents a workqueue - a collection of kernel threads that process work items. It maintains per-CPU work lists and worker threads. Created with `create_workqueue()` or `alloc_workqueue()`.
[Intermediate]

Q: How do you declare and initialize a work_struct?
A:
```c
/* Static declaration */
DECLARE_WORK(name, func);

/* Dynamic initialization */
struct work_struct my_work;
INIT_WORK(&my_work, my_work_func);
```
[Basic]

Q: What is the function signature of a work handler?
A:
```c
void my_work_handler(struct work_struct *work);
```
The work pointer is passed to the handler. Use `container_of()` to get the enclosing structure if work is embedded in another struct.
[Basic]

Q: How do you queue work to a specific workqueue?
A:
```c
bool queue_work(struct workqueue_struct *wq, struct work_struct *work);
```
Returns true if work was queued, false if already pending. Work executes on one of the workqueue's threads.
[Basic]

Q: How do you use the default system workqueue?
A:
```c
schedule_work(&my_work);  /* Queue to system_wq (events) */
```
Equivalent to `queue_work(system_wq, &my_work)`. The system workqueue is shared; use your own for heavy work.
[Basic]

Q: What is the `events` workqueue?
A: The `events` workqueue (system_wq) is a default, shared workqueue available to all kernel code. Per-CPU worker threads process work items. Good for simple, quick work but shouldn't be used for long-running tasks as it's shared.
[Basic]

Q: How do you create a custom workqueue?
A:
```c
/* Multi-threaded (one thread per CPU) */
struct workqueue_struct *wq = create_workqueue("my_wq");

/* Single-threaded (one thread total) */
struct workqueue_struct *wq = create_singlethread_workqueue("my_wq");
```
[Basic]

Q: When should you create a custom workqueue vs using the system workqueue?
A: Create custom workqueue when:
- Work is long-running or may block for extended periods
- Need guaranteed ordering (single-threaded)
- Work should not interfere with other drivers
- Need specific CPU affinity
Use system_wq for quick, non-blocking tasks.
[Intermediate]

Q: What is `struct delayed_work`?
A:
```c
struct delayed_work {
    struct work_struct work;
    struct timer_list timer;
};
```
Wraps a work_struct with a timer, allowing work to be scheduled for execution after a delay.
[Intermediate]

Q: How do you schedule delayed work?
A:
```c
DECLARE_DELAYED_WORK(name, func);
/* or */
struct delayed_work dwork;
INIT_DELAYED_WORK(&dwork, my_handler);

/* Schedule with delay (in jiffies) */
schedule_delayed_work(&dwork, msecs_to_jiffies(100));
/* or to specific queue */
queue_delayed_work(wq, &dwork, HZ);  /* 1 second delay */
```
[Basic]

Q: How do you flush a workqueue?
A:
```c
void flush_workqueue(struct workqueue_struct *wq);
```
Blocks until all currently queued work items complete. Does NOT prevent new work from being queued during flush.
[Intermediate]

Q: How do you cancel pending work?
A:
```c
bool cancel_work_sync(struct work_struct *work);
```
Cancels the work and waits for it to complete if already running. Returns true if work was pending. Safe to call even if work not queued.
[Basic]

Q: What is `cancel_delayed_work_sync()` used for?
A:
```c
bool cancel_delayed_work_sync(struct delayed_work *dwork);
```
Cancels delayed work whether the timer is pending or the work is already running. Blocks until work completes if executing. Use before freeing delayed_work.
[Intermediate]

Q: How do you destroy a workqueue?
A:
```c
void destroy_workqueue(struct workqueue_struct *wq);
```
Flushes all pending work and destroys the workqueue. All work must be cancelled first or will complete during flush.
[Basic]

Q: Write a complete workqueue usage example.
A:
```c
struct my_device {
    struct work_struct work;
    /* ... device data ... */
};

static void my_work_handler(struct work_struct *work)
{
    struct my_device *dev = container_of(work, struct my_device, work);
    /* Can sleep here! */
    mutex_lock(&dev->mutex);
    /* ... process work ... */
    mutex_unlock(&dev->mutex);
}

/* In interrupt handler */
static irqreturn_t my_isr(int irq, void *data)
{
    struct my_device *dev = data;
    schedule_work(&dev->work);
    return IRQ_HANDLED;
}

/* In probe */
INIT_WORK(&dev->work, my_work_handler);

/* In remove */
cancel_work_sync(&dev->work);
```
[Intermediate]

Q: What is the `container_of()` macro used for with workqueues?
A: Since work handlers receive a `work_struct*`, use `container_of()` to get the enclosing structure:
```c
struct my_device *dev = container_of(work, struct my_device, work_member);
```
This retrieves the my_device pointer from the embedded work_struct.
[Intermediate]

Q: What is Concurrency Managed Workqueues (cmwq)?
A: CMWQ (introduced ~2.6.36, refined in 3.x) replaces traditional workqueues with:
- Automatic worker thread management
- Better concurrency control
- Reduced resource usage
- The `alloc_workqueue()` API with flags
In kernel 3.2, cmwq was becoming the standard implementation.
[Intermediate]

Q: What flags can be passed to `alloc_workqueue()`?
A:
```c
struct workqueue_struct *alloc_workqueue(const char *fmt,
                                          unsigned int flags,
                                          int max_active);
```
Common flags:
- `WQ_UNBOUND`: Not bound to specific CPU
- `WQ_HIGHPRI`: High-priority workers
- `WQ_MEM_RECLAIM`: May be used in memory reclaim path
- `WQ_FREEZABLE`: Work should not run during suspend
[Advanced]

Q: What is a "rescuer" thread in workqueue terminology?
A: A rescuer thread handles work when all worker threads are blocked (e.g., waiting for memory during OOM). Created for workqueues with `WQ_MEM_RECLAIM` flag. Ensures forward progress even under memory pressure.
[Advanced]

Q: What happens if you queue work that is already pending?
A: The `queue_work()` call returns false and the work remains queued once. Multiple queue attempts don't create duplicates. The work function runs once, regardless of how many times queued before execution.
[Intermediate]

Q: How do you ensure work completes before module unload?
A:
```c
/* In module exit */
cancel_work_sync(&my_work);        /* For regular work */
cancel_delayed_work_sync(&my_dwork); /* For delayed work */
destroy_workqueue(my_wq);          /* For custom workqueues */
```
All pending work must be cancelled or completed before freeing resources.
[Intermediate]

Q: What is `flush_scheduled_work()` and why is it deprecated?
A: `flush_scheduled_work()` flushes the system workqueue (events). It's deprecated because:
1) Flushes ALL work, not just yours
2) May deadlock if work schedules more work
3) Doesn't prevent new work being queued
Use `cancel_work_sync()` for specific work instead.
[Intermediate]

Q: Compare workqueue latency to tasklet latency.
A: **Tasklets** have lower latency because:
- Run in softirq context immediately after IRQ
- No context switch needed
- Higher priority than user processes
**Workqueues** have higher latency because:
- Need context switch to worker thread
- Worker may be sleeping or preempted
- May need to wait for other work to complete
[Intermediate]

---

## Section 10: Interrupt Control and Synchronization

Q: What does `local_irq_disable()` do?
A: `local_irq_disable()` disables hardware interrupts on the LOCAL CPU only:
- Executes CLI instruction (x86)
- Does NOT affect other CPUs
- Does NOT save previous interrupt state
- Use when you KNOW interrupts are enabled
[Basic]

Q: What does `local_irq_enable()` do?
A: `local_irq_enable()` enables hardware interrupts on the local CPU:
- Executes STI instruction (x86)
- Unconditionally enables interrupts
- Does NOT restore previous state
- Can race with `local_irq_disable()` if nested
[Basic]

Q: Why is `local_irq_save()`/`local_irq_restore()` preferred over disable/enable?
A: `local_irq_save()` saves the current interrupt state before disabling:
```c
unsigned long flags;
local_irq_save(flags);   /* Save state, disable IRQs */
/* critical section */
local_irq_restore(flags); /* Restore previous state */
```
This handles nesting correctly - if IRQs were already disabled, they stay disabled.
[Intermediate]

Q: What is the danger of using `local_irq_disable()`/`local_irq_enable()` pairs?
A: They don't nest correctly:
```c
local_irq_disable();    /* IRQs off */
  local_irq_disable();  /* Still off */
  local_irq_enable();   /* OOPS! IRQs now enabled! */
local_irq_enable();     /* Already enabled */
```
Use `local_irq_save()/restore()` for correct nesting.
[Intermediate]

Q: What does `disable_irq(irq)` do?
A: `disable_irq(irq)` disables a specific IRQ line across ALL CPUs:
- Increments irq_desc->depth
- Masks the IRQ at the interrupt controller
- WAITS for any running handler to complete
- Call `enable_irq(irq)` to re-enable
[Basic]

Q: What is the difference between `disable_irq()` and `disable_irq_nosync()`?
A: - `disable_irq(irq)`: Disables IRQ AND waits for running handler to complete. May sleep.
- `disable_irq_nosync(irq)`: Disables IRQ but does NOT wait. Cannot deadlock but handler may still be running.
Use nosync carefully - data accessed by handler may be in inconsistent state.
[Intermediate]

Q: When would you use `disable_irq_nosync()` instead of `disable_irq()`?
A: Use `disable_irq_nosync()` when:
- Called from the interrupt handler itself (would deadlock otherwise)
- In atomic context where waiting isn't allowed
- You'll ensure handler completion through other means
Example: Calling from within the IRQ handler to prevent re-entry.
[Intermediate]

Q: What does `enable_irq(irq)` do?
A: `enable_irq(irq)` re-enables a specific IRQ:
- Decrements irq_desc->depth
- When depth reaches 0, unmasks IRQ at hardware
- Allows nesting: must call enable same number of times as disable
[Basic]

Q: Why do disable_irq/enable_irq use a depth counter?
A: To support correct nesting:
```c
disable_irq(irq);  /* depth = 1 */
disable_irq(irq);  /* depth = 2 */
enable_irq(irq);   /* depth = 1, still disabled */
enable_irq(irq);   /* depth = 0, NOW enabled */
```
This allows different code paths to disable the same IRQ safely.
[Intermediate]

Q: What is `spin_lock_irqsave()` and when should you use it?
A:
```c
unsigned long flags;
spin_lock_irqsave(&lock, flags);
/* critical section */
spin_unlock_irqrestore(&lock, flags);
```
Use when the lock is shared between process context and interrupt handler. Disables local IRQs and acquires the lock.
[Intermediate]

Q: What is the difference between `spin_lock_irq()` and `spin_lock_irqsave()`?
A: - `spin_lock_irq()`: Disables IRQs, acquires lock. `spin_unlock_irq()` unconditionally enables IRQs.
- `spin_lock_irqsave()`: Saves IRQ state, disables, acquires lock. `spin_unlock_irqrestore()` restores previous state.
Use `_irqsave` when you don't know the current IRQ state.
[Intermediate]

Q: When can you safely use `spin_lock_irq()` instead of `spin_lock_irqsave()`?
A: Use `spin_lock_irq()` only when you KNOW interrupts are currently enabled:
- Entry points from user space (syscalls)
- Top of interrupt handlers (before re-enabling)
When unsure or in nested code paths, use `spin_lock_irqsave()`.
[Intermediate]

Q: What happens if you use a regular `spin_lock()` for data shared with an interrupt handler?
A: Potential deadlock:
```
CPU 0: spin_lock(&lock);
       <--- IRQ fires here
       IRQ handler: spin_lock(&lock);  // DEADLOCK!
```
The handler waits forever for a lock held by the interrupted code. Use `spin_lock_irqsave()` instead.
[Intermediate]

Q: What is `spin_lock_bh()` and when is it used?
A: `spin_lock_bh(&lock)` disables softirqs/bottom halves while holding the lock:
- Use for data shared between process context and softirqs/tasklets
- Does NOT disable hardware interrupts
- `spin_unlock_bh()` re-enables bottom halves
[Intermediate]

Q: Create a table showing which spin_lock variant to use.
A:
```
Data shared between:             | Use:
---------------------------------|------------------------
Process contexts only            | spin_lock()
Process + softirq/tasklet        | spin_lock_bh()
Process + hardirq handler        | spin_lock_irqsave()
Softirq + hardirq handler        | spin_lock_irqsave()
Two hardirq handlers             | spin_lock() (IRQs off)
```
[Intermediate]

Q: What is `synchronize_irq(irq)` used for?
A:
```c
void synchronize_irq(unsigned int irq);
```
Waits for any currently executing handler for this IRQ to complete. Does NOT prevent future handlers. Use before accessing data that handler might be using.
[Intermediate]

Q: How do you implement safe data access shared between interrupt handler and process context?
A:
```c
/* In process context */
spin_lock_irqsave(&dev->lock, flags);
dev->data = new_value;
spin_unlock_irqrestore(&dev->lock, flags);

/* In interrupt handler */
spin_lock(&dev->lock);  /* IRQs already disabled */
value = dev->data;
spin_unlock(&dev->lock);
```
[Intermediate]

Q: What is a potential deadlock scenario with nested IRQ disabling?
A:
```c
/* Thread A */                  /* Thread B (IRQ handler) */
spin_lock(&lock_a);             spin_lock(&lock_b);
spin_lock_irq(&lock_b);         spin_lock(&lock_a);
                                 /* DEADLOCK if IRQ fires during A */
```
Both wait for locks held by the other. Avoid holding multiple locks when IRQs can fire.
[Advanced]

Q: What does `irqs_disabled()` check?
A: `irqs_disabled()` returns true if local interrupts are currently disabled on this CPU. Useful for assertions:
```c
WARN_ON(!irqs_disabled());  /* Expect IRQs to be off */
```
Tests the IF flag or equivalent on the architecture.
[Intermediate]

Q: What is the difference between `local_bh_disable()` and `local_irq_disable()`?
A: - `local_irq_disable()`: Disables hardware interrupts (and implicitly softirqs)
- `local_bh_disable()`: Disables only softirqs/bottom halves, hardware IRQs can still fire
Use `local_bh_disable()` when only protecting against softirqs, for better latency.
[Intermediate]

---

## Section 11: Threaded Interrupts

Q: What are threaded interrupts?
A: Threaded interrupts split interrupt handling into:
1) **Primary handler**: Runs in hardirq context, quick acknowledgment
2) **Thread handler**: Runs in a dedicated kernel thread, can sleep
Introduced to support sleeping in interrupt handling and improve RT-preempt compatibility.
[Intermediate]

Q: What is the signature of `request_threaded_irq()`?
A:
```c
int request_threaded_irq(unsigned int irq,
                         irq_handler_t handler,        /* Primary/hardirq */
                         irq_handler_t thread_fn,      /* Thread handler */
                         unsigned long flags,
                         const char *name,
                         void *dev_id);
```
[Intermediate]

Q: What does the primary handler do in a threaded interrupt?
A: The primary handler runs in hardirq context and should:
1) Check if interrupt is from this device
2) Acknowledge the interrupt at hardware
3) Return IRQ_WAKE_THREAD to wake thread handler
4) OR return IRQ_HANDLED if no thread work needed
5) OR return IRQ_NONE if not this device's interrupt
[Intermediate]

Q: What return values are valid from a primary handler in threaded IRQ?
A: - `IRQ_NONE`: Not our interrupt
- `IRQ_HANDLED`: Handled completely, no thread needed
- `IRQ_WAKE_THREAD`: Wake the thread handler for further processing
Only IRQ_WAKE_THREAD causes the thread function to run.
[Intermediate]

Q: What can the thread handler do that the primary handler cannot?
A: The thread handler runs in process context, so it can:
- Sleep (msleep, wait_event, etc.)
- Use mutexes and semaphores
- Allocate memory with GFP_KERNEL
- Perform I/O operations that may block
- Call any kernel function
[Basic]

Q: What is the IRQF_ONESHOT flag?
A: `IRQF_ONESHOT` keeps the IRQ disabled after the primary handler returns until the thread handler completes. Required when:
- No primary handler (handler=NULL)
- Need to prevent interrupt re-triggering during thread execution
Without it, level-triggered IRQs would immediately re-fire.
[Intermediate]

Q: When is IRQF_ONESHOT required?
A: IRQF_ONESHOT is required when:
1) Primary handler is NULL (thread-only IRQ)
2) Hardware doesn't have a clear-on-read status register
3) Device needs to remain masked during lengthy processing
Level-triggered IRQs typically need it to prevent storm during thread execution.
[Intermediate]

Q: Write an example of requesting a threaded IRQ.
A:
```c
static irqreturn_t my_primary_handler(int irq, void *dev_id)
{
    struct my_dev *dev = dev_id;
    u32 status = readl(dev->base + IRQ_STATUS);
    if (!(status & MY_IRQ_BIT))
        return IRQ_NONE;
    writel(status, dev->base + IRQ_ACK);
    return IRQ_WAKE_THREAD;
}

static irqreturn_t my_thread_handler(int irq, void *dev_id)
{
    struct my_dev *dev = dev_id;
    mutex_lock(&dev->mutex);  /* Can sleep! */
    /* ... process data ... */
    mutex_unlock(&dev->mutex);
    return IRQ_HANDLED;
}

/* In probe: */
ret = request_threaded_irq(irq, my_primary_handler, my_thread_handler,
                           IRQF_SHARED, "my_device", dev);
```
[Intermediate]

Q: Can you have a threaded interrupt with no primary handler?
A: Yes, pass NULL for the handler parameter:
```c
request_threaded_irq(irq, NULL, thread_fn, IRQF_ONESHOT, "dev", data);
```
The kernel provides a default primary handler that just returns IRQ_WAKE_THREAD. IRQF_ONESHOT is required.
[Intermediate]

Q: What kernel thread runs the threaded interrupt handler?
A: A dedicated `irq/<irq>-<name>` kernel thread is created per registered threaded handler. Example: `irq/17-eth0`. This thread wakes when primary handler returns IRQ_WAKE_THREAD and calls thread_fn.
[Intermediate]

Q: How does `free_irq()` handle threaded interrupts?
A: `free_irq()` for threaded IRQs:
1) Waits for any running primary handler
2) Waits for any running thread handler
3) Stops and cleans up the irq thread
4) Frees the irqaction structure
Safe to call even if handlers are active - will wait.
[Intermediate]

Q: What are the advantages of threaded interrupts over tasklet + workqueue?
A: Advantages:
1) Simpler - one registration, automatic thread management
2) Better for RT-preempt - thread can be prioritized
3) Natural per-device thread - no shared workqueue concerns
4) IRQ masking handled automatically with IRQF_ONESHOT
5) Thread inherits IRQ priority in RT kernels
[Intermediate]

Q: How do threaded interrupts improve real-time performance?
A: In RT-preempt kernels:
1) Threaded handlers run as schedulable threads
2) Can assign real-time priority to IRQ threads
3) Higher-priority tasks can preempt IRQ processing
4) More predictable latency for critical tasks
5) Avoids long non-preemptible sections
[Advanced]

Q: What is the `irq_handler_t` type definition?
A:
```c
typedef irqreturn_t (*irq_handler_t)(int irq, void *dev_id);
```
Both primary handlers and thread handlers use this signature. The return type `irqreturn_t` is IRQ_NONE, IRQ_HANDLED, or IRQ_WAKE_THREAD.
[Basic]

Q: Compare threaded IRQ handlers to traditional top/bottom half split.
A:
```
Traditional:                   Threaded IRQ:
+------------------+           +------------------+
| Top half (ISR)   |           | Primary handler  |
| - hardirq context|           | - hardirq context|
| - can't sleep    |           | - can't sleep    |
+------------------+           +------------------+
        |                              |
        v                              v IRQ_WAKE_THREAD
+------------------+           +------------------+
| Tasklet/Softirq  |           | Thread handler   |
| - softirq context|           | - process context|
| - can't sleep    |           | - CAN sleep      |
+------------------+           +------------------+
        |                              
        v                      
+------------------+           
| Workqueue        |           
| - process context|           
| - can sleep      |           
+------------------+           
```
[Intermediate]

---

## Section 12: SMP and Interrupt Affinity

Q: What is IRQ affinity?
A: IRQ affinity determines which CPU(s) can handle a specific interrupt. Setting affinity allows:
- Binding interrupts to specific CPUs
- Load balancing across processors
- Improving cache locality
- Reducing cross-CPU contention
Configured via the I/O APIC redirection table.
[Basic]

Q: How do you view an IRQ's CPU affinity?
A: Read the sysfs file:
```
cat /proc/irq/<irq>/smp_affinity
```
Returns a hexadecimal bitmask where each bit represents a CPU. Example: `f` means CPUs 0-3, `1` means CPU 0 only.
[Basic]

Q: How do you set an IRQ's CPU affinity from userspace?
A: Write to the sysfs file:
```bash
echo 2 > /proc/irq/17/smp_affinity    # CPU 1 only
echo f > /proc/irq/17/smp_affinity    # CPUs 0-3
echo 5 > /proc/irq/17/smp_affinity    # CPUs 0 and 2
```
The mask is a hexadecimal bitmap of allowed CPUs.
[Basic]

Q: What is `irq_set_affinity()` used for?
A:
```c
int irq_set_affinity(unsigned int irq, const struct cpumask *mask);
```
Sets which CPUs can receive this IRQ from within kernel code. Returns 0 on success. Used by drivers that need specific CPU binding.
[Intermediate]

Q: What is `smp_affinity_list` in /proc/irq/<n>/?
A: `smp_affinity_list` shows/sets affinity as a CPU list instead of bitmask:
```
cat /proc/irq/17/smp_affinity_list
0-3              # CPUs 0 through 3
echo 0,2 > /proc/irq/17/smp_affinity_list  # CPUs 0 and 2
```
More readable for systems with many CPUs.
[Basic]

Q: What is the `irqbalance` daemon?
A: `irqbalance` is a userspace daemon that automatically distributes hardware interrupts across CPUs:
- Monitors interrupt rates
- Moves IRQs to balance load
- Considers NUMA topology and cache affinity
- Runs periodically to adapt to changing workloads
Commonly used on servers for automatic IRQ distribution.
[Basic]

Q: What are Inter-Processor Interrupts (IPIs)?
A: IPIs are interrupts that one CPU sends to another in an SMP system. Common uses:
- TLB shootdown (invalidate TLB on remote CPUs)
- Rescheduling (wake scheduler on remote CPU)
- Function calls (`smp_call_function()`)
- Stop/restart CPUs
Sent via the LAPIC's IPI mechanism.
[Intermediate]

Q: What is `smp_call_function()` used for?
A:
```c
int smp_call_function(void (*func)(void *), void *info, int wait);
```
Sends an IPI to ALL other CPUs to execute the given function. If `wait` is true, blocks until all CPUs complete. Used for cross-CPU synchronization.
[Intermediate]

Q: What is `smp_call_function_single()` used for?
A:
```c
int smp_call_function_single(int cpu, void (*func)(void *), 
                             void *info, int wait);
```
Sends an IPI to a specific CPU to execute the function. Returns 0 on success. Used when only one specific CPU needs to act.
[Intermediate]

Q: What is a TLB shootdown?
A: A TLB shootdown is the process of invalidating TLB entries across multiple CPUs when page tables change. One CPU sends IPIs to others, requesting TLB invalidation. Necessary because each CPU has its own TLB cache.
[Intermediate]

Q: What are per-CPU interrupts?
A: Per-CPU interrupts are delivered to a specific CPU and cannot be re-routed:
- Local APIC timer
- Performance monitoring counters
- Some device-specific interrupts (IRQF_PERCPU flag)
Each CPU handles its own instance independently.
[Intermediate]

Q: What is the IRQF_PERCPU flag?
A: `IRQF_PERCPU` marks an interrupt as per-CPU:
- Each CPU has its own handler registration
- Interrupt is not shared between CPUs
- No cross-CPU serialization needed
- Used for CPU-local devices (timers, performance counters)
[Intermediate]

Q: How does interrupt affinity affect performance?
A: Good affinity can improve performance by:
- Keeping data in local CPU caches (fewer cache misses)
- Reducing lock contention (same CPU handles related work)
- NUMA awareness (IRQ on same node as memory)
Poor affinity causes cache thrashing and increased latency.
[Intermediate]

Q: What is the impact of moving an IRQ to a different CPU?
A: Moving an IRQ affects:
- Cache locality (cold cache on new CPU)
- Any per-CPU data associated with the interrupt
- Latency (brief disruption during migration)
- Threaded IRQ handlers (thread may migrate)
Best done during low activity periods.
[Intermediate]

Q: What does `/proc/interrupts` show regarding SMP?
A: `/proc/interrupts` shows per-CPU interrupt counts:
```
           CPU0       CPU1       CPU2       CPU3
 17:      12345       6789       5432       8765  IR-IO-APIC-fasteoi   eth0
```
Columns show count per CPU. Unbalanced counts indicate affinity settings or natural workload distribution.
[Basic]

---

## Section 13: Interrupt Flow and Call Paths

Q: Draw the complete interrupt handling call path on x86.
A:
```
Hardware IRQ fires
       |
       v
CPU: IDT lookup -> interrupt gate
       |
       v
common_interrupt (entry_64.S / entry_32.S)
       |
       v
do_IRQ(regs)
       |
       v
handle_irq(irq, regs) or irq_enter() + generic_handle_irq()
       |
       v
irq_desc->handle_irq() [flow handler]
       |
       v
handle_irq_event() -> handle_irq_event_percpu()
       |
       v
action->handler(irq, dev_id) [device handler]
       |
       v
irq_exit() -> invoke_softirq() if pending
```
[Intermediate]

Q: What is `do_IRQ()` function?
A: `do_IRQ()` is the C entry point for hardware interrupts on x86:
```c
unsigned int __irq_entry do_IRQ(struct pt_regs *regs)
```
It determines the IRQ number from the vector, finds the irq_desc, and calls the appropriate handler. Defined in `arch/x86/kernel/irq.c`.
[Intermediate]

Q: What does `irq_enter()` do?
A: `irq_enter()` is called when entering interrupt context:
1) Increments preempt_count (HARDIRQ_OFFSET)
2) Updates accounting (irq_stat)
3) Traces interrupt entry (if enabled)
Ensures the kernel knows we're in interrupt context.
[Intermediate]

Q: What does `irq_exit()` do?
A: `irq_exit()` is called when leaving interrupt context:
1) Decrements preempt_count (HARDIRQ_OFFSET)
2) Checks for pending softirqs
3) If softirqs pending and not nested, calls invoke_softirq()
4) Updates accounting
5) May trigger preemption if needed
[Intermediate]

Q: What is a "flow handler" in interrupt handling?
A: A flow handler manages the interrupt controller interaction sequence for different IRQ types. It's stored in `irq_desc->handle_irq` and called by `generic_handle_irq()`. Examples:
- `handle_level_irq()`
- `handle_edge_irq()`
- `handle_fasteoi_irq()`
- `handle_simple_irq()`
[Intermediate]

Q: What does `handle_level_irq()` do?
A: `handle_level_irq()` handles level-triggered interrupts:
1) Mask the IRQ (prevent re-trigger)
2) Acknowledge the interrupt
3) Call device handler(s)
4) Unmask the IRQ
Must mask before handling because level stays asserted.
[Intermediate]

Q: What does `handle_edge_irq()` do?
A: `handle_edge_irq()` handles edge-triggered interrupts:
1) Acknowledge immediately (edge already captured)
2) Do NOT mask (edges are transient)
3) Call device handler(s)
4) Check if another edge occurred during handling
Handles the possibility of missed edges through re-checking.
[Intermediate]

Q: What does `handle_fasteoi_irq()` do?
A: `handle_fasteoi_irq()` is optimized for APIC-style controllers:
1) Don't mask before handling
2) Call device handler(s)
3) Send EOI after handling
"fasteoi" = fast end-of-interrupt. Most common on modern x86 systems.
[Intermediate]

Q: What is the difference between handle_level_irq and handle_fasteoi_irq?
A: - `handle_level_irq()`: Mask → ACK → Handle → Unmask
- `handle_fasteoi_irq()`: Handle → EOI only
fasteoi skips explicit mask/unmask, relying on the interrupt controller's ISR bit to prevent re-entry. More efficient for APIC.
[Intermediate]

Q: What is `handle_irq_event()`?
A: `handle_irq_event()` executes all handlers registered for an IRQ:
```c
irqreturn_t handle_irq_event(struct irq_desc *desc)
{
    /* Set IRQ_INPROGRESS */
    /* Call handle_irq_event_percpu() */
    /* Clear IRQ_INPROGRESS */
}
```
Called by flow handlers after controller-specific operations.
[Intermediate]

Q: What does `handle_irq_event_percpu()` do?
A: Walks the irqaction chain and calls each handler:
```c
for_each_action_of_desc(desc, action) {
    res = action->handler(irq, action->dev_id);
    switch (res) {
        case IRQ_WAKE_THREAD:
            __irq_wake_thread(desc, action);
            /* fall through */
        case IRQ_HANDLED:
            handled = true;
            break;
    }
}
```
[Advanced]

Q: What is `generic_handle_irq()`?
A:
```c
int generic_handle_irq(unsigned int irq)
{
    struct irq_desc *desc = irq_to_desc(irq);
    if (!desc)
        return -EINVAL;
    generic_handle_irq_desc(irq, desc);
    return 0;
}
```
Generic entry point to dispatch an IRQ to its flow handler. Used by interrupt controllers.
[Intermediate]

Q: Draw the call flow inside a flow handler (handle_fasteoi_irq example).
A:
```
handle_fasteoi_irq(irq, desc)
    |
    +---> raw_spin_lock(&desc->lock)
    |
    +---> mask_ack_irq(desc)  [if needed]
    |
    +---> handle_irq_event(desc)
    |         |
    |         +---> handle_irq_event_percpu()
    |                   |
    |                   +---> action->handler() for each action
    |
    +---> cond_unmask_eoi_irq(desc, chip)
    |         |
    |         +---> chip->irq_eoi()
    |
    +---> raw_spin_unlock(&desc->lock)
```
[Advanced]

Q: What is the role of `irq_chip->irq_ack()` in the flow?
A: `irq_ack()` acknowledges the interrupt at the controller level:
- For edge-triggered: Clears pending edge latch
- For level-triggered: Usually combined with mask
- For PIC: Sends EOI command
Called early in flow handlers to allow subsequent interrupts.
[Intermediate]

Q: What is the role of `irq_chip->irq_eoi()` in the flow?
A: `irq_eoi()` (End Of Interrupt) tells the controller handling is complete:
- APIC: Writes to EOI register, clears ISR bit
- Allows lower-priority interrupts
- Called after device handlers complete
For fasteoi flow, this is the only controller operation.
[Intermediate]

Q: How does the kernel handle shared interrupts in the call path?
A: The handler chain in irqaction is walked sequentially:
```c
for each action in desc->action list:
    ret = action->handler(irq, action->dev_id)
    if (ret == IRQ_HANDLED)
        mark as handled but continue checking others
    if (ret == IRQ_NONE)
        this device didn't cause the interrupt
```
All handlers are called; each checks if interrupt is theirs.
[Intermediate]

Q: What happens in the call path for threaded interrupts?
A: In handle_irq_event_percpu():
```c
res = action->handler(irq, dev_id);  /* primary handler */
if (res == IRQ_WAKE_THREAD) {
    __irq_wake_thread(desc, action);
    /* Wakes the irq/<n>-<name> thread */
    /* Thread runs action->thread_fn */
}
```
The thread runs later in process context.
[Intermediate]

Q: What is `__irq_wake_thread()` used for?
A: `__irq_wake_thread()` wakes the kernel thread for a threaded interrupt:
1) Sets IRQTF_RUNTHREAD flag in irqaction
2) Calls `wake_up_process(action->thread)`
3) Thread wakes and calls `action->thread_fn()`
Called when primary handler returns IRQ_WAKE_THREAD.
[Intermediate]

Q: What is the `irq_enter()`/`irq_exit()` timing relationship?
A:
```
do_IRQ()
   |
   +---> irq_enter()         # Enter interrupt context
   |
   +---> generic_handle_irq()
   |           |
   |           +---> flow_handler -> device handlers
   |
   +---> irq_exit()          # Exit interrupt context
              |
              +---> invoke_softirq() if pending
```
All device handlers run between irq_enter and irq_exit.
[Intermediate]

---

## Section 14: Exceptions and NMI

Q: What is the difference between an exception and an interrupt?
A: - **Exception**: Synchronous, caused by CPU during instruction execution (divide by zero, page fault, invalid opcode). Has a direct cause.
- **Interrupt**: Asynchronous, caused by external hardware. Can occur at any time, unrelated to current instruction.
Both use the IDT for dispatch.
[Basic]

Q: What are the three categories of x86 exceptions?
A: 1) **Faults**: Correctable, instruction restarted after handling (page fault)
2) **Traps**: Reported after instruction completes, continue at next instruction (breakpoint, syscall)
3) **Aborts**: Severe errors, cannot continue (double fault, machine check)
[Basic]

Q: List some important x86 exception vectors.
A:
```
Vector  Name                  Type
0       Divide Error          Fault
6       Invalid Opcode        Fault
8       Double Fault          Abort
13      General Protection    Fault
14      Page Fault            Fault
18      Machine Check         Abort
```
Vectors 0-31 are reserved for CPU exceptions.
[Intermediate]

Q: What is a page fault exception?
A: Page fault (vector 14) occurs when:
- Accessing unmapped virtual address
- Permission violation (write to read-only)
- Accessing non-present page
The handler examines CR2 (faulting address) and error code to determine the cause and response (allocate page, swap in, or SIGSEGV).
[Basic]

Q: What information does the page fault error code contain?
A: The error code bits indicate:
- Bit 0: Present (0=not present, 1=protection violation)
- Bit 1: Write (0=read, 1=write)
- Bit 2: User (0=kernel mode, 1=user mode)
- Bit 3: Reserved bit violation
- Bit 4: Instruction fetch
[Intermediate]

Q: What is the page fault handler call path?
A:
```
page_fault (entry point)
    |
    v
do_page_fault(regs, error_code)
    |
    v
__do_page_fault(regs, error_code, address)
    |
    +---> find_vma()  /* Find memory region */
    |
    +---> handle_mm_fault()  /* Handle the fault */
    |         |
    |         +---> Allocate page / swap in / COW
    |
    +---> if bad access: force_sig_fault(SIGSEGV)
```
[Intermediate]

Q: What is a General Protection Fault (GPF)?
A: GPF (vector 13) is a catch-all exception for protection violations:
- Segment limit violations
- Invalid segment selector
- Writing to read-only segment
- Privilege level violations
- Many other protection checks
In user space, typically causes SIGSEGV.
[Intermediate]

Q: What is a Double Fault?
A: A double fault (vector 8) occurs when an exception happens while trying to handle a previous exception:
- Example: Page fault handler triggers another page fault
- Uses a special Task State Segment (TSS) with known-good stack
- Usually indicates kernel bug or stack overflow
- Often unrecoverable
[Intermediate]

Q: What is an NMI (Non-Maskable Interrupt)?
A: NMI is a high-priority interrupt that cannot be disabled by software:
- Cannot be blocked by CLI or IF flag
- Used for critical events (hardware failure, watchdog)
- Vector 2 on x86
- Special handling required (cannot use normal IRQ infrastructure)
[Intermediate]

Q: What are common uses of NMI in Linux?
A: 1) **NMI watchdog**: Detects hung CPUs (no timer interrupts)
2) **Performance monitoring**: PMU overflow
3) **Hardware errors**: Memory ECC errors, bus errors
4) **Debugging**: Magic SysRq, crash dumps
5) **External devices**: Some legacy hardware
[Intermediate]

Q: What is the NMI watchdog?
A: The NMI watchdog detects system hangs by using NMI:
- Sends periodic NMIs to each CPU
- If CPU doesn't respond (increment counter), it's stuck
- Can detect hardlocks where regular timer interrupts don't fire
- Enabled with `nmi_watchdog=1` or perf events
[Intermediate]

Q: Why is NMI handling complex?
A: NMI handling is complex because:
1) NMIs can nest (NMI during NMI handler)
2) Cannot block NMIs, must handle carefully
3) Most locking primitives are unsafe
4) Can interrupt any code, even critical sections
5) May arrive during exception handling
Requires special "NMI-safe" code paths.
[Advanced]

Q: What is `do_nmi()` function?
A: `do_nmi()` is the C entry point for NMI handling on x86:
```c
dotraplinkage notrace void do_nmi(struct pt_regs *regs, long error_code)
{
    nmi_enter();
    /* Handle various NMI sources */
    /* - NMI watchdog */
    /* - Unknown NMI (print message) */
    nmi_exit();
}
```
[Intermediate]

Q: What is `nmi_enter()`/`nmi_exit()` used for?
A: These mark entry/exit from NMI context:
- Update preempt_count with NMI marker
- Prevent recursion issues
- Trace NMI entry/exit
- Allow checking `in_nmi()` to detect NMI context
Defined in `include/linux/hardirq.h`.
[Intermediate]

Q: What does `in_nmi()` check?
A: `in_nmi()` returns true if currently executing in NMI handler context. Used to:
- Select NMI-safe code paths
- Avoid unsafe operations (some locks, printk variants)
- Debug assertions
Returns non-zero when `preempt_count` has NMI bits set.
[Intermediate]

Q: How are system calls related to exceptions?
A: System calls use trap mechanisms:
- x86-64: `SYSCALL` instruction (not exception-based)
- x86-32: `INT 0x80` (software interrupt) or `SYSENTER`
- Handled via special entry points, not the exception path
System calls are synchronous, intentional traps to kernel mode.
[Intermediate]

---

## Section 15: Advanced Topics and Debugging

Q: How do you interpret `/proc/interrupts`?
A:
```
           CPU0       CPU1
  0:        45          0   IO-APIC-edge      timer
  1:         2          0   IO-APIC-edge      i8042
 17:      3847       2156   IO-APIC-fasteoi   eth0
NMI:         0          0   Non-maskable interrupts
LOC:    123456     123789   Local timer interrupts
```
Shows: IRQ#, per-CPU counts, controller type, device name(s).
[Basic]

Q: What does `/proc/softirqs` show?
A:
```
                    CPU0       CPU1
          HI:          1          0
       TIMER:      12345      12346
      NET_TX:        567        432
      NET_RX:       8901       7654
       BLOCK:        123        234
    TASKLET:          45         32
      SCHED:      54321      54322
        RCU:       9876       9877
```
Shows softirq execution counts per CPU per type.
[Basic]

Q: What is a spurious interrupt?
A: A spurious interrupt is an interrupt with no identifiable source:
- All handlers return IRQ_NONE
- Can be caused by: EMI noise, signal reflections, hardware bugs
- Kernel tracks them; too many may disable the IRQ
- Check `/proc/interrupts` for "spurious" count
[Intermediate]

Q: How does Linux handle spurious interrupts?
A: Kernel tracks spurious interrupts per IRQ:
```c
if (ret == IRQ_NONE) {
    desc->irqs_unhandled++;
    if (desc->irqs_unhandled > 99900) {
        __report_bad_irq(irq, desc, ret);
        desc->irq_count = 0;  /* Reset */
        /* May disable IRQ to prevent storm */
    }
}
```
[Intermediate]

Q: What is an IRQ storm and how is it mitigated?
A: An IRQ storm is rapid-fire interrupts overwhelming the CPU:
- Causes: Hardware malfunction, driver bug, stuck IRQ line
- Symptoms: High CPU usage in IRQ, unresponsive system
- Mitigation: Kernel may disable the IRQ after spurious threshold
- Fix: Debug hardware/driver, check for unacknowledged interrupts
[Intermediate]

Q: What is the `irqsoff` tracer?
A: `irqsoff` is an ftrace tracer that tracks maximum time with interrupts disabled:
```bash
echo irqsoff > /sys/kernel/debug/tracing/current_tracer
cat /sys/kernel/debug/tracing/tracing_max_latency
```
Helps find code paths that disable interrupts too long.
[Advanced]

Q: What is the `preemptirqsoff` tracer?
A: `preemptirqsoff` traces combined preemption and IRQ disable time:
- Shows maximum latency from either cause
- More comprehensive than irqsoff alone
- Used for RT latency debugging
- Shows call stack at worst-case point
[Advanced]

Q: How do you debug interrupt latency issues?
A: Tools and techniques:
1) `/proc/interrupts` - Check interrupt counts
2) `irqsoff` tracer - Find long IRQ-disabled sections
3) `ftrace` - Trace interrupt handlers
4) `perf` - Profile interrupt handlers
5) `cyclictest` - Measure system latency
6) Check for IRQ storms or handler issues
[Advanced]

Q: What is a soft lockup vs hard lockup?
A: - **Soft lockup**: CPU stuck in kernel without scheduling for >20s. Timer interrupts still work. Detected by watchdog task.
- **Hard lockup**: CPU completely stuck, timer interrupts not firing. Detected by NMI watchdog.
Both indicate kernel bugs (infinite loops, deadlocks).
[Intermediate]

Q: How does the kernel detect soft lockups?
A: A per-CPU watchdog thread monitors progress:
1) Watchdog thread updates timestamp when running
2) Timer interrupt checks if timestamp is stale
3) If no update for `watchdog_thresh` seconds, soft lockup warning
4) Indicates scheduler not running (kernel stuck somewhere)
[Intermediate]

Q: What common bugs occur in interrupt handler code?
A: Common mistakes:
1) Sleeping in interrupt context (deadlock/crash)
2) Using wrong spinlock variant (deadlock)
3) Not acknowledging interrupt (storm)
4) Accessing user memory (invalid)
5) Forgetting synchronize_irq before freeing resources
6) Long handler execution (latency)
[Intermediate]

Q: What happens if an interrupt handler tries to sleep?
A: Unpredictable behavior:
- May corrupt scheduler state
- May deadlock if waiting for interrupt
- `might_sleep()` checks will WARN
- System may crash or hang
- With CONFIG_DEBUG_ATOMIC_SLEEP, triggers BUG/WARN
[Basic]

Q: What debugging options help find interrupt bugs?
A: Kernel config options:
- `CONFIG_DEBUG_ATOMIC_SLEEP`: Warn on sleep in atomic context
- `CONFIG_PROVE_LOCKING`: Lockdep for lock order violations
- `CONFIG_DEBUG_SPINLOCK`: Debug spinlock misuse
- `CONFIG_IRQSOFF_TRACER`: Trace IRQ-disabled time
- `CONFIG_DEBUG_PREEMPT`: Debug preemption issues
[Intermediate]

Q: What is MSI (Message Signaled Interrupts) and why use it?
A: MSI replaces traditional IRQ lines with memory writes:
- Device writes to special memory address to signal interrupt
- No shared IRQ lines - each device gets unique vector
- More efficient: No EOI to interrupt controller
- Supports more interrupts than APIC pins
- Better for virtualization and PCIe devices
[Intermediate]

Q: How does MSI-X differ from MSI in practice?
A: MSI-X improvements:
- Up to 2048 vectors per device (vs 32 for MSI)
- Each vector independently configurable
- Per-vector masking capability
- Common in multi-queue NICs (one vector per queue)
- Better scalability for high-performance devices
[Advanced]

Q: What is IRQF_NOBALANCING used for?
A: `IRQF_NOBALANCING` excludes an IRQ from the irqbalance daemon's automatic redistribution:
- Use for IRQs that must stay on specific CPU
- Important for cache-sensitive handlers
- Needed when handler data is CPU-local
- Example: Per-CPU device interrupts
[Intermediate]

Q: What is IRQF_NO_SUSPEND used for?
A: `IRQF_NO_SUSPEND` prevents the IRQ from being disabled during system suspend:
- Used for wakeup-capable devices
- Device can still generate interrupts during suspend
- Combined with enable_irq_wake() for wakeup
- Example: Wake-on-LAN, power button
[Intermediate]

Q: Explain the misconception: "Disabling interrupts makes code safe."
A: Incorrect. `local_irq_disable()` only affects the LOCAL CPU:
- Other CPUs can still access shared data
- Need spinlocks for SMP safety
- `spin_lock_irqsave()` handles both IRQ and SMP protection
Single-CPU systems are rare; always consider SMP.
[Intermediate]

Q: Explain the misconception: "Tasklets can sleep because they're scheduled."
A: Incorrect. Despite being "scheduled," tasklets run in softirq context:
- Softirq context cannot sleep
- No backing process to reschedule to
- preemption is disabled
- Use workqueues if sleeping is needed
"Scheduled" means "deferred for later," not "schedulable."
[Intermediate]

Q: Explain the misconception: "interrupt handlers are always fast."
A: Not always true in practice:
- Poorly written handlers can be slow
- Some drivers do too much in top half
- PIO (programmed I/O) can be slow
- Debugging code may add latency
- Best practice: Keep handlers minimal, defer work
[Intermediate]

---

## End of Flashcards

Total cards: ~300
Covers Linux kernel v3.2 interrupt handling subsystem
Topics range from fundamentals to advanced debugging

