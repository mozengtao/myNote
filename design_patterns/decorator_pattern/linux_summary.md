
1. 装饰器模式核心要点（C 语言 / 内核视角）
特性		实现方式							内核适配优化
统一接口	函数指针结构体						 内核标准操作集（如file_operations、mem_ops）
装饰器封装	嵌套核心接口指针 + 封装函数			  内核容器化封装（如struct dm_target包裹底层块设备）
附加功能	封装函数中添加统计 / 加密 / 日志等	  内核软中断 / 工作队列（异步执行附加功能，不阻塞核心逻辑）
动态扩展	运行时替换函数指针					 内核模块参数（调试模式启用装饰器，生产禁用）

2. 内核装饰器模式的核心价值
解耦核心与附加逻辑：核心功能（如磁盘读写、内存分配）与附加功能（加密、统计、日志）完全分离，核心逻辑更稳定；
灵活扩展：可按需组合多个装饰器（如 “加密 + 日志 + 统计”），无需修改核心代码；
性能可控：调试 / 生产模式可切换装饰器，生产模式仅保留核心逻辑，无额外开销；
避免冗余：无需为每个功能组合创建独立的实现（如 “读写 + 日志”“读写 + 加密”“读写 + 日志 + 加密”），仅需嵌套装饰器。

3. 关键认知
Linux 内核中的装饰器模式不是 OOP 语法的照搬，而是思想层面的落地：
无 “装饰器类”，用「函数指针结构体 + 嵌套封装」实现装饰器层；
无 “继承”，用「持有核心接口指针 + 调用核心逻辑」实现功能复用；
无 “多态”，用「统一接口 + 函数指针替换」实现装饰器与核心组件的无缝替换；
核心目标是 “让核心功能专注于自身逻辑，附加功能通过装饰器动态挂载”，这也是设计模式的本质 —— 解决 “核心逻辑稳定” 与 “附加功能多变” 的耦合问题。