
1. 核心要点回顾
享元模式核心：区分内部 / 外部状态，复用内部状态固定的细粒度对象，减少内存占用和创建 / 销毁开销；
C 语言实现：通过「对象池（数组 / 链表）+ 工厂函数（获取 / 创建 / 回收）」实现，内部状态存储在结构体中，外部状态动态传入；
内核优化：内核优先使用 “预分配 + 空闲链表” 管理享元对象，避免运行时malloc/free，同时设置池大小上限平衡内存占用和复用率。

2. 内核享元模式的核心价值
减少内存碎片：Slab/skb/inode 缓存复用固定大小的内存块，避免频繁分配释放导致的碎片化；
提升性能：复用已有对象，避免磁盘 IO（inode）、内存分配（skb/Slab）的耗时操作；
节省内存：大量细粒度对象共享内部状态，仅存储一份不变数据（如 inode 的文件属性）。

3. 关键认知
内核中的享元模式无 OOP 的 “类 / 继承”，而是基于 “内存池 + 空闲链表” 的 C 语言特化实现，核心是 “复用” 而非 “对象抽象”；
内部状态的选择是关键：必须是不变、可共享的属性（如 Slab 对象大小、inode 号），外部状态需动态传入且不存储在享元对象中；
享元模式的本质是 “空间换时间”：预分配对象池占用少量内存，但节省了频繁创建 / 销毁对象的时间开销，这对高性能的内核场景至关重要