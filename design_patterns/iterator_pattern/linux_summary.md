
1. 迭代器模式核心要点（C 语言 / 内核视角）
特性			实现方式								内核适配优化
统一迭代接口	函数指针结构体（通用 C）/ 宏封装（内核）	内核优先使用宏（无函数调用开销，提升性能）
遍历逻辑封装	迭代器内部处理下标 / 指针移动、边界判断		内核提供 “安全迭代宏”（如list_for_each_entry_safe），避免删除节点崩溃
聚合对象适配	容器_of 宏（通过成员找结构体）				内核所有数据结构均支持容器_of，适配任意业务结构体
多态遍历	统一接口适配不同聚合对象						内核通过不同迭代宏（list/hlist/device）适配不同数据结构，上层逻辑统一

2. 内核迭代器模式的核心价值
简化遍历代码：内核开发者无需手写 “链表节点移动 + 边界判断 + 结构体转换” 的重复代码，仅需调用迭代器宏；
解耦数据结构与业务逻辑：聚合对象（如list_head、hlist）的内部实现修改后，遍历业务逻辑无需调整；
提升代码健壮性：迭代器宏封装了边界判断、空指针检查等逻辑，避免上层代码出现数组越界、链表空指针等错误；
适配多样化场景：内核提供正向 / 反向 / 安全 / 条件迭代器，满足不同遍历需求（如删除节点、筛选元素）。

3. 关键认知
Linux 内核中的迭代器模式不是 OOP 语法的照搬，而是基于 C 语言特性的特化实现：
无 “迭代器类”，用「宏封装遍历逻辑」替代函数指针（内核追求性能，避免函数调用开销）；
无 “接口继承”，用「统一宏参数格式」替代接口规范（如list_for_each_entry的参数格式统一）；
无 “抽象聚合对象”，用「container_of 宏」适配任意业务结构体，实现 “数据结构与业务解耦”；
核心目标是 “让内核开发者专注于业务逻辑（如筛选进程、管理设备），而非数据结构的遍历细节”，这也是设计模式的本质 —— 解决 “通用遍历逻辑” 与 “多样化数据结构” 的耦合问题。