- 为什么要copy_from_user
	- 为什么拷贝，不拷贝行不行？
		- 在内核态直接使用用户态传过来的指针`const char __user *buf`是灾难性的，因为buf的虚拟地址只在这个进程空间有效，跨进程是无效的。但是由于调度随时可能发生，workqueue是存在的，内核线程是存在的，其他进程是存在的，原先用户进程的的buf地址，切换进程后是没有任何意义的（页表发生了变化）
		- 内核的正确做法是，把buf拷贝到一个跨中断，跨进程，跨workqueue，跨内核线程的长期有效的内存里面，因为对内核而言，用户态传入的指针只是一个匆匆过客，瞬间即逝
		- 安全考虑
			- copy_from_user可以通过自带的access_ok(buf, len)进行检查，确保从buf开始的len长的区间一定是位于用户空间的，应用程序不能传入一个内核空间的地址给系统调用，否则内核会写坏内核本身，造成内核安全漏洞。
	- 为什么copy from user而不是memcpy？
		- copy_from_user()有自带的access_ok检查，如果用户传进来的buffer不属于用户空间而是内核空间，根本不会拷贝
		- copy_from_user()有自带的page fault后exception修复机制
			- 内核针对copy_from_user，有exception fixup机制，而memcpy()是没有的
			- 假设用户态向内核传入了一个不存在的用户空间地址，由于空间地址确实是用户态的，因此access_ok是没有问题的，但是这个地址根本没有有效的数据，此时内核会提示用户这个地址是个错误的地址，系统调用参数不对，用户态程序也不会死，只会收到bad address的错误，而不是产生kernel panic