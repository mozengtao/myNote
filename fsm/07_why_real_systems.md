# WHY | FSMs in Real Systems (Time, Failure, Retries)

## 1. Time as an Event Source

```
TIMERS GENERATE EVENTS, FSMs DON'T SLEEP
========================================

WRONG (FSM that sleeps):
+----------------------------------------------------+
|  case STATE_WAITING:                               |
|      sleep(5);           // FSM BLOCKED!           |
|      state = STATE_DONE; // What if event arrives? |
+----------------------------------------------------+

RIGHT (Timer generates event):
+----------------------------------------------------+
|  case STATE_WAITING:                               |
|      /* FSM returns immediately */                 |
|      /* External timer running */                  |
|      break;                                        |
|                                                    |
|  /* When timer fires: */                           |
|  fsm_dispatch(&fsm, EVENT_TIMEOUT);                |
+----------------------------------------------------+


The FSM Rule:
+------------------------------------------------------------+
| FSMs NEVER block, sleep, or wait.                          |
| FSMs respond INSTANTLY to events.                          |
| Time delays are modeled as EVENTS (timeout, ticker, etc.)  |
+------------------------------------------------------------+
```

```
TIMER INTEGRATION PATTERN
=========================

             +-----------+
             |   Timer   |
             | Subsystem |
             +-----+-----+
                   |
                   | EVENT_TIMEOUT (after N seconds)
                   v
             +-----------+
    Event -->|    FSM    |--> State Change
             +-----------+
                   |
                   | Action: start_timer(N)
                   v
             +-----------+
             |   Timer   |
             | Subsystem |
             +-----------+

Cycle:
1. FSM transitions to WAITING state
2. Action starts a timer (external)
3. FSM returns control (not blocking)
4. Timer fires after N seconds
5. Timer subsystem sends EVENT_TIMEOUT
6. FSM handles timeout event
```

```c
/* Timer Integration Example */

typedef enum {
    STATE_IDLE,
    STATE_CONNECTING,
    STATE_WAITING_ACK,
    STATE_CONNECTED,
    STATE_ERROR,
    STATE_COUNT
} state_t;

typedef enum {
    EVENT_CONNECT_REQ,
    EVENT_CONNECTED,
    EVENT_ACK_RECEIVED,
    EVENT_TIMEOUT,       /* Generated by timer */
    EVENT_ERROR,
    EVENT_COUNT
} event_t;

/* Timer context */
typedef struct {
    int timer_id;
    void (*on_timeout)(void *ctx);
    void *ctx;
} timer_t;

/* Connection context */
typedef struct {
    state_t state;
    int socket;
    timer_t *ack_timer;
    int retry_count;
} connection_t;

/* Actions */
int act_start_connect(void *ctx) {
    connection_t *c = ctx;
    c->socket = socket_connect(...);
    return 0;
}

int act_wait_for_ack(void *ctx) {
    connection_t *c = ctx;
    
    /* Start timer - does NOT block */
    c->ack_timer = timer_start(
        5000,  /* 5 seconds */
        timeout_callback,
        c
    );
    
    return 0;  /* Return immediately */
}

int act_handle_timeout(void *ctx) {
    connection_t *c = ctx;
    c->retry_count++;
    
    if (c->retry_count < 3) {
        /* Retry: send again and restart timer */
        send_request(c);
        timer_restart(c->ack_timer);
    }
    /* State transition handles retry vs error */
    return 0;
}

/* Timeout callback - external to FSM */
void timeout_callback(void *ctx) {
    connection_t *c = ctx;
    /* Generate event for FSM */
    fsm_dispatch(c, EVENT_TIMEOUT);
}

/* Transition table */
static const transition_t table[STATE_COUNT][EVENT_COUNT] = {
/*                CONNECT_REQ                 CONNECTED                    ACK_RECEIVED                TIMEOUT                       ERROR               */
[STATE_IDLE]       = {{STATE_CONNECTING, act_start_connect}, ILLEGAL,     ILLEGAL,                    ILLEGAL,                      ILLEGAL             },
[STATE_CONNECTING] = {ILLEGAL,           {STATE_WAITING_ACK, act_wait_for_ack}, ILLEGAL,              ILLEGAL,                      {STATE_ERROR, NULL} },
[STATE_WAITING_ACK]= {ILLEGAL,           ILLEGAL,            {STATE_CONNECTED, NULL}, {STATE_WAITING_ACK, act_handle_timeout}, {STATE_ERROR, NULL} },
[STATE_CONNECTED]  = {ILLEGAL,           ILLEGAL,            ILLEGAL,                    ILLEGAL,                      {STATE_ERROR, NULL} },
[STATE_ERROR]      = {ILLEGAL,           ILLEGAL,            ILLEGAL,                    ILLEGAL,                      ILLEGAL             },
};
```

---

## 2. Failure Modeling

```
FAILURE AS STATE
================

Failures are NOT exceptions to the FSM model.
Failures ARE states in the FSM.

Basic Error Pattern:
+--------+     error     +-------+
| NORMAL | ------------> | ERROR |
+--------+               +-------+
    ^                        |
    |       reset            |
    +------------------------+


Detailed Error Pattern:
+---------+     +---------+     +-----------+     +------------+
| WORKING | --> | RETRYING| --> | BACKOFF   | --> | FAILED     |
+---------+     +---------+     +-----------+     +------------+
     ^               |               |                 |
     |               |               |                 |
     +---------------+               |                 |
        success                      |                 |
                                     v                 v
                               +----------+      +----------+
                               | RECOVING |      | TERMINAL |
                               +----------+      +----------+
```

```
RETRY STATES
============

WRONG (Retry as a loop):
+----------------------------------------------------+
|  while (retry_count < MAX_RETRY) {                 |
|      if (try_connect() == SUCCESS) break;          |
|      retry_count++;                                |
|      sleep(backoff);  // BLOCKS FSM!               |
|  }                                                 |
+----------------------------------------------------+

RIGHT (Retry as state):
+----------------------------------------------------+
|  States:                                           |
|    CONNECTING                                      |
|    CONNECT_FAILED (transition: retry or give up)   |
|    WAITING_RETRY  (timeout will trigger retry)     |
|                                                    |
|  CONNECTING + ERROR --> CONNECT_FAILED             |
|  CONNECT_FAILED [retries < max] --> WAITING_RETRY  |
|  CONNECT_FAILED [retries >= max] --> FAILED        |
|  WAITING_RETRY + TIMEOUT --> CONNECTING            |
+----------------------------------------------------+


Retry State Diagram:
                                    
  +-----------+    error    +---------------+
  | CONNECTING| ----------> | CONNECT_FAILED|
  +-----------+             +---------------+
       ^                          |
       |                    [retries < max]
       |                          |
       |   timeout                v
       +<---------------  +---------------+
                          | WAITING_RETRY |
                          +---------------+
                          
                    [retries >= max]
                          |
                          v
                    +----------+
                    |  FAILED  |
                    +----------+
```

```
BACKOFF STATES
==============

Exponential backoff modeled as state + context:

Context:
  struct {
      int retry_count;
      int backoff_ms;     /* Current backoff duration */
  };

States:
  CONNECTING
  WAITING_BACKOFF
  FAILED

Transition Logic:
  CONNECTING + ERROR:
    if (retry_count < MAX_RETRIES) {
        backoff_ms = min(backoff_ms * 2, MAX_BACKOFF);
        start_timer(backoff_ms);
        -> WAITING_BACKOFF
    } else {
        -> FAILED
    }
    
  WAITING_BACKOFF + TIMEOUT:
    retry_count++;
    -> CONNECTING
```

```
TERMINAL VS RECOVERABLE FAILURE
===============================

Recoverable Failure:
  - Can transition back to operational state
  - Has reset/retry event
  - Resource may be temporarily unavailable
  
  Example:
    +-------+    error    +-------+    reset    +------+
    | READY | ----------> | ERROR | ----------> | IDLE |
    +-------+             +-------+             +------+


Terminal Failure:
  - No outgoing transitions (except cleanup)
  - System must be restarted
  - Unrecoverable resource corruption
  
  Example:
    +-------+    fatal    +----------+
    | READY | ----------> | TERMINAL |  (No transitions out)
    +-------+             +----------+
                               |
                          (cleanup, shutdown)


Design Question:
  "Can this error EVER be recovered automatically?"
  
  YES -> Recoverable failure state
  NO  -> Terminal failure state
```

---

## 3. Determinism Under Failure

```
WHY FSMs SIMPLIFY FAILURE HANDLING
==================================

Without FSM:
+------------------------------------------------------------+
| Error occurs:                                              |
|   - Where in the code path are we?                         |
|   - What resources are allocated?                          |
|   - What cleanup is needed?                                |
|   - What can we retry?                                     |
|   - How do we report this?                                 |
|                                                            |
| Answer: It depends on a complex combination of conditions  |
|         that may not be fully known.                       |
+------------------------------------------------------------+

With FSM:
+------------------------------------------------------------+
| Error occurs:                                              |
|   - Current state: SENDING                                 |
|   - Legal error handling: transition to ERROR state        |
|   - Cleanup: defined by state entry/exit actions           |
|   - Retry: defined by transitions from ERROR state         |
|   - Report: log state transition                           |
|                                                            |
| Answer: Exactly defined by FSM structure.                  |
+------------------------------------------------------------+
```

```
STATE-BASED CLEANUP
===================

Each state "knows" what resources it uses.
Error handling becomes state-based.

typedef struct {
    state_t state;
    int socket;           /* Valid in: CONNECTED, SENDING, RECEIVING */
    buffer_t *send_buf;   /* Valid in: SENDING */
    buffer_t *recv_buf;   /* Valid in: RECEIVING */
    timer_t *timeout;     /* Valid in: WAITING_* states */
} context_t;

/* Cleanup based on current state */
void cleanup_for_state(context_t *c) {
    switch (c->state) {
        case STATE_SENDING:
            buffer_free(c->send_buf);
            c->send_buf = NULL;
            /* FALLTHROUGH to CONNECTED cleanup */
        case STATE_CONNECTED:
            close(c->socket);
            c->socket = -1;
            break;
        case STATE_WAITING_TIMEOUT:
            timer_cancel(c->timeout);
            c->timeout = NULL;
            break;
        /* etc. */
    }
}

/* Or: Exit actions per state */
static void exit_sending(context_t *c) {
    if (c->send_buf) {
        buffer_free(c->send_buf);
        c->send_buf = NULL;
    }
}
```

```
FAILURE DETERMINISM TABLE
=========================

Every failure scenario is enumerable:

+----------------+----------------+------------------+---------------+
| Current State  | Failure Event  | Next State       | Cleanup Action|
+----------------+----------------+------------------+---------------+
| CONNECTING     | ERROR          | CONNECT_FAILED   | close socket  |
| CONNECTED      | ERROR          | DISCONNECTED     | close socket  |
| SENDING        | ERROR          | SEND_FAILED      | free buffer   |
| SENDING        | TIMEOUT        | SEND_TIMEOUT     | free buffer   |
| RECEIVING      | ERROR          | RECV_FAILED      | free buffer   |
| WAITING_ACK    | TIMEOUT        | ACK_TIMEOUT      | incr retry    |
+----------------+----------------+------------------+---------------+

No hidden failure paths.
Every error is explicitly handled.
```

```c
/* Complete Failure-Handling FSM Example */

typedef enum {
    STATE_IDLE,
    STATE_CONNECTING,
    STATE_CONNECTED,
    STATE_SENDING,
    STATE_WAITING_RETRY,
    STATE_ERROR,
    STATE_FATAL,
    STATE_COUNT
} state_t;

typedef enum {
    EVENT_CONNECT,
    EVENT_CONNECTED,
    EVENT_SEND,
    EVENT_SENT,
    EVENT_ERROR,
    EVENT_TIMEOUT,
    EVENT_RESET,
    EVENT_COUNT
} event_t;

typedef struct {
    state_t state;
    int socket;
    int retry_count;
    int backoff_ms;
    timer_t *timer;
} fsm_ctx_t;

/* Actions */
static int act_start_connect(void *v) {
    fsm_ctx_t *c = v;
    c->socket = socket(AF_INET, SOCK_STREAM, 0);
    if (c->socket < 0) return -1;
    return connect_nonblock(c->socket, ...);
}

static int act_handle_error(void *v) {
    fsm_ctx_t *c = v;
    
    if (c->socket >= 0) {
        close(c->socket);
        c->socket = -1;
    }
    
    if (c->retry_count < 3) {
        /* Schedule retry with backoff */
        c->backoff_ms = (c->backoff_ms == 0) ? 1000 : c->backoff_ms * 2;
        c->timer = timer_start(c->backoff_ms, timeout_cb, c);
        /* Transition to WAITING_RETRY handled by table */
    }
    
    return 0;
}

static int act_retry(void *v) {
    fsm_ctx_t *c = v;
    c->retry_count++;
    return act_start_connect(v);
}

static int act_fatal(void *v) {
    fsm_ctx_t *c = v;
    /* Log fatal error */
    fprintf(stderr, "FATAL: Unrecoverable error after %d retries\n",
            c->retry_count);
    /* Cleanup all resources */
    if (c->socket >= 0) close(c->socket);
    if (c->timer) timer_cancel(c->timer);
    return 0;
}

static int act_reset(void *v) {
    fsm_ctx_t *c = v;
    c->retry_count = 0;
    c->backoff_ms = 0;
    return 0;
}

/* Guard: can we retry? */
static bool can_retry(fsm_ctx_t *c) {
    return c->retry_count < 3;
}

/* Transition table with guards */
/* For simplicity, guards implemented in action or separate dispatch */
static const transition_t table[STATE_COUNT][EVENT_COUNT] = {
/*                CONNECT                         CONNECTED               SEND                        SENT                        ERROR                            TIMEOUT                     RESET                    */
[STATE_IDLE]      = {{STATE_CONNECTING, act_start_connect}, ILLEGAL,    ILLEGAL,                    ILLEGAL,                    ILLEGAL,                         ILLEGAL,                    ILLEGAL                  },
[STATE_CONNECTING]= {ILLEGAL,                               {STATE_CONNECTED, NULL}, ILLEGAL,       ILLEGAL,                    {STATE_WAITING_RETRY, act_handle_error}, ILLEGAL,             ILLEGAL                  },
[STATE_CONNECTED] = {ILLEGAL,                               ILLEGAL,    {STATE_SENDING, NULL},      ILLEGAL,                    {STATE_WAITING_RETRY, act_handle_error}, ILLEGAL,             ILLEGAL                  },
[STATE_SENDING]   = {ILLEGAL,                               ILLEGAL,    ILLEGAL,                    {STATE_CONNECTED, NULL},    {STATE_WAITING_RETRY, act_handle_error}, {STATE_ERROR, NULL}, ILLEGAL                  },
[STATE_WAITING_RETRY]= {ILLEGAL,                            ILLEGAL,    ILLEGAL,                    ILLEGAL,                    {STATE_FATAL, act_fatal},        {STATE_CONNECTING, act_retry}, ILLEGAL              },
[STATE_ERROR]     = {ILLEGAL,                               ILLEGAL,    ILLEGAL,                    ILLEGAL,                    ILLEGAL,                         ILLEGAL,                    {STATE_IDLE, act_reset}  },
[STATE_FATAL]     = {ILLEGAL,                               ILLEGAL,    ILLEGAL,                    ILLEGAL,                    ILLEGAL,                         ILLEGAL,                    ILLEGAL                  },
};
```

---

## Summary: FSMs Under Real-World Conditions

```
+----------------------------------------------------------+
|                                                          |
|  TIME:                                                   |
|    - Timers are event sources                            |
|    - FSMs never sleep/block                              |
|    - Timeouts trigger state transitions                  |
|                                                          |
|  FAILURE:                                                |
|    - Errors are states, not exceptions                   |
|    - Retries are state loops                             |
|    - Backoff is state + context                          |
|    - Terminal vs recoverable is explicit                 |
|                                                          |
|  DETERMINISM:                                            |
|    - Every failure path is enumerable                    |
|    - Cleanup is state-based                              |
|    - No hidden error conditions                          |
|                                                          |
+----------------------------------------------------------+
```

---

**中文解释（Chinese Explanation）**

**时间作为事件源**

FSM 规则：**FSM 绝不阻塞、睡眠或等待**。FSM 立即响应事件，时间延迟被建模为事件。

定时器集成模式：
1. FSM 转换到等待状态
2. 动作启动定时器（外部）
3. FSM 返回控制（不阻塞）
4. 定时器在 N 秒后触发
5. 定时器子系统发送 EVENT_TIMEOUT
6. FSM 处理超时事件

**故障建模**

故障不是 FSM 模型的例外，故障**就是** FSM 的状态。

**重试状态**：不要在循环中重试（会阻塞 FSM）。将重试建模为状态：
- CONNECTING + ERROR → CONNECT_FAILED
- CONNECT_FAILED [重试次数 < 最大] → WAITING_RETRY
- WAITING_RETRY + TIMEOUT → CONNECTING（重新开始）

**退避状态**：指数退避通过状态 + 上下文建模。上下文存储 `backoff_ms`，每次重试翻倍。

**终止 vs 可恢复故障**：
- 可恢复：可以转换回正常状态，有重置/重试事件
- 终止：没有出站转换，系统必须重启

设计问题："这个错误能否自动恢复？"——能则可恢复状态，不能则终止状态。

**确定性故障处理**

FSM 简化故障处理的原因：
- 无 FSM 时：错误发生后，不知道在代码路径的哪里、分配了什么资源、需要什么清理
- 有 FSM 时：当前状态明确、合法错误处理由转换定义、清理由状态入口/出口动作定义

基于状态的清理：每个状态"知道"它使用什么资源。错误处理变成基于状态的，每个故障场景都可枚举，没有隐藏的故障路径。
