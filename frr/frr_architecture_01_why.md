# FRR Architecture Guide - Part 1: WHY | Engineering Motivation

## ASCII Architecture Overview

```
+==============================================================================+
|                    WHY FRR EXISTS - Engineering Motivation                   |
+==============================================================================+

                         THE FUNDAMENTAL PROBLEM
+-----------------------------------------------------------------------------+
|                                                                             |
|    Static Routing World                    Dynamic Routing World            |
|    ====================                    =====================            |
|                                                                             |
|    +-------+     +-------+                 +-------+     +-------+          |
|    |Router1|--X--|Router2|                 |Router1|--X--|Router2|          |
|    +---+---+     +---+---+                 +---+---+     +---+---+          |
|        |             |                         |             |              |
|        |   LINK      |                         |   LINK      |              |
|        |   FAILS     |                         |   FAILS     |              |
|        v             v                         v             v              |
|                                                                             |
|    Manual fix        Traffic                Auto-detect    Traffic          |
|    required!         BLACK HOLE             + reroute      RECOVERS         |
|    Hours later...    for hours              Seconds!       in seconds       |
|                                                                             |
+-----------------------------------------------------------------------------+

                    CONTROL PLANE vs DATA PLANE SEPARATION
+-----------------------------------------------------------------------------+
|                                                                             |
|  +---------------------------+        +---------------------------+         |
|  |      CONTROL PLANE        |        |       DATA PLANE          |         |
|  |      (FRR Daemons)        |        |       (Linux Kernel)      |         |
|  +---------------------------+        +---------------------------+         |
|  |                           |        |                           |         |
|  | - Protocol State Machines |        | - Packet Forwarding       |         |
|  | - Route Selection         |   -->  | - FIB (Forwarding Table)  |         |
|  | - Policy Decisions        |        | - Interface Management    |         |
|  | - Neighbor Discovery      |        | - Hardware Offload        |         |
|  | - Path Computation        |        |                           |         |
|  |                           |        |                           |         |
|  +---------------------------+        +---------------------------+         |
|           ^                                       |                         |
|           |         FEEDBACK LOOP                 |                         |
|           +---------------------------------------+                         |
|                  (Interface state, etc.)                                    |
|                                                                             |
+-----------------------------------------------------------------------------+

                         FRR DAEMON ARCHITECTURE
+-----------------------------------------------------------------------------+
|                                                                             |
|   User Space                                                                |
|   +-----------------------------------------------------------------------+ |
|   |                                                                       | |
|   |  +---------+  +---------+  +---------+  +---------+  +---------+     | |
|   |  |  bgpd   |  |  ospfd  |  |  isisd  |  |  ripd   |  | staticd |     | |
|   |  | (BGP)   |  | (OSPF)  |  | (IS-IS) |  | (RIP)   |  | (Static)|     | |
|   |  +----+----+  +----+----+  +----+----+  +----+----+  +----+----+     | |
|   |       |            |            |            |            |          | |
|   |       |            |            |            |            |          | |
|   |       +------------+------------+------------+------------+          | |
|   |                              |                                       | |
|   |                              v                                       | |
|   |                    +-----------------+                               | |
|   |                    |      zebra      |  <-- Central Route Manager    | |
|   |                    | (RIB Manager)   |                               | |
|   |                    +--------+--------+                               | |
|   |                             |                                        | |
|   +-----------------------------------------------------------------------+ |
|                                 |                                           |
|   - - - - - - - - - - - - - - - | - - - - - - - - - - - - - - - - - - - - - |
|                                 | Netlink                                   |
|   Kernel Space                  v                                           |
|   +-----------------------------------------------------------------------+ |
|   |                    +------------------+                               | |
|   |                    |   Linux Kernel   |                               | |
|   |                    |   Routing Stack  |                               | |
|   |                    |   (FIB + NICs)   |                               | |
|   |                    +------------------+                               | |
|   +-----------------------------------------------------------------------+ |
|                                                                             |
+-----------------------------------------------------------------------------+

                    EVOLUTION: ZEBRA → QUAGGA → FRR
+-----------------------------------------------------------------------------+
|                                                                             |
|   1996-2005              2005-2016              2016-Present                |
|   =========              =========              ==============              |
|                                                                             |
|   +--------+             +--------+             +--------+                  |
|   | Zebra  |  ------>    | Quagga |  ------>    |  FRR   |                  |
|   +--------+             +--------+             +--------+                  |
|       |                      |                      |                       |
|       v                      v                      v                       |
|   - First open           - Community           - Active                     |
|     source routing         fork after            development               |
|     suite                  Zebra stalled       - Modern features            |
|   - Established          - Limited              - YANG/gRPC                 |
|     daemon model           development         - Performance                |
|   - Multi-protocol       - Still widely          improvements              |
|                            deployed            - Cloud-native               |
|                                                                             |
+-----------------------------------------------------------------------------+
```

---

## 中文详细说明

### 1. FRR 解决的核心工程问题

#### 为什么静态路由不够用？

**静态路由的局限性：**
- **无法自动故障恢复**：当链路故障时，静态路由不会自动切换到备用路径
- **配置复杂度爆炸**：N个节点的全连接网络需要 N×(N-1) 条静态路由
- **缺乏负载均衡能力**：无法根据网络状况动态调整流量路径
- **运维成本高**：每次拓扑变化都需要人工更新所有受影响设备

#### 为什么路由逻辑不能完全在内核中实现？

**内核空间的限制：**
1. **复杂性管理**：BGP、OSPF 等协议涉及复杂的状态机，在内核实现会增加内核复杂度和安全风险
2. **调试困难**：内核代码调试成本远高于用户空间
3. **稳定性要求**：内核崩溃会导致整个系统宕机，而用户空间守护进程可以独立重启
4. **灵活性**：策略配置、协议扩展在用户空间更容易实现

---

### 2. 没有 FRR 类软件时系统如何退化？

```
问题场景分析：
+------------------------------------------------------------------+
|  问题                    |  无动态路由的后果      |  恢复时间    |
+------------------------------------------------------------------+
|  链路故障                |  流量黑洞              |  分钟~小时   |
|  设备故障                |  需人工切换            |  分钟~小时   |
|  网络扩容                |  需更新所有设备配置    |  小时~天     |
|  负载不均                |  无法自动均衡          |  持续存在    |
|  路由环路                |  可能长期存在          |  难以定位    |
+------------------------------------------------------------------+
```

**典型退化模式：**
1. **手动配置风险**：人为错误导致路由黑洞或环路
2. **慢速故障恢复**：依赖监控告警 + 人工干预
3. **路由状态不一致**：不同设备上的路由表可能冲突
4. **转发逻辑与路由逻辑耦合**：修改困难，测试复杂

---

### 3. FRR 管理的主要复杂性

```
复杂性分层：
+==================================================================+
|  层次              |  具体复杂性                                  |
+==================================================================+
|  分布式状态收敛     |  - 多节点间路由信息同步                      |
|                    |  - 最短路径计算 (Dijkstra/Bellman-Ford)      |
|                    |  - 收敛时间优化                              |
+------------------------------------------------------------------+
|  协议特定复杂性     |  - BGP: AS 路径、策略、大规模邻居管理        |
|                    |  - OSPF: 区域划分、LSA 泛洪、DR/BDR 选举     |
|                    |  - IS-IS: Level 1/2 层次结构                 |
+------------------------------------------------------------------+
|  策略控制          |  - 路由过滤 (prefix-list, route-map)         |
|                    |  - 路径选择策略                              |
|                    |  - 流量工程                                  |
+------------------------------------------------------------------+
|  内核交互          |  - Netlink 消息处理                          |
|                    |  - VRF / Namespace 支持                      |
|                    |  - 路由表同步                                |
+------------------------------------------------------------------+
|  守护进程生命周期  |  - 优雅重启                                  |
|                    |  - 状态持久化                                |
|                    |  - 进程间通信                                |
+==================================================================+
```

---

### 4. 历史背景与架构选择

#### Zebra → Quagga → FRR 演进

| 时期 | 项目 | 特点 |
|------|------|------|
| 1996-2005 | Zebra | 首个开源路由套件，确立了多守护进程架构 |
| 2005-2016 | Quagga | Zebra 社区分支，维护性更新为主 |
| 2016-至今 | FRR | 积极开发，添加现代特性（YANG、gRPC、EVPN 等）|

#### 为什么使用多守护进程而非单体架构？

```
多守护进程优势：
+------------------------------------------------------------------+
|  1. 故障隔离：单个协议守护进程崩溃不影响其他协议                 |
|  2. 独立升级：可以单独升级 bgpd 而不影响 ospfd                   |
|  3. 资源隔离：每个守护进程有独立的内存和 CPU 配额                |
|  4. 调试便利：可以单独 attach 调试器到某个守护进程               |
|  5. 部署灵活：根据需要只启动必要的守护进程                       |
+------------------------------------------------------------------+
```

#### 为什么使用 C 语言？

1. **性能要求**：路由协议需要高效处理大量更新
2. **系统调用亲和**：直接使用 POSIX API 和 Netlink
3. **历史传承**：从 Zebra 时代延续
4. **生态系统**：与 Linux 内核和网络工具链一致

#### 为什么针对 Unix-like 系统？

1. **Netlink 接口**：Linux 特有的内核通信机制
2. **VRF 支持**：Linux 3.x+ 内核特性
3. **BSD 兼容**：支持 routing socket
4. **容器化**：现代云原生部署需求

---

### 5. 核心设计原则

从 `event.c` 代码中可以看到 FRR 的核心设计：

```c
/* 从 event.c 第 66-71 行 */
/* control variable for initializer */
static pthread_once_t init_once = PTHREAD_ONCE_INIT;
pthread_key_t thread_current;

static pthread_mutex_t masters_mtx = PTHREAD_MUTEX_INITIALIZER;
static struct list *masters;
```

**体现的设计原则：**
1. **线程安全初始化**：使用 `pthread_once` 确保单次初始化
2. **事件驱动模型**：`event_loop` 结构管理所有事件
3. **模块化**：共享库 (`lib/`) 提供基础设施
4. **显式状态管理**：事件类型、状态清晰定义

```c
/* 事件类型定义（概念层面）*/
typedef enum {
    EVENT_READ,      // I/O 可读事件
    EVENT_WRITE,     // I/O 可写事件
    EVENT_TIMER,     // 定时器事件
    EVENT_EVENT,     // 普通事件
    EVENT_READY,     // 就绪事件
    EVENT_EXECUTE,   // 立即执行事件
    EVENT_UNUSED     // 未使用
} event_type_t;
```

这种设计使得 FRR 能够：
- 高效处理数千个并发事件
- 精确控制定时器（协议超时、保活等）
- 在单线程模型中管理复杂状态机
