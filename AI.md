[OpenAI Cookbook](https://cookbook.openai.com/)  
[Prompt Engineering Guide](https://www.promptingguide.ai/)  
[Prompt Engineering Guide](https://learnprompting.org/docs/introduction)  
[Five proven prompt engineering techniques](https://www.lennysnewsletter.com/p/five-proven-prompt-engineering-techniques)  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[]()  
[gemini-cli](https://github.com/google-gemini/gemini-cli)  
[Gemini CLI documentation](https://geminicli.com/docs/)  


## Coding Platform
[Cursor](https://cursor.com/home)  
[Claude](https://claude.ai/)  
[Qoder](https://qoder.com/)  

### Cursor
[How I use Cursor](https://www.builder.io/blog/cursor-tips)  
[cursor.directory](https://cursor.directory/)  
[Rules](https://docs.cursor.com/en/context/rules)  
[]()  
[]()  
```shortcuts
Settings
    Ctrl + Shift + j
```

## Online
[ChatGPT](https://chatgpt.com/)  
[Grok](https://grok.com/)  
[KiMi](https://kimi.moonshot.cn/)  
[Gmini](https://gemini.google.com/app)  
[NoteBookLM](https://notebooklm.google.com/)  
[DeepSeek](https://chat.deepseek.com/)  
[hix.ai/](https://hix.ai/)  
[Ithy](https://ithy.com/)  
[å­—èŠ‚è±†åŒ…](https://www.doubao.com/chat/)  
[è…¾è®¯å…ƒå®](https://yuanbao.tencent.com/chat/)  
[é˜¿é‡Œé€šä¹‰](https://tongyi.aliyun.com/qianwen/)  




[Learn The Art of Prompting](https://www.learnprompt.org/)  
[A Comprehensive Guide to Using ChatGPT Prompts for Coding Tasks](https://www.learnprompt.org/chat-gpt-prompts-for-coding/)  
[Unleashing ChatGPT for Programmers](https://www.learnprompt.org/chatgpt-prompts-for-programmers/)  
[Prompts for Code Generation, Debugging, Optimization, and More](https://www.learnprompt.org/chatgpt-prompts-for-developers/)  
[My Top 17 ChatGPT Prompts for Coding](https://www.fullstackfoundations.com/blog/chatgpt-prompts-for-coding#chatgpt-prompts-for-learning-to-code)  
[DEV ChatGPT Prompts](https://github.com/PickleBoxer/dev-chatgpt-prompts)  
[awesome-chatgpt-prompts](https://github.com/f/awesome-chatgpt-prompts)  
[280+ ChatGPT Prompts & How to Write Your Own](https://writesonic.com/blog/chatgpt-prompts)  
[Check These 100 Powerful ChatGPT Prompts For Every Situation](https://growthtribe.io/blog/chatgpt-prompts/)  
[500+ Best Prompts for ChatGPT](https://www.godofprompt.ai/blog/500-best-prompts-for-chatgpt-2024?srsltid=AfmBOorDz97w7PxISB5pLqsCH1hYRaXwd7yqJdi-pBhu8a8UBRZD66mA)  
[]()  
[]()  


[LLM åº”ç”¨å¼€å‘å®è·µç¬”è®°](https://aitutor.liduos.com/)  
[é¢å‘å¼€å‘è€…çš„å¤§æ¨¡å‹æ‰‹å†Œ](https://datawhalechina.github.io/llm-cookbook/#/)  

## Prompt
![ChatGPT Prompts](./assets/ChatGPT_Prompts.pdf)  
[]()  
```
ConfD é…ç½®äº‹åŠ¡ (commit)
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Work ç»“æ„ä½“ (å·¥ä½œåˆ—è¡¨)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚  â”‚ w->list â”‚â”€â”€â–º Witem â”€â”€â–º Witem â”€â”€â–º nil â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    (å˜æ›´1)   (å˜æ›´2)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ASCII Art Diagramï¼ˆASCII è‰ºæœ¯å›¾ï¼‰æˆ– Text-based Diagramï¼ˆçº¯æ–‡æœ¬å›¾è¡¨ï¼‰

åç§°	                            è¯´æ˜
ASCII Flow Chart	                ASCII æµç¨‹å›¾ - å±•ç¤ºæµç¨‹å’Œæ­¥éª¤
ASCII Box Diagram	                ASCII æ–¹æ¡†å›¾ - ç”¨æ–¹æ¡†è¡¨ç¤ºç»„ä»¶
ASCII Data Structure Diagram	    ASCII æ•°æ®ç»“æ„å›¾ - å±•ç¤ºé“¾è¡¨ã€æ ‘ç­‰ç»“æ„
ASCII Architecture Diagram	        ASCII æ¶æ„å›¾ - å±•ç¤ºç³»ç»Ÿç»„ä»¶å…³ç³»

ASCII Art ä¸­æ–‡å¯¹é½é—®é¢˜ï¼š
æ¨èåšæ³•
    å¯¹äºæŠ€æœ¯æ–‡æ¡£ï¼Œæœ€ç®€å•çš„æ–¹æ¡ˆæ˜¯ï¼š
    1. çº¯è‹±æ–‡ ç»˜åˆ¶ ASCII å›¾
    2. å›¾ä¸‹æ–¹ ç”¨æ™®é€šæ–‡å­—æ·»åŠ ä¸­æ–‡è¯´æ˜

ç¤ºä¾‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Work Structure (worklist)              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚  â”‚ w->list â”‚â”€â”€â–º Witem â”€â”€â–º Witem â”€â”€â–º nil â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    (item1)   (item2)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è¯´æ˜ï¼šWork æ˜¯å·¥ä½œç»“æ„ä½“ï¼ŒåŒ…å«ä¸€ä¸ª Witem é“¾è¡¨ï¼Œ
æ¯ä¸ª Witem ä»£è¡¨ä¸€ä¸ªé…ç½®å˜æ›´é¡¹ã€‚
```
- æ ¸å¿ƒåŸåˆ™ (5W1H + R)
```
| åŸåˆ™                          | å«ä¹‰               | è¯´æ˜              |
| -------------------------    | ----------         | --------------- |
| **1. What â€“ ä¸»é¢˜æ˜ç¡®**        | å‘Šè¯‰æˆ‘ä½ æƒ³è¦ä»€ä¹ˆ    | æ¨¡ç³Šçš„é—®é¢˜ â†’ æ¨¡ç³Šçš„ç­”æ¡ˆ   |
| **2. Why â€“ ç›®çš„æ¸…æ™°**         | è®©æˆ‘çŸ¥é“ç”¨é€”æˆ–ç›®æ ‡  | æˆ‘èƒ½æ®æ­¤è°ƒæ•´æ·±åº¦ä¸è§’åº¦     |
| **3. Who â€“ ç›®æ ‡å—ä¼—**         | é¢å‘è°è§£é‡Š          | ä¸åŒå—ä¼—â†’ä¸åŒè¯­è¨€å’Œç»†èŠ‚    |
| **4. How â€“ é£æ ¼/å½¢å¼**        | å¸Œæœ›è¾“å‡ºä»€ä¹ˆå½¢å¼    | åˆ—è¡¨ï¼Ÿæ€»ç»“ï¼Ÿæ•™å­¦ï¼Ÿä»£ç ï¼ŸæŠ¥å‘Šï¼Ÿ |
| **5. Scope â€“ èŒƒå›´é™å®š**       | è¦å¤šæ·±ã€å¤šé•¿ã€å¤šä¸“ä¸š | æ§åˆ¶å›ç­”ç²’åº¦å’Œå¤æ‚åº¦      |
| **6. Restriction â€“ çº¦æŸæ¡ä»¶** | æŒ‡å®šè¯­æ°”ã€é£æ ¼ã€æ ¼å¼ | é¿å…å•°å—¦æˆ–è·‘é¢˜         |
```
### TIPS
Socratic Questioning: ->"Act as a Socratic tutor and help me understand the concept of [topic]. Ask me questions to guide my understanding."
è‹æ ¼æ‹‰åº•å¼æé—®ï¼š->"è¯·æ‰®æ¼”è‹æ ¼æ‹‰åº•å¼çš„å¯¼å¸ˆï¼Œé€šè¿‡æé—®å¼•å¯¼æˆ‘ç†è§£[ä¸»é¢˜]æ¦‚å¿µã€‚"

Multi-Level Explanations: ->"Explain [concept] to me as if Iâ€™m a child, then a high schooler, and finally an academic."
å¤šå±‚çº§è§£é‡Šï¼š->"è¯·ç”¨å°å­¦ç”Ÿã€ä¸­å­¦ç”Ÿå’Œå­¦è€…èƒ½ç†è§£çš„ä¸åŒè¡¨è¿°æ–¹å¼ï¼Œä¸ºæˆ‘è§£é‡Š[æ¦‚å¿µ]ã€‚"

Practice Questions: ->"Create practice questions for me on [topic] at beginner, intermediate, and advanced levels."
åˆ†çº§ç»ƒä¹ é¢˜ï¼š->"è¯·å›´ç»•[ä¸»é¢˜]è®¾è®¡åˆçº§ã€ä¸­çº§å’Œé«˜çº§ä¸‰ä¸ªéš¾åº¦çš„ç»ƒä¹ é¢˜ã€‚"

Summarizing and Comparing: ->"Summarize this paper and list the key concepts. Then compare it to my summary and identify any gaps."
æ‘˜è¦å¯¹æ¯”åˆ†æï¼š->"è¯·æ€»ç»“è¿™ç¯‡è®ºæ–‡çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶ä¸æˆ‘çš„æ€»ç»“å¯¹æ¯”ï¼ŒæŒ‡å‡ºé—æ¼ä¹‹å¤„ã€‚"

Key Terms and Categories: ->"Give me a list of 20 key terms in this paper and break them into five categories."
æœ¯è¯­åˆ†ç±»å½’çº³ï¼š->"è¯·åˆ—å‡ºæœ¬æ–‡çš„20ä¸ªå…³é”®æœ¯è¯­ï¼Œå¹¶å°†å…¶å½’çº³ä¸ºäº”ä¸ªç±»åˆ«ã€‚"

Bloomâ€™s Taxonomy Challenges: ->"Create a set of challenges for me to apply Bloomâ€™s taxonomy (remember, understand, apply, analyze, evaluate, create) to [topic]." Analogies and 
å¸ƒé²å§†åˆ†ç±»æ³•å®è·µï¼š->"è¯·æ ¹æ®å¸ƒé²å§†åˆ†ç±»æ³•ï¼ˆè®°å¿†ã€ç†è§£ã€åº”ç”¨ã€åˆ†æã€è¯„ä¼°ã€åˆ›é€ ï¼‰è®¾è®¡ä¸€å¥—å…³äº[ä¸»é¢˜]çš„å®è·µæŒ‘æˆ˜ã€‚"

Real-Life Examples: ->"Provide analogies and real-life examples to help me understand [concept]."
ç±»æ¯”è¿ç§»æ•™å­¦ï¼š->"è¯·é€šè¿‡ç±»æ¯”å’Œç”Ÿæ´»å®ä¾‹å¸®åŠ©æˆ‘ç†è§£[æ¦‚å¿µ]ã€‚"


ç¤ºä¾‹:
è¯·ç”¨è‹æ ¼æ‹‰åº•å¼æé—®ï¼Œé€šè¿‡æé—®å¼•å¯¼æˆ‘ç†è§£linuxçš„å¯åŠ¨è¿‡ç¨‹ï¼Œæé—®è¿‡ç¨‹ä¸­çš„æ¯æ¬¡å¯¹è¯è®°å½•ä¸Šä¸€æ¬¡çš„ä¸Šä¸‹æ–‡

- ç¤ºä¾‹
```
å¦‚ä½•é«˜æ•ˆçš„åˆ©ç”¨cursorå­¦ä¹ linux 3.2å†…æ ¸æºç ,ç»™å‡ºå…·ä½“çš„å­¦ä¹ å»ºè®®å’Œæ­¥éª¤ï¼Œä¾‹å¦‚å…ˆä»å“ªä¸ªç®€å•çš„æ¨¡å—å…¥æ‰‹æ¯”è¾ƒå¥½

åˆ†æarch/x86/kernel/syscall_table_32.Sä¸­çš„ç³»ç»Ÿè°ƒç”¨è¡¨ç»“æ„ï¼Œåˆ—å‡ºå‰10ä¸ªç³»ç»Ÿè°ƒç”¨çš„åç§°å’Œå¯¹åº”çš„å¤„ç†å‡½æ•°

è·Ÿè¸ªsys_getpidç³»ç»Ÿè°ƒç”¨çš„å®Œæ•´æ‰§è¡Œè·¯å¾„ï¼š
1. ç”¨æˆ·æ€è°ƒç”¨å…¥å£
2. é™·å…¥å†…æ ¸çš„æœºåˆ¶
3. å®é™…å¤„ç†å‡½æ•°
4. è¿”å›ç”¨æˆ·æ€çš„è¿‡ç¨‹

è§£é‡Štask_structç»“æ„ä½“ä¸­çš„ä¸»è¦å­—æ®µå«ä¹‰

åˆ†æè¿›ç¨‹è°ƒåº¦å™¨å¦‚ä½•é€‰æ‹©ä¸‹ä¸€ä¸ªè¿è¡Œè¿›ç¨‹

ç”»å‡ºLinux 3.2çš„å†…å­˜ç®¡ç†æ¶æ„å›¾

åˆ†æä¼™ä¼´ç³»ç»Ÿçš„å·¥ä½œåŸç†

è§£é‡ŠVFSå±‚çš„å››ä¸ªä¸»è¦å¯¹è±¡å…³ç³»

æé—®æ¨¡æ¿ï¼š"åˆ†æ[æ–‡ä»¶å]ä¸­çš„[å‡½æ•°å]å‡½æ•°ï¼š
1. å‡½æ•°çš„ä¸»è¦åŠŸèƒ½
2. è¾“å…¥å‚æ•°è¯´æ˜
3. è¿”å›å€¼å«ä¹‰
4. è°ƒç”¨å…³ç³»å›¾"

æé—®æ¨¡æ¿ï¼š"åœ¨[æ¨¡å—å]ä¸­ï¼Œä¸ºæˆ‘åˆ›å»º5ä¸ªå…³é”®æ•°æ®ç»“æ„çš„è®°å¿†å¡ç‰‡ï¼ˆå­—æ®µå+è¯´æ˜ï¼‰"

å¦‚æœæˆ‘è¦åœ¨Linux 3.2ä¸­æ·»åŠ ä¸€ä¸ªç®€å•çš„ç³»ç»Ÿè°ƒç”¨ï¼Œ
éœ€è¦ä¿®æ”¹å“ªäº›æ–‡ä»¶ï¼Ÿç»™å‡ºå…·ä½“ä»£ç ç¤ºä¾‹

# 1. ç”Ÿæˆè°ƒç”¨å›¾
"ä¸º__scheduleå‡½æ•°ç”Ÿæˆå‡½æ•°è°ƒç”¨å…³ç³»å›¾"

# 2. å¯¹æ¯”åˆ†æ
"æ¯”è¾ƒLinux 3.2ä¸æœ€æ–°å†…æ ¸åœ¨å†…å­˜ç®¡ç†æ–¹é¢çš„ä¸»è¦å·®å¼‚"

# 3. æ¼æ´åˆ†æ
"åˆ†æCVE-2012-0056æ¼æ´çš„æˆå› å’Œä¿®å¤æ–¹æ¡ˆ"

```

- ç»“æ„åŒ–æé—®æ¨¡æ¿
```
[è§’è‰²è®¾å®š] ä½ ç°åœ¨æ˜¯...
[ä»»åŠ¡ç›®æ ‡] æˆ‘å¸Œæœ›ä½ ...
[å†…å®¹èŒƒå›´] è¯·è§£é‡Š/åˆ†æ/ç”Ÿæˆå…³äº...
[è¾“å‡ºå½¢å¼] è¾“å‡ºåº”åŒ…æ‹¬...
[é£æ ¼è¦æ±‚] é£æ ¼è¦...
[é™åˆ¶æ¡ä»¶] ä¸è¦... / é¿å…...

å¥½ Prompt = è§’è‰² + ä»»åŠ¡ + ç›®æ ‡ + èŒƒå›´ + æ ¼å¼ + é£æ ¼

ä¾‹å­:
ä½ æ˜¯ä¸€åèµ„æ·±è½¯ä»¶å·¥ç¨‹å¸ˆã€‚
è¯·ç”¨æ•™å­¦é£æ ¼è§£é‡Šâ€œæ“ä½œç³»ç»Ÿå†…æ ¸çš„çº¿ç¨‹è°ƒåº¦æœºåˆ¶â€ï¼Œ
é¢å‘å¤§å­¦è®¡ç®—æœºç³»å­¦ç”Ÿã€‚
è¾“å‡ºåŒ…å«ï¼šè°ƒåº¦åŸç†ã€ç®—æ³•å¯¹æ¯”ã€ä¼˜ç¼ºç‚¹åˆ†æã€‚
ä½¿ç”¨Markdownå°æ ‡é¢˜å’Œå›¾ç¤ºç»“æ„ã€‚
å­—æ•°æ§åˆ¶åœ¨800å­—ä»¥å†…ã€‚
```

- ç¤ºä¾‹
```
æ™®é€šæé—®
    ä»€ä¹ˆæ˜¯åŒºå—é“¾ï¼Ÿ

ä¼˜åŒ–æé—®ï¼ˆç»“æ„åŒ–ç‰ˆæœ¬ï¼‰
    ä½ ç°åœ¨æ˜¯ä¸€ååŒºå—é“¾é¢†åŸŸçš„æŠ€æœ¯è®²å¸ˆã€‚
    è¯·ä»¥ç³»ç»ŸåŒ–ã€åˆ†å±‚ç»“æ„çš„æ–¹å¼è®²è§£â€œä»€ä¹ˆæ˜¯åŒºå—é“¾â€ï¼Œ
    ç›®æ ‡è¯»è€…æ˜¯æœ‰ç¼–ç¨‹åŸºç¡€çš„å·¥ç¨‹å¸ˆã€‚
    è¾“å‡ºåŒ…å«ï¼šâ‘ å®šä¹‰ â‘¡æ•°æ®ç»“æ„ â‘¢å…±è¯†æœºåˆ¶ â‘£å®‰å…¨åŸç† â‘¤åº”ç”¨åœºæ™¯ã€‚
    æ¯éƒ¨åˆ†ä½¿ç”¨å°æ ‡é¢˜å’Œç®€è¦ç¤ºä¾‹ã€‚
    é£æ ¼è¦æŠ€æœ¯å‘ã€é€»è¾‘æ¸…æ™°ã€æ— è¥é”€å£å»ã€‚
```

- ä¸åŒåœºæ™¯ä¸‹çš„ Prompt ç¤ºä¾‹
```
| ç›®æ ‡               | ä¼˜åŒ–æé—®æ¨¡æ¿                                              |
| --------------     | --------------------------------------------------- |
| ğŸ“˜ **å­¦ä¹ æ¦‚å¿µ**    | â€œè¯·åƒæˆ‘æ˜¯ä¸€åæ–°æ‰‹ç¨‹åºå‘˜ä¸€æ ·è§£é‡Š[æ¦‚å¿µ]ï¼Œç”¨ç±»æ¯”å’Œä¾‹å­è¯´æ˜åŸç†ï¼Œæœ€åæ€»ç»“3ä¸ªå…³é”®ç‚¹ã€‚â€         |
| ğŸ’» **ä»£ç è®²è§£**    | â€œè¯·é€è¡Œè§£é‡Šä¸‹é¢çš„Cä»£ç ï¼Œè¯´æ˜æ¯ä¸€è¡Œçš„ä½œç”¨å’ŒèƒŒåçš„è¯­è¨€æœºåˆ¶ã€‚â€                     |
| ğŸ§ª **è°ƒè¯•æˆ–é”™è¯¯åˆ†æ** | â€œä»¥ä¸‹æ˜¯æˆ‘åœ¨ç¼–è¯‘Cç¨‹åºæ—¶çš„é”™è¯¯ä¿¡æ¯ã€‚è¯·åˆ†æåŸå› å¹¶ç»™å‡ºè§£å†³æ­¥éª¤ã€‚å‡è®¾æˆ‘çš„ç¯å¢ƒæ˜¯Linux + gccã€‚â€ |
| ğŸ“‘ **æ€»ç»“æŠ¥å‘Š**    | â€œè¯·æŠŠä¸‹é¢å†…å®¹æ€»ç»“ä¸ºæŠ€æœ¯æŠ¥å‘Šï¼ŒåŒ…å«æ‘˜è¦ã€é—®é¢˜åˆ†æã€è§£å†³æ–¹æ¡ˆã€ç»“è®ºå››éƒ¨åˆ†ã€‚â€               |
| ğŸ’¬ **å†™ä½œæ”¹è¿›**    | â€œè¯·å¸®æˆ‘æ”¹è¿›ä¸‹é¢çš„æ®µè½ï¼Œä½¿å…¶æ›´ç®€æ´ä¸“ä¸šï¼Œä¿æŒåŸæ„ï¼Œé£æ ¼åæŠ€æœ¯æ–‡æ¡£ã€‚â€                  |

```

- è¿›é˜¶æŠ€å·§
```
è§’è‰²è®¾å®šæ³•ï¼ˆRole promptingï¼‰
    â€œä½ æ˜¯ä¸€åèµ„æ·±Cè¯­è¨€ç¼–è¯‘å™¨å·¥ç¨‹å¸ˆâ€

åˆ†æ­¥æ¨ç†æ³•ï¼ˆStep-by-step promptingï¼‰
    â€œè¯·å…ˆè§£é‡ŠåŸºæœ¬åŸç†ï¼Œå†åˆ†æå®ç°ï¼Œå†æ€»ç»“ä¼˜ç¼ºç‚¹ã€‚â€

è¿­ä»£ä¼˜åŒ–æ³•ï¼ˆRefinement promptingï¼‰
    ç¬¬ä¸€æ¬¡æé—®åï¼Œè¯´â€œè¯·ç®€åŒ–æˆè¦ç‚¹ç‰ˆâ€æˆ–â€œè¯·è¡¥å……ä»£ç å®ä¾‹â€

ç»“æ„æ§åˆ¶æ³•
æ˜ç¡®è¾“å‡ºæ ¼å¼ï¼Œä¾‹å¦‚ï¼š
ç”¨markdownæ ¼å¼è¾“å‡ºï¼ŒåŒ…å«ï¼š
1. å®šä¹‰
2. åŸç†
3. ç¤ºä¾‹
4. æ€»ç»“


é¿å…æ­§ä¹‰è¯
é¿å…â€œè®²è¯¦ç»†ä¸€ç‚¹â€â€œå¸®æˆ‘ä¼˜åŒ–â€è¿™ç§æ¨¡ç³Šè¡¨è¾¾ï¼Œ
æ”¹ä¸ºâ€œè¯·åœ¨è§£é‡Šä¸­å¢åŠ åº•å±‚åŸç†ä¸ä»£ç å®ç°ç¤ºä¾‹â€ã€‚
```

- æŠ€æœ¯å­¦ä¹ ç±»å¥½æç¤ºè¯çš„5å¤§åŸåˆ™ (LAYERæ¨¡å‹)
```
| åŸåˆ™                     | å«ä¹‰             | ç¤ºä¾‹                   |
| ----------------------   | ---------       | -------------------- |
| **L â€” Level (å±‚æ¬¡)**     | æŒ‡å®šè®²è§£æ·±åº¦     | â€œå‡è®¾æˆ‘å·²ç»æ‡‚Cè¯­è¨€ï¼Œä½†ä¸äº†è§£å†…æ ¸åŸç†â€ |
| **A â€” Audience (å—ä¼—)**  | å‘Šè¯‰æˆ‘ä½ æ˜¯è°     | â€œé¢å‘æœ‰ç¼–ç¨‹ç»éªŒçš„å·¥ç¨‹å¸ˆâ€        |
| **Y â€” Yield (äº§å‡º)**     | æ˜ç¡®è¾“å‡ºå½¢å¼     | â€œè¯·è¾“å‡ºç»“æ„åŒ–è®²è§£ï¼ŒåŒ…å«ç¤ºä¾‹å’Œå›¾è§£â€   |
| **E â€” Explain (è®²è§£æ–¹å¼)** | æ§åˆ¶è®²è§£é£æ ¼    | â€œè¯·åƒåœ¨è¯¾å ‚ä¸Šæ•™å­¦ä¸€æ ·åˆ†æ­¥éª¤è®²è§£â€    |
| **R â€” Refine (ä¼˜åŒ–)**    | ç»™å‡ºçº¦æŸä¸æ”¹è¿›è¦æ±‚ | â€œè¯­è¨€ç®€æ´ï¼Œä½¿ç”¨ç±»æ¯”ï¼Œä¸è¶…è¿‡800å­—â€  |
```

- æ¨¡æ¿
```
ä½ æ˜¯ä¸€å[æŠ€æœ¯é¢†åŸŸ]çš„èµ„æ·±å·¥ç¨‹å¸ˆå…¼è®²å¸ˆã€‚
è¯·ç³»ç»ŸåŒ–è®²è§£[æŠ€æœ¯ä¸»é¢˜]ã€‚
å‡è®¾è¯»è€…æ˜¯[ç›®æ ‡å—ä¼—]ï¼Œå·²æœ‰[ç›¸å…³çŸ¥è¯†èƒŒæ™¯]ã€‚
è®²è§£å†…å®¹åº”åŒ…å«ï¼š
1. åŸºæœ¬æ¦‚å¿µå’Œå®šä¹‰
2. å†…éƒ¨å·¥ä½œåŸç†ï¼ˆåˆ†æ­¥éª¤è¯´æ˜ï¼‰
3. å¸¸è§åº”ç”¨æˆ–ç¤ºä¾‹
4. å¯èƒ½çš„é™·é˜±æˆ–è¯¯åŒº
5. ç®€çŸ­æ€»ç»“ï¼ˆ3â€“5è¡Œï¼‰

è¾“å‡ºè¦æ±‚ï¼š
- ä½¿ç”¨ Markdown æ ¼å¼ï¼Œå¸¦æ ‡é¢˜ä¸å°èŠ‚
- è¯­è¨€æ¸…æ™°ã€ç»“æ„åˆ†æ˜
- æ—¢æœ‰ç†è®ºåˆæœ‰å®è·µè§’åº¦


ç¤ºä¾‹1ï¼šå­¦ä¹ ç½‘ç»œåè®®
ä½ æ˜¯ä¸€åè®¡ç®—æœºç½‘ç»œè®²å¸ˆã€‚
è¯·ç³»ç»Ÿè®²è§£ TCPä¸‰æ¬¡æ¡æ‰‹çš„å…¨è¿‡ç¨‹ï¼Œå‡è®¾æˆ‘å·²ç»äº†è§£IPå±‚çš„æ¦‚å¿µã€‚
è¾“å‡ºåº”åŒ…å«ï¼š
1. ä¸‰æ¬¡æ¡æ‰‹æ¯ä¸€æ­¥çš„æŠ¥æ–‡å†…å®¹å’Œç›®çš„
2. ä¸ºä»€ä¹ˆæ˜¯ä¸‰æ¬¡è€Œä¸æ˜¯ä¸¤æ¬¡æˆ–å››æ¬¡
3.æŠ¥æ–‡ä¸¢å¤±æˆ–å»¶è¿Ÿçš„å¤„ç†æœºåˆ¶
æœ€åé™„ä¸Šä¸€æ®µæ€»ç»“ã€‚
è¦æ±‚ï¼šç”¨ Markdown æ ¼å¼è¾“å‡ºã€å›¾æ–‡ç»“åˆã€æ¸…æ™°æ˜“æ‡‚ã€‚

ç¤ºä¾‹2ï¼šå­¦ä¹ ç¼–è¯‘å™¨åŸç†
ä½ æ˜¯ä¸€åç¼–è¯‘å™¨ä¸“å®¶ã€‚
è¯·ä»¥æ•™å­¦æ–¹å¼è®²è§£ Cè¯­è¨€ç¼–è¯‘è¿‡ç¨‹çš„4ä¸ªé˜¶æ®µï¼ˆé¢„å¤„ç†ã€ç¼–è¯‘ã€æ±‡ç¼–ã€é“¾æ¥ï¼‰ã€‚
å‡è®¾æˆ‘æœ‰Cè¯­è¨€åŸºç¡€ä½†ä¸äº†è§£ç¼–è¯‘å™¨å†…éƒ¨ç»“æ„ã€‚
è¯·è¯´æ˜ï¼š
    - æ¯ä¸ªé˜¶æ®µçš„è¾“å…¥ä¸è¾“å‡ºæ–‡ä»¶
    - ä¸»è¦åšäº†å“ªäº›è½¬æ¢
    - å¸¸è§çš„ç¼–è¯‘é”™è¯¯ç¤ºä¾‹
    - ç”¨gcc -E/-S/-cä¸¾ä¾‹è¯´æ˜
é£æ ¼è¦æ±‚ï¼šæ¸…æ™°ã€é€»è¾‘æ€§å¼ºã€æœ‰è¡¨æ ¼ã€‚

âœ… ç¤ºä¾‹3ï¼šå­¦ä¹ Rustç‰¹æ€§
ä½ æ˜¯ä¸€åRustè¯­è¨€è®²å¸ˆã€‚
è¯·è®²è§£ Rustçš„æ‰€æœ‰æƒä¸å€Ÿç”¨æœºåˆ¶ã€‚
å‡è®¾æˆ‘æ‡‚C++æŒ‡é’ˆï¼Œä½†åˆšå¼€å§‹å­¦Rustã€‚
è¯·ç”¨å¯¹æ¯”çš„æ–¹å¼è§£é‡Šï¼š
    1. æ‰€æœ‰æƒçš„ä¸‰æ¡æ ¸å¿ƒè§„åˆ™
    2. å€Ÿç”¨ä¸å¼•ç”¨çš„åŒºåˆ«
    3. ç”Ÿå‘½å‘¨æœŸçš„å«ä¹‰
æœ€åç»™å‡ºä¸€æ®µRustä»£ç ç¤ºä¾‹å¹¶é€è¡Œè§£é‡Šã€‚

âœ… ç¤ºä¾‹4ï¼šå­¦ä¹ ç³»ç»Ÿç¼–ç¨‹
ä½ æ˜¯ä¸€åLinuxç³»ç»Ÿå·¥ç¨‹å¸ˆã€‚
è¯·è§£é‡Š fork() ç³»ç»Ÿè°ƒç”¨çš„å·¥ä½œåŸç†ã€‚
åŒ…æ‹¬ï¼š
    - å†…æ ¸å¦‚ä½•å¤åˆ¶è¿›ç¨‹
    - çˆ¶å­è¿›ç¨‹çš„åŒºåˆ«
    - fork() è¿”å›å€¼çš„æ„ä¹‰
    - ä½¿ç”¨ç¤ºä¾‹ä»£ç ä¸è¾“å‡ºè¯´æ˜
è¯­è¨€è¦æ±‚ï¼šç®€æ´ã€å¸¦ä»£ç æ³¨é‡Šã€‚

- å¼ºåŒ–è¾“å‡ºçš„é™„åŠ æŠ€å·§
| ç›®æ ‡         | æç¤ºæŠ€å·§                   |
| -------      | ---------------------- |
| æƒ³å­¦å¾—ç³»ç»Ÿ    | â€œè¯·ä»¥è¯¾ç¨‹å½¢å¼åˆ†ç« èŠ‚è®²è§£â€          |
| æƒ³å¿«é€Ÿç†è§£    | â€œè¯·ç”¨ç±»æ¯”å’Œæ¯”å–»è§£é‡Šâ€            |
| æƒ³çœ‹åº•å±‚æœºåˆ¶  | â€œè¯·æ·±å…¥åˆ°å®ç°ç»†èŠ‚å’Œç³»ç»Ÿè°ƒç”¨å±‚é¢â€      |
| æƒ³ç»“åˆä»£ç     | â€œè¯·é™„ä¸Šç®€çŸ­C/Rustä»£ç ç¤ºä¾‹å¹¶é€è¡Œè§£é‡Šâ€ |
| æƒ³æ‰“å°æ€»ç»“ç¬”è®° | â€œè¯·è¾“å‡ºè¦ç‚¹æ€»ç»“è¡¨æ ¼ï¼Œæ–¹ä¾¿å¤ä¹ â€       |


- æŠ€æœ¯å­¦ä¹ ç±»å¥½ Prompt çš„å…¬å¼
è§’è‰² + ç›®æ ‡ä¸»é¢˜ + èƒŒæ™¯ + å†…å®¹ç»“æ„ + è¾“å‡ºæ ¼å¼ + é£æ ¼è¦æ±‚

ç¤ºä¾‹:
ä½ æ˜¯ä¸€åæ“ä½œç³»ç»Ÿè®²å¸ˆã€‚
è¯·ä»¥ç³»ç»ŸåŒ–ã€æ•™å­¦æ–¹å¼è®²è§£â€œLinux è¿›ç¨‹è°ƒåº¦æœºåˆ¶â€ã€‚
å‡è®¾æˆ‘ç†Ÿæ‚‰Cè¯­è¨€ä½†ä¸äº†è§£å†…æ ¸ã€‚
è¾“å‡ºåŒ…æ‹¬ï¼šè°ƒåº¦ç­–ç•¥ã€CFSç®—æ³•ã€æ—¶é—´ç‰‡ã€ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚
ç”¨Markdownæ ¼å¼è¾“å‡ºï¼Œå¸¦å°æ ‡é¢˜ä¸è¡¨æ ¼è¯´æ˜ã€‚

```

- ä»£ç è°ƒè¯•ç±»é«˜è´¨é‡æé—®çš„æ ¸å¿ƒåŸåˆ™ (DEBUG æ¨¡å‹)
```
| åŸåˆ™                    | å«ä¹‰         | è¦ç‚¹               |
| ---------------------   | ------      | ---------------- |
| **D â€” Describe**        | æ˜ç¡®æè¿°é—®é¢˜ | å‡ºç°ä»€ä¹ˆé”™è¯¯ï¼Ÿåœ¨ä»€ä¹ˆæƒ…å†µä¸‹ï¼Ÿ   |
| **E â€” Environment**     | æŒ‡å‡ºç¯å¢ƒ     | æ“ä½œç³»ç»Ÿã€ç¼–è¯‘å™¨ã€è¯­è¨€ç‰ˆæœ¬ç­‰   |
| **B â€” Background**      | æä¾›ä¸Šä¸‹æ–‡   | ä»£ç ç›®çš„ã€ä½ æƒ³å®ç°çš„åŠŸèƒ½     |
| **U â€” Understanding**   | è¡¨è¾¾ä½ çš„ç†è§£ | ä½ è®¤ä¸ºé—®é¢˜å¯èƒ½çš„åŸå› ï¼ˆå“ªæ€•çŒœæµ‹ï¼‰ |
| **G â€” Goal**            | æ˜ç¡®ç›®æ ‡     | æƒ³è¦ä»€ä¹ˆæ ·çš„ç»“æœæˆ–è¾“å‡º      |

- é€šç”¨æ¨¡æ¿
æˆ‘åœ¨è°ƒè¯•ä¸€æ®µ [ç¼–ç¨‹è¯­è¨€/æ¡†æ¶] ä»£ç æ—¶é‡åˆ°é—®é¢˜ã€‚

### ğŸ§© èƒŒæ™¯
- åŠŸèƒ½ç›®æ ‡ï¼šæˆ‘æƒ³å®ç° [è¯´æ˜ä»£ç åŠŸèƒ½æˆ–é€»è¾‘]
- è¿è¡Œç¯å¢ƒï¼šæ“ä½œç³»ç»Ÿ [å¦‚ Debian 12]ï¼Œç¼–è¯‘å™¨/è§£é‡Šå™¨ç‰ˆæœ¬ [å¦‚ gcc 13.2 / Python 3.11]
- ç¬¬ä¸‰æ–¹ä¾èµ–æˆ–åº“ï¼ˆå¦‚æœ‰ï¼‰

### ğŸ’» å‡ºé”™ä»£ç 
```[è¯­è¨€å]
(è¯·ç²˜è´´å‡ºé”™ä»£ç ç‰‡æ®µï¼Œè¶³ä»¥é‡ç°é—®é¢˜)

âš ï¸ é”™è¯¯ä¿¡æ¯
(å®Œæ•´ç²˜è´´é”™è¯¯æ—¥å¿—ã€ç¼–è¯‘è¾“å‡ºã€å †æ ˆä¿¡æ¯ç­‰)

ğŸ§  æˆ‘çš„ç†è§£
(å¯é€‰ï¼šä½ è®¤ä¸ºé—®é¢˜å‡ºåœ¨å“ªï¼Ÿå°è¯•è¿‡å“ªäº›ä¿®å¤åŠæ³•ï¼Ÿ)

ğŸ¯ æˆ‘çš„æœŸæœ›
è¯·å¸®æˆ‘åˆ†æï¼š
é—®é¢˜äº§ç”Ÿçš„åŸå› 
å¦‚ä½•ä¿®å¤
æ˜¯å¦æœ‰æ›´å¥½çš„å†™æ³•/æœ€ä½³å®è·µ


## ğŸ§© å…­ã€è°ƒè¯•ç±»æé—®çš„é™„åŠ æŠ€å·§

| ç›®æ ‡        | æç¤ºæŠ€å·§ |
|------       |-----------|
| æƒ³è¦è¯¦ç»†åˆ†æ | â€œè¯·é€è¡Œè§£é‡Šä»£ç è¡Œä¸ºï¼Œå¹¶è¯´æ˜å“ªä¸€è¡Œå¯èƒ½å‡ºé”™â€ |
| æƒ³å­¦è°ƒè¯•æ–¹æ³• | â€œè¯·å‘Šè¯‰æˆ‘å¦‚ä½•ç”¨ gdb / strace / lldb æ¥å®šä½è¿™ä¸ªé—®é¢˜â€ |
| æƒ³è¦é‡æ„å»ºè®® | â€œè¯·æä¾›æ›´å®‰å…¨æˆ–æ›´ç®€æ´çš„å®ç°æ–¹å¼â€ |
| æƒ³åšæ€§èƒ½ä¼˜åŒ– | â€œè¯·å¸®æˆ‘åˆ†æè¿™æ®µä»£ç å¯èƒ½çš„æ€§èƒ½ç“¶é¢ˆâ€ |
| éœ€è¦è·¨è¯­è¨€è§£é‡Š | â€œè¯·æ¯”è¾ƒè¿™æ®µCä»£ç ä¸Rustä¸­ç­‰ä»·å†™æ³•çš„å†…å­˜è¡Œä¸ºå·®å¼‚â€ |

---

## ğŸ§¾ ä¸ƒã€æ€»ç»“ï¼šè°ƒè¯•ç±»é«˜æ•ˆ Prompt é»„é‡‘å…¬å¼

> ğŸ§  **èƒŒæ™¯ + ç¯å¢ƒ + ä»£ç  + é”™è¯¯ + ç†è§£ + æœŸæœ›**

ç¤ºä¾‹ï¼š
æˆ‘åœ¨ Linux ä¸Šç”¨ gcc ç¼–è¯‘ä¸€ä¸ªåŠ¨æ€åº“æ—¶å‡ºé”™ã€‚

**èƒŒæ™¯ï¼š** æƒ³å†™ä¸€ä¸ª collectd æ’ä»¶  
**å‘½ä»¤ï¼š** `gcc -fPIC -shared -o plugin.so plugin.c -I/usr/include/collectd`  
**é”™è¯¯ï¼š** `fatal error: plugin.h: No such file or directory`  
**ç¯å¢ƒï¼š** Debian 12, gcc 13.2  
**æˆ‘çš„ç†è§£ï¼š** å¯èƒ½æ˜¯ include è·¯å¾„ä¸å¯¹ã€‚  
**è¯·å¸®æˆ‘åˆ†æï¼š** å¤´æ–‡ä»¶è·¯å¾„åœ¨å“ªé‡Œï¼Ÿæ­£ç¡®ç¼–è¯‘å‚æ•°æ˜¯ä»€ä¹ˆï¼Ÿcollectd æ’ä»¶ä¸€èˆ¬æ€ä¹ˆç¼–è¯‘ï¼Ÿ

```

- Ultimate Learning Prompt for Any Topic
```
I want to learn the topic: <TOPIC>.
Please act as my expert instructor and provide ALL of the following:

High-level overview
    What the topic is
    Why it matters
    Where it is used in real systems

Core concepts explained simply
    Define the essential terms
    Give short analogies for each concept
    Provide visual ASCII diagrams when helpful

Progressive deep dive
    Structure the learning in levels:
        Level 1: Beginner explanation
        Level 2: Intermediate technical concepts
        Level 3: Expert-level architecture & internal mechanisms
        Level 4: Real-world engineering considerations (performance, design, pitfalls)

Hands-on examples
    Provide practical examples relevant to <TOPIC>, such as:
        Code examples (C / Rust / Go / Python depending on context)
        Command-line examples
        Minimal complete working examples (MCWE)

Mini-projects / exercises
    Give me exercises at three difficulty levels:
        Easy
        Medium
        Hard
        Include expected outputs or hints.

Common mistakes & misunderstandings
Explain the top mistakes learners make
Show correct vs incorrect examples

Links between concepts
    Explain how this topic connects to:
        Operating systems
        Networking
        Memory management
        Distributed systems
        Security
        (Choose relevant ones depending on <TOPIC>)

Interview-style questions
    Provide 10 conceptual questions + 10 deep technical questions + answers.

Learning roadmap
    Tell me what to study next after this topic.
    Include recommended order and estimated time.

Optional: generate visual summaries
    Such as:
        ASCII architecture diagrams
        Flowcharts
        Tables summarizing differences or pros/cons

Before starting, ask me 3 clarifying questions to tailor the material to my background and goals.
```

- ç”¨äºç”Ÿæˆé«˜è´¨é‡ Anki å¡ç‰‡çš„ä¸“å®¶çº§æç¤ºè¯
```
I want to learn the topic: <TOPIC>.

Act as my expert instructor and generate high-quality Anki-style flashcards that are accurate, clear, and optimized for long-term technical retention.

Please create the cards with ALL of the following characteristics:

1. **Card Format**
   - Use Q: (front) and A: (back)
   - One concept per card
   - Avoid overly long answers
   - Prefer clear definitions, contrasts, examples, diagrams

2. **Card Types (mix them)**
   - Concept cards (definitions)
   - Reverse cards (Aâ†’Q)
   - Cloze deletion cards
   - Understanding tests ("why", "what if", "compare")
   - Code interpretation cards (for C/Python when appropriate)
   - ASCII diagram cards (for system / kernel / network topics)

3. **Content Requirements**
   - Start with core fundamentals of <TOPIC>
   - Add deeper internal mechanisms (since I am intermediate level)
   - Include real examples whenever possible
   - For networking/kernel topics, emphasize:
        - call paths
        - state machines
        - data structures
        - key APIs
   - Include common misconceptions and contrast them

4. **Difficulty Levels**
   - Tag each card as: [Basic], [Intermediate], or [Advanced]

5. **Number of Cards**
   - Generate 30 cards initially
   - Ensure they progressively increase in complexity

6. **Output Format**
   - Provide clean plain-text output.
   - No numbering; each card separated by a blank line.

Before generating the cards, ask me 2â€“3 clarifying questions to tailor the difficulty, language, and coding examples.

```

- prompt 1
```
walk through a real Linux NIC driver, end-to-end, at code level, but still readable.use virtio_net as the main example(considering RX/TX rings, DMA, NAPI, SKB, etc.) å¦‚æœéœ€è¦çš„ï¼Œå¯ä»¥ç”¨å¦‚ä¸‹çš„æ–¹å¼è¿›è¡Œå±•ç¤º
1.çº¯è‹±æ–‡ ç»˜åˆ¶ ASCII å›¾
2.å›¾ä¸‹æ–¹ ç”¨æ™®é€šæ–‡å­—æ·»åŠ ä¸­æ–‡è¯´æ˜
ç»“æœä¿å­˜ä¸ºMarkdownæ ¼å¼çš„æ–‡ä»¶

Explain SKB(struct sk_buff) internals with diagrams, which should be a driver-level + stack-level explanation, with ASCII diagrams, field breakdowns, and how data flows without copies, header offsets which is critical for protocol stack, SKB lifecycle for tx path and rx path, linear and no-linear SKBs, common SKB helper APIs, how SKB ties to RX/TX rings, etc.å¦‚æœéœ€è¦çš„ï¼Œå¯ä»¥ç”¨å¦‚ä¸‹çš„æ–¹å¼è¿›è¡Œå±•ç¤º
1.çº¯è‹±æ–‡ ç»˜åˆ¶ ASCII å›¾
2.å›¾ä¸‹æ–¹ ç”¨æ™®é€šæ–‡å­—æ·»åŠ ä¸­æ–‡è¯´æ˜
ç»“æœä¿å­˜ä¸ºMarkdownæ ¼å¼çš„æ–‡ä»¶

If needed, you can present it in the following way:
1. Pure English ASCII diagram
2. Below the diagram, add Chinese explanations in plain text
Save the result as a Markdown file
```

- Structured Prompt Template (General Technical Topics)
```
I want to learn the topic: <TOPIC>.

Please act as an expert systems engineer and instructor.
Explain this topic in a clear, structured, and progressive way.

Follow this exact structure:

1. High-level overview
   - What the topic is
   - Why it exists (the problem it solves)
   - Where it is used in real systems

2. Architecture overview
   - Describe the overall architecture
   - Identify major components and their responsibilities
   - Show how components interact
   - Include a clean ASCII architecture diagram (aligned, readable)

3. Key components (deep but clear)
   For each major component:
   - Purpose
   - Inputs / outputs
   - Key data structures
   - Important invariants or rules
   - Common variations or implementations

4. Core workflows (step-by-step)
   - Explain the main workflows end-to-end
   - Show control flow and data flow
   - Use ASCII sequence diagrams or flow diagrams where helpful

5. Internal mechanisms (under-the-hood)
   - Explain how it actually works internally
   - Algorithms, state machines, memory layout, or concurrency model
   - Highlight performance and correctness considerations

6. Practical examples
   - Minimal working examples (MCWE)
   - Realistic code snippets (C / C++ / Rust / Go / Python as appropriate)
   - Explain what each part of the code does
   - Show how the example maps back to the architecture

7. Common mistakes and pitfalls
   - Typical misunderstandings
   - Incorrect vs correct approaches
   - Real-world bugs and how to avoid them

8. Mental models and summaries
   - Provide 2â€“3 strong mental models
   - Summarize key takeaways in bullet points
   - Optional comparison table if alternatives exist

9. Real-world engineering considerations
   - Performance bottlenecks
   - Scalability concerns
   - Debugging and observability
   - Security or reliability implications

10. What to learn next
    - Related topics
    - Suggested learning order
    - Why each next topic matters

Constraints:
- Break explanations into small, digestible sections
- Prefer diagrams over long text when possible
- Use precise technical language but explain it clearly
- Do not skip steps or hand-wave important details

```

```
Explain <TOPIC> as if I am reading production source code.

- Explicitly connect concepts to real implementations
- Show how the abstractions map to actual code paths
- Call out invariants, ownership rules, and lifetimes
- Use ASCII diagrams for memory layout and control flow
- Prefer correctness and clarity over oversimplification

Assume I have an intermediate programming background.

```

- Structured Prompt: Learning Linux Kernel Source Code (v3.2)
```
I want to systematically learn the Linux kernel source code (version 3.2).

Please act as a senior Linux kernel maintainer and systems instructor.
Teach me by reading and explaining the actual source code, not just concepts.

Assume:
- I have intermediate C skills
- I understand OS fundamentals
- I want to learn how the kernel really works internally

Follow this exact structure:

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Subsystem context (big picture)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- What kernel subsystem are we studying?
- What problem does it solve?
- Where it sits in the overall kernel architecture
- How this subsystem interacts with others

Include a clean ASCII architecture diagram showing:
- This subsystem
- Adjacent subsystems
- Data/control flow

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2. Directory & file map (code navigation)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- List the main directories and files involved (relative to kernel root)
- Explain the responsibility of each file
- Explain why the code is split this way

Example format:
  kernel/
    sched/
      core.c   â†’ main scheduler logic
      fair.c   â†’ CFS implementation

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3. Core data structures
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
For each important struct:
- Show the struct definition (simplified if large)
- Explain each field
- Explain ownership and lifetime rules
- Explain how and where it is allocated/freed

Explain invariants that must always hold.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4. Entry points & call paths
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Identify key entry points (syscalls, interrupts, callbacks)
- Trace the main call paths step-by-step
- Show the function call chain in order

Use ASCII call graphs or sequence diagrams.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5. Core workflows (code-driven)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Explain major workflows such as:
- Initialization
- Fast path (performance-critical)
- Slow path (exceptional cases)
- Error handling paths

For each workflow:
- Start from the triggering event
- Walk through the exact functions involved
- Explain state changes and side effects

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6. Important algorithms & mechanisms
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Scheduling, locking, memory management, or protocol logic
- Why these algorithms were chosen
- Tradeoffs and limitations (especially in v3.2)

Explain with diagrams where appropriate.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7. Concurrency & synchronization
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- What concurrency model is used?
- What locks are involved?
- Where preemption, interrupts, or RCU are used
- What race conditions the code prevents

Explain what would break if synchronization is wrong.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
8. Performance considerations
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Hot paths vs cold paths
- Cacheline considerations
- Lock contention
- Scalability limits in v3.2

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
9. Common pitfalls & bugs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Typical mistakes kernel developers make here
- Subtle bugs this code avoids
- Historical issues or known limitations in v3.2

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
10. How to read this code yourself
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- What functions to read first
- What to ignore initially
- Suggested reading order
- Grep / cscope tips

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
11. Summary & mental model
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- One-paragraph summary
- Key invariants
- Mental model to keep while reading code

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
12. What to study next
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Related kernel subsystems
- Why they matter
- Recommended learning order

```

- Learn Boundaries & Contracts in C Architectures
```
You are a senior systems architect with decades of experience designing
large, long-lived C codebases (databases, OS components, network services).

Your task is to teach me how to identify, design, and enforce
BOUNDARIES and CONTRACTS in typical C architectures.

Do NOT focus on patterns by name alone.
Focus on responsibilities, dependency rules, and invariants.

--------------------------------------------------
STEP 1 â€” Define What a Boundary Is (in C)
--------------------------------------------------

Explain:
- What a boundary means in C (where the language gives no enforcement)
- Why boundaries exist
- What problems boundaries prevent over time

Explicitly distinguish between:
- Conceptual boundaries
- Code-level boundaries

--------------------------------------------------
STEP 2 â€” Identify Common Architectural Layers in C
--------------------------------------------------

List common architectural layers used in real C systems, such as:
- Application / Policy layer
- Domain / Service layer
- Core / Mechanism layer
- Infrastructure / OS layer

For each layer:
- Primary responsibility
- Allowed dependencies
- Forbidden dependencies
- Typical volatility (how often it changes)

--------------------------------------------------
STEP 3 â€” Boundary Types and Contracts
--------------------------------------------------

Identify and explain the major types of boundaries in C, including:

- API boundaries
- Data ownership boundaries
- Control flow boundaries
- Error propagation boundaries
- Configuration / policy boundaries
- Visibility / symbol boundaries

For EACH boundary type:
- What contract is enforced
- What is allowed
- What is forbidden
- What breaks when the contract is violated

--------------------------------------------------
STEP 4 â€” Contracts as C Interfaces
--------------------------------------------------

Show how contracts are expressed in C using:
- Header files
- Opaque structs
- Function signatures
- Naming conventions
- Documentation invariants

Provide small but realistic C code snippets for each technique.

--------------------------------------------------
STEP 5 â€” Allowed Interaction Patterns Between Layers
--------------------------------------------------

Describe and illustrate:
- Direct downward calls
- Dependency injection via function pointers
- Callbacks without layer inversion
- Data passed across layers safely

For each interaction:
- Why it is allowed
- What rules must be followed

--------------------------------------------------
STEP 6 â€” Forbidden Interactions (Anti-Patterns)
--------------------------------------------------

List common boundary violations in C systems, such as:
- Upward dependencies
- Leaking internal structs
- Shared global state
- Policy decisions in low layers

Show short C examples of each violation and explain why it is harmful.

--------------------------------------------------
STEP 7 â€” Contracts Over Time (Evolution)
--------------------------------------------------

Explain how boundaries and contracts help when:
- Features are added
- Performance is optimized
- Code is refactored
- Teams change

Explain what happens when contracts are vague or undocumented.

--------------------------------------------------
STEP 8 â€” Mapping Boundaries to Real Systems
--------------------------------------------------

Apply the concepts to at least one real C system
(e.g., SQLite, Redis, or a POSIX service).

Identify:
- Major boundaries
- Key contracts
- Where the system is strict vs pragmatic

--------------------------------------------------
STEP 9 â€” Boundary Review Checklist
--------------------------------------------------

Provide a practical checklist I can use during code review to evaluate:
- Whether boundaries are respected
- Whether contracts are clear
- Where architecture is at risk of decay

--------------------------------------------------
RULES
--------------------------------------------------

- Architecture-first explanations
- Use precise language
- Avoid buzzwords
- Prefer tables and diagrams where useful
- Treat this as professional-level training



- Coach Advice (Important)

Most C codebases fail not because of performance,
but because boundaries erode silently.

If you master:
    Where boundaries are
    What contracts they enforce
    How violations creep in
Youâ€™ll outgrow 90% of C developers architecturallyâ€”even very senior ones.
```

- Cursor Prompt: Learn Boundaries & Contracts in a Specific C Project
```
You are a senior systems architect reviewing a real-world C codebase.

Your task is to help me learn how boundaries and contracts are designed,
enforced, and violated over time in the following project:

PROJECT:
[project name + repo path]

Do NOT explain what the project does at a high level.
Treat it as an architectural artifact under review.

Focus on:
- Where boundaries exist
- What contracts they enforce
- How violations creep in
- How architecture decays in C systems

--------------------------------------------------
STEP 1 â€” Identify the Major Architectural Boundaries
--------------------------------------------------

Scan the codebase and identify its major architectural boundaries.

For each boundary, explain:
- Boundary name
- What lies on each side of the boundary
- Why the boundary exists
- What kind of change it is meant to absorb

Present the result as a table.

--------------------------------------------------
STEP 2 â€” Map Boundaries to Code Locations
--------------------------------------------------

For each identified boundary, map it to concrete code elements:
- Directories
- Source files
- Header files
- Key data structures

Explain how the boundary is expressed in C
(e.g., headers, opaque structs, naming, file layout).

--------------------------------------------------
STEP 3 â€” Contracts Enforced at Each Boundary
--------------------------------------------------

For each boundary, describe the contracts enforced across it:

- API contracts (function signatures, headers)
- Data ownership and lifetime contracts
- Control flow contracts (who calls whom)
- Error propagation contracts
- Performance contracts (hot path vs cold path)

Show small but representative C code snippets
that illustrate each contract.

--------------------------------------------------
STEP 4 â€” Dependency Rules & Direction
--------------------------------------------------

Explain the dependency rules for each boundary:

- Which side may depend on which
- Which includes are allowed or forbidden
- Whether dependency inversion is used

Provide a textual dependency diagram and explain
why reversing any dependency would be harmful.

--------------------------------------------------
STEP 5 â€” How Violations Creep In (Architecture Decay)
--------------------------------------------------

Analyze realistic ways this projectâ€™s boundaries can be violated over time:

- Convenience-driven shortcuts
- Performance-driven exceptions
- Debugging or logging leaks
- Feature creep
- Team or ownership changes

For each violation type:
- Show what the code smell looks like
- Explain why it seems harmless at first
- Explain the long-term architectural damage

--------------------------------------------------
STEP 6 â€” Existing Safeguards (or Lack Thereof)
--------------------------------------------------

Explain how the project currently prevents violations:

- Coding conventions
- File layout discipline
- Comments or documentation
- Review culture implied by the code

Also explain what is NOT protected and relies on discipline alone.

--------------------------------------------------
STEP 7 â€” Stability vs Volatility Analysis
--------------------------------------------------

Identify:
- Stable boundaries that rarely change
- Volatile boundaries that absorb frequent change

Explain how contracts protect stable parts
and where instability leaks across layers.

--------------------------------------------------
STEP 8 â€” Stress-Test the Architecture
--------------------------------------------------

Evaluate the architecture under these hypothetical changes:

1) Add a major new feature
2) Optimize performance on a hot path
3) Remove or replace a subsystem
4) Hand the project to a new team

For each case:
- Which boundaries hold
- Which contracts are stressed or broken
- Where refactoring would be required

--------------------------------------------------
STEP 9 â€” Architecture Lessons Extracted
--------------------------------------------------

Summarize reusable lessons from this project:

For each lesson:
- Boundary or contract principle
- How this project applies it (or fails to)
- How I should apply it in my own C projects

--------------------------------------------------
RULES
--------------------------------------------------

- Architecture-first analysis
- Use concrete code references
- No vague praise or generic advice
- Prefer structured output (tables, diagrams)
- Treat this as a professional architecture review

```

- Example Prompt
For each of the following prompts:


1ï¸âƒ£ Prompt â€” Ops Tables (Manual Polymorphism)
You are a Linux kernel maintainer.

Teach me how the Linux kernel (v3.2) implements object-oriented design
using ops tables (function pointer tables).

Focus on architectural intent, not syntax.

----------------------------------------
GOALS
----------------------------------------

- Understand why ops tables exist
- Understand the xxx->ops->yyy() pattern
- Understand contracts between caller and callee
- Learn how to apply this pattern in user-space C

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Explain what ops tables represent conceptually
2. Explain why the kernel avoids inheritance and virtual functions
3. Analyze at least 6 real examples:
   - VFS (file_operations)
   - net_device_ops
   - uart_ops
   - block_device_operations
   - usb_driver ops
   - tty_operations
4. For each example:
   - who owns the ops table
   - who calls it
   - what invariants are guaranteed
   - what violations look like
5. Extract a reusable user-space design pattern

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Architecture-first explanations
- Minimal code snippets
- Explicit contracts

2ï¸âƒ£ Prompt â€” Inversion of Control (IoC)
You are a Linux kernel architect.

Teach me how inversion of control is enforced in Linux kernel v3.2.

----------------------------------------
GOALS
----------------------------------------

- Understand framework-driven execution
- Understand why drivers never call each other
- Learn how IoC enables scalability

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Explain IoC in kernel terms
2. Analyze:
   - driver model (probe/remove)
   - VFS call paths
   - netdev open/transmit paths
3. Explain how control flow is inverted
4. Identify forbidden call directions
5. Show how violating IoC breaks kernel architecture
6. Translate IoC into user-space frameworks

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Call-flow diagrams (textual)
- Clear layering rules

3ï¸âƒ£ Prompt â€” Ownership & Lifetime Discipline
You are a Linux kernel memory and lifetime expert.

Teach me how strict ownership and lifetime rules are enforced
in Linux kernel v3.2.

----------------------------------------
GOALS
----------------------------------------

- Understand single-owner rule
- Understand explicit ownership transfer
- Understand how lifetime errors are prevented

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Define ownership vs reference
2. Analyze ownership in:
   - sk_buff
   - struct file
   - task_struct
3. Explain refcounting rules
4. Explain common lifetime bugs
5. Show how these rules can be used in user-space C

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Rule-based explanations
- Bug-driven examples

4ï¸âƒ£ Prompt â€” Refcount + RCU Pattern
You are an RCU and concurrency maintainer.

Teach me how refcounting and RCU work together
in Linux kernel v3.2.

----------------------------------------
GOALS
----------------------------------------

- Understand why RCU exists
- Understand reader vs writer contracts
- Learn safe object reclamation

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Explain why refcount alone is insufficient
2. Explain RCU mental model
3. Analyze at least 5 real kernel examples combining both
4. Explain what goes wrong if contracts are violated
5. Translate pattern to user-space design

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Mental models
- Timeline diagrams (text)

5ï¸âƒ£ Prompt â€” Fast Path vs Slow Path Separation
You are a Linux kernel performance engineer.

Teach me how fast paths and slow paths are separated
in Linux kernel v3.2.

----------------------------------------
GOALS
----------------------------------------

- Understand performance-driven architecture
- Learn how hot paths are protected from complexity

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Define fast path vs slow path
2. Analyze examples from:
   - networking
   - block I/O
   - scheduler
3. Explain how slow paths are isolated
4. Show how mixing paths causes regressions
5. Apply this idea to user-space systems

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Performance reasoning
- Before/after examples

6ï¸âƒ£ Prompt â€” Context-Aware Programming
You are a Linux kernel concurrency expert.

Teach me how Linux kernel v3.2 enforces context-aware programming.

----------------------------------------
GOALS
----------------------------------------

- Understand execution contexts
- Understand why sleeping is forbidden sometimes
- Learn context-safe design

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Explain kernel execution contexts
2. Analyze:
   - IRQ handlers
   - softirqs
   - process context
3. Explain allowed and forbidden operations per context
4. Show real bugs caused by context misuse
5. Translate to user-space async systems

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Rule tables
- Context comparison

7ï¸âƒ£ Prompt â€” Embedded State Machines
You are a Linux kernel protocol designer.

Teach me how state machines are implemented
in Linux kernel v3.2.

----------------------------------------
GOALS
----------------------------------------

- Understand enum + switch FSMs
- Understand ops-based state pattern
- Learn maintainable FSM design

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Analyze TCP FSM
2. Analyze at least 2 other kernel FSMs
3. Explain state transitions and invariants
4. Show why FSMs are split across files
5. Apply FSM patterns to user-space protocols

----------------------------------------
OUTPUT STYLE
----------------------------------------

- State transition explanations
- Failure analysis

8ï¸âƒ£ Prompt â€” Policy vs Mechanism Separation
You are a Linux kernel architect.

Teach me how Linux kernel v3.2 separates policy from mechanism.

----------------------------------------
GOALS
----------------------------------------

- Understand long-term maintainability
- Learn extensible architecture design

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Define policy vs mechanism
2. Analyze scheduler classes
3. Analyze VFS and block layer
4. Show how policy is swapped without touching mechanism
5. Apply this principle in user-space libraries

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Architectural diagrams (text)

9ï¸âƒ£ Prompt â€” Zero-Cost Abstractions
You are a Linux kernel performance specialist.

Teach me how Linux kernel v3.2 achieves abstraction without overhead.

----------------------------------------
GOALS
----------------------------------------

- Understand zero-cost abstractions
- Learn when macros beat functions
- Learn tradeoffs

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Analyze inline functions
2. Analyze ops tables vs virtual dispatch
3. Analyze container_of and macros
4. Show performance reasoning
5. Apply to user-space systems code

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Cost analysis
- Assembly-level reasoning (lightweight)

ğŸ”Ÿ Prompt â€” Failure-First Design
You are a Linux kernel reliability engineer.

Teach me how Linux kernel v3.2 is designed for failure-first behavior.

----------------------------------------
GOALS
----------------------------------------

- Understand explicit error handling
- Learn robust cleanup patterns

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Analyze probe error paths
2. Analyze goto-based cleanup
3. Explain why exceptions are avoided
4. Show how partial failure is handled
5. Apply failure-first design to user-space C

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Error-path walkthroughs
- Cleanup invariants

For each prompt, produce an output according to the specified style:

Present it in the following way:
1. Pure English ASCII diagram
2. Below the diagram, add Chinese explanations in plain text

Save the result as a Markdown file