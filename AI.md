[OpenAI Cookbook](https://cookbook.openai.com/)  
[Prompt Engineering Guide](https://www.promptingguide.ai/)  
[Prompt Engineering Guide](https://learnprompting.org/docs/introduction)  
[Five proven prompt engineering techniques](https://www.lennysnewsletter.com/p/five-proven-prompt-engineering-techniques)  
[]()  
[]()  
[llm-course](https://github.com/mlabonne/llm-course)  
[]()  
[**vibekanban**](https://www.vibekanban.com/)  
> Vibe Kanban lets you run coding agents in parallel without conflicts, and perform code review through our diff tool. Now you can focus on planning and quality instead of watching terminal logs.
[]()  
[]()  
[]()  
[gemini-cli](https://github.com/google-gemini/gemini-cli)  
[Gemini CLI documentation](https://geminicli.com/docs/)  
[]()  
[]()  
[cursor commands](https://github.com/hamzafer/cursor-commands)  
[cursor rules](https://cursor.com/cn/docs/context/rules)  
[slasm commands](https://cursor.com/cn/docs/cli/reference/slash-commands)  
[Speed Up Your Agents with Cursor Slash Commands](https://egghead.io/speed-up-your-agents-with-cursor-slash-commands~ze5ag)  
[awesome-cursorrules](https://github.com/PatrickJS/awesome-cursorrules/tree/main)  
[awesome-cursor-rules-mdc](https://github.com/sanjeed5/awesome-cursor-rules-mdc/tree/main)  
[agent-best-practices](https://cursor.com/cn/blog/agent-best-practices)  
[trigger.dev](https://github.com/triggerdotdev/trigger.dev)  
[How to write great Cursor Rules](https://trigger.dev/blog/cursor-rules)  
[Mastering Cursor Rules: A Developer's Guide to Smart AI Integration](https://dev.to/dpaluy/mastering-cursor-rules-a-developers-guide-to-smart-ai-integration-1k65)  
[]()  
[]()  
[]()  
[]()  


## Coding Platform
[Cursor](https://cursor.com/home)  
[Claude](https://claude.ai/)  
[Qoder](https://qoder.com/)  

### Cursor
[How I use Cursor](https://www.builder.io/blog/cursor-tips)  
[cursor.directory](https://cursor.directory/)  
[Rules](https://docs.cursor.com/en/context/rules)  
[]()  
[agent modes](https://cursor.com/cn/docs/agent/modes)  
- Agent
   å¤æ‚åŠŸèƒ½ã€é‡æ„
   è‡ªä¸»æ¢ç´¢ã€å¤šæ–‡ä»¶ç¼–è¾‘
- Ask
   å­¦ä¹ ã€è§„åˆ’ã€æé—®
   åªè¯»æ¢ç´¢ï¼Œæ— è‡ªåŠ¨ä¿®æ”¹
- Plan
   éœ€è¦è§„åˆ’çš„å¤æ‚åŠŸèƒ½
   åœ¨æ‰§è¡Œå‰åˆ›å»ºè¯¦ç»†è®¡åˆ’ï¼Œå¹¶æå‡ºæ¾„æ¸…æ€§é—®é¢˜
- Debug
   æ£˜æ‰‹ Bugã€å›å½’é—®é¢˜
   ç”Ÿæˆå‡è®¾ã€æ—¥å¿—åŸ‹ç‚¹ã€è¿è¡Œæ—¶åˆ†æ
```shortcuts
Settings
    Ctrl + Shift + j
```

## skill
[skill creator](https://github.com/moltbot/moltbot/blob/main/skills/skill-creator/SKILL.md)  
> The open agent skills tool - npx skills
[skills](https://github.com/vercel-labs/skills)  
> The Open Agent Skills Ecosystem
[skills](https://skills.sh/)  
[antigravity-awesome-skills](https://github.com/sickn33/antigravity-awesome-skills)  
[moltbot skills](https://github.com/moltbot/moltbot/tree/main/skills)  
[]()  
[]()  
[]()  
[]()  

## Prompt tips
```
è¯·ä»¥Markdownæ ¼å¼å›ç­”ä»¥ä¸‹é—®é¢˜ï¼Œå¹¶å°†æ•´ä¸ªå›å¤å†…å®¹æ”¾åœ¨ä¸€ä¸ªæ ‡è®°ä¸º markdownçš„ä»£ç å—ä¸­
Use markdown format to answer: TOPIC, make sure to put the whole response into a code block marked in markdown format.
Use markdown format to answer: TOPIC, make sure to put the whole response into a ```markdown  code block.
```
[AI Prompt Library](https://library.maastrichtuniversity.nl/apps-tools/ai-prompt-library/)  
[Claude Prompt Library](https://platform.claude.com/docs/en/resources/prompt-library/library)  
[Learning supported by AI prompts](https://library.maastrichtuniversity.nl/apps-tools/ai-prompt-library/learning-supported-by-ai-prompts/)  
[Prompt Library](https://www.moreusefulthings.com/prompts)  
[snackprompt](https://snackprompt.com/)  
[Learning Prompt](https://learningprompt.wiki/)  
[aishort](https://www.aishort.top/)  
[]()  
[]()  
[]()  


## Online
[ChatGPT](https://chatgpt.com/)  
[Grok](https://grok.com/)  
[KiMi](https://kimi.moonshot.cn/)  
[Gmini](https://gemini.google.com/app)  
[NoteBookLM](https://notebooklm.google.com/)  
[DeepSeek](https://chat.deepseek.com/)  
[hix.ai/](https://hix.ai/)  
[Ithy](https://ithy.com/)  
[å­—èŠ‚è±†åŒ…](https://www.doubao.com/chat/)  
[è…¾è®¯å…ƒå®](https://yuanbao.tencent.com/chat/)  
[é˜¿é‡Œé€šä¹‰](https://tongyi.aliyun.com/qianwen/)  


![Prompt engineering vs Context engineering](./assets/prompt_engineering_vs_context_engineering.png)  

## Context Engineering
- what is Context engineering
   the set of strategies for curating and maintaining the optimal set of tokens (information) during LLM inference, including all the other information that may land there outside of the prompts.

### Context
- What is context
   the set of tokens included when sampling from a large-language model (LLM)

### Engineering
- engineering problem
   optimizing the utility of those tokens against the inherent constraints of LLMs in order to consistently achieve a desired outcome

## Skills
[skills](https://github.com/anthropics/skills)  
[Equipping agents for the real world with Agent Skills](https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills)  
[Skills explained: How Skills compares to prompts, Projects, MCP, and subagents](https://claude.com/blog/skills-explained)  
[skill-creator](https://skillsmp.com/skills/langgenius-dify-agents-skills-skill-creator-skill-md)  
[]()  
[]()  
- What Skills were designed for
   delivering specialized context on demand without permanent overhead.

- A skill is
   a document (often markdown) containing instructions, constraints, and domain knowledge, stored in a designated directory that Claude can access through simple file-reading tools.

- Mental model
   skills are prompts and contextual resources that activate on demand, providing specialized guidance for specific task types without incurring permanent context overhead.

[Learn The Art of Prompting](https://www.learnprompt.org/)  
[A Comprehensive Guide to Using ChatGPT Prompts for Coding Tasks](https://www.learnprompt.org/chat-gpt-prompts-for-coding/)  
[Unleashing ChatGPT for Programmers](https://www.learnprompt.org/chatgpt-prompts-for-programmers/)  
[Prompts for Code Generation, Debugging, Optimization, and More](https://www.learnprompt.org/chatgpt-prompts-for-developers/)  
[My Top 17 ChatGPT Prompts for Coding](https://www.fullstackfoundations.com/blog/chatgpt-prompts-for-coding#chatgpt-prompts-for-learning-to-code)  
[DEV ChatGPT Prompts](https://github.com/PickleBoxer/dev-chatgpt-prompts)  
[awesome-chatgpt-prompts](https://github.com/f/awesome-chatgpt-prompts)  
[280+ ChatGPT Prompts & How to Write Your Own](https://writesonic.com/blog/chatgpt-prompts)  
[Check These 100 Powerful ChatGPT Prompts For Every Situation](https://growthtribe.io/blog/chatgpt-prompts/)  
[500+ Best Prompts for ChatGPT](https://www.godofprompt.ai/blog/500-best-prompts-for-chatgpt-2024?srsltid=AfmBOorDz97w7PxISB5pLqsCH1hYRaXwd7yqJdi-pBhu8a8UBRZD66mA)  
[]()  
[]()  


[LLM åº”ç”¨å¼€å‘å®è·µç¬”è®°](https://aitutor.liduos.com/)  
[é¢å‘å¼€å‘è€…çš„å¤§æ¨¡å‹æ‰‹å†Œ](https://datawhalechina.github.io/llm-cookbook/#/)  

## Prompt
![ChatGPT Prompts](./assets/ChatGPT_Prompts.pdf)  

### [ä»»åŠ¡åˆ†è§£: è¾“å…¥ + è¾“å‡º + è¿‡ç¨‹](./prompt/input_output_process.md)  
- è¾“å…¥
- è¾“å‡º
- è¿‡ç¨‹
   - æ­¥éª¤1
      é’ˆå¯¹æ­¥éª¤ä¸­å¯èƒ½é€ æˆçš„ä¸ç¡®å®šæ€§é€šè¿‡æŒ‡å®šå·¥å…·æˆ–è€…é€šè¿‡æè¿°è¿›è¡Œé™åˆ¶(ä¾‹å¦‚:å¿…é¡»ä½¿ç”¨xxxå·¥å…·è¿›è¡Œxxx),å¹¶æŒ‡å®šè¾“å‡ºå†…å®¹ä¿å­˜åˆ°æŒ‡å®šæ–‡ä»¶ï¼Œæ–¹ä¾¿åç»­æ­¥éª¤è¿›è¡Œä½¿ç”¨
   - æ­¥éª¤2
      å¯ä»¥åˆ©ç”¨ä¹‹å‰æ­¥éª¤ç”Ÿæˆçš„æ–‡ä»¶è¿›è¡Œè¿›ä¸€æ­¥åŠ å·¥å¤„ç†ï¼Œå’Œæ­¥éª¤1ç±»ä¼¼ï¼Œå¯ä»¥æŒ‡å®šç‰¹å®šå·¥å…·é˜²æ­¢ä¸ç¡®å®šæ€§(ä¾‹å¦‚ï¼šå¿…é¡»ä½¿ç”¨curlå‘½ä»¤è¿›è¡Œä¸‹è½½)ï¼Œä»¥åŠæ–‡ä»¶çš„ä¿å­˜è·¯å¾„(ä¾‹å¦‚:é€ä¸€ä¸‹è½½å›¾ç‰‡åˆ°resources/ æ–‡ä»¶å¤¹)
   - æ­¥éª¤3
      å¦‚æœç”Ÿæˆçš„ç»“æ„æ¯”è¾ƒå¤æ‚ï¼Œå¯ä»¥é€šè¿‡æŒ‡å®šæ–‡ä»¶å†…å®¹çš„é“¾æ¥è¿›è¡Œå¼•ç”¨(ä¾‹å¦‚:articleä¸­çš„å›¾ç‰‡é“¾æ¥æŒ‡å‘resources/ æ–‡ä»¶å¤¹)

- å¦‚ä½•è®© AI æ‹¥æœ‰é•¿æœŸè®°å¿†
   å¦‚æœä»»åŠ¡æœ¬èº«è¿‡äºå¤æ‚(ä¾‹å¦‚æœ‰å‡ åä¸ªæ­¥éª¤éœ€è¦å¤„ç†), ä¸Šä¸‹æ–‡é‡Œçš„å™ªéŸ³å°±è¶Šå¤šï¼Œå›ç­”å°±è¶Šå®¹æ˜“å‡ºç°å¹»è§‰ï¼Œè§£å†³æ€è·¯: è®© AI å­¦ä¼šè®°ç¬”è®°ï¼Œå³é€šè¿‡ç»™ AI è®¾è®¡ä¸€ä¸ªä¸“å±å·¥ä½œç¬”è®°ï¼Œè®© AI åœ¨æ‰§è¡Œæµç¨‹ä¸­ä¸æ–­çš„è¿›è¡Œæ›´æ–°ï¼Œä¾‹å¦‚åœ¨æç¤ºå™¨çš„æœ€é¡¶ä¸Šå¢åŠ ä¸€æ¡æ€»è§„åˆ™ï¼Œå¹¶åœ¨å…·ä½“çš„æ­¥éª¤ä¸­æ·»åŠ çº¦æŸ, è¦æ±‚ AI å¿…é¡»æ›´æ–°çŠ¶æ€

   æ­¥éª¤0: ç”Ÿæˆç¬”è®°
      - ä»¿ç…§ä¾‹å­å’Œå½“å‰ä»»åŠ¡ç”Ÿæˆç¬”è®° progress.md

   - æ­¥éª¤2
      - æŠŠå›¾ç‰‡é“¾æ¥å†™å…¥ progress.md å›¾ç‰‡ä¸‹è½½è¿›åº¦
      ...
      - æ¯ä¸‹è½½å®Œæˆä¸€ä¸ªå›¾ç‰‡, å¿…é¡»æ›´æ–°å›¾ç‰‡ä¸‹è½½è¿›åº¦

[]()  
[]()  
```
ConfD é…ç½®äº‹åŠ¡ (commit)
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Work ç»“æ„ä½“ (å·¥ä½œåˆ—è¡¨)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚  â”‚ w->list â”‚â”€â”€â–º Witem â”€â”€â–º Witem â”€â”€â–º nil â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    (å˜æ›´1)   (å˜æ›´2)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ASCII Art Diagramï¼ˆASCII è‰ºæœ¯å›¾ï¼‰æˆ– Text-based Diagramï¼ˆçº¯æ–‡æœ¬å›¾è¡¨ï¼‰

åç§°	                            è¯´æ˜
ASCII Flow Chart	                ASCII æµç¨‹å›¾ - å±•ç¤ºæµç¨‹å’Œæ­¥éª¤
ASCII Box Diagram	                ASCII æ–¹æ¡†å›¾ - ç”¨æ–¹æ¡†è¡¨ç¤ºç»„ä»¶
ASCII Data Structure Diagram	    ASCII æ•°æ®ç»“æ„å›¾ - å±•ç¤ºé“¾è¡¨ã€æ ‘ç­‰ç»“æ„
ASCII Architecture Diagram	        ASCII æ¶æ„å›¾ - å±•ç¤ºç³»ç»Ÿç»„ä»¶å…³ç³»

ASCII Art ä¸­æ–‡å¯¹é½é—®é¢˜ï¼š
æ¨èåšæ³•
    å¯¹äºæŠ€æœ¯æ–‡æ¡£ï¼Œæœ€ç®€å•çš„æ–¹æ¡ˆæ˜¯ï¼š
    1. çº¯è‹±æ–‡ ç»˜åˆ¶ ASCII å›¾
    2. å›¾ä¸‹æ–¹ ç”¨æ™®é€šæ–‡å­—æ·»åŠ ä¸­æ–‡è¯´æ˜

ç¤ºä¾‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Work Structure (worklist)              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚  â”‚ w->list â”‚â”€â”€â–º Witem â”€â”€â–º Witem â”€â”€â–º nil â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    (item1)   (item2)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è¯´æ˜ï¼šWork æ˜¯å·¥ä½œç»“æ„ä½“ï¼ŒåŒ…å«ä¸€ä¸ª Witem é“¾è¡¨ï¼Œ
æ¯ä¸ª Witem ä»£è¡¨ä¸€ä¸ªé…ç½®å˜æ›´é¡¹ã€‚
```
- æ ¸å¿ƒåŸåˆ™ (5W1H + R)
```
| åŸåˆ™                          | å«ä¹‰               | è¯´æ˜              |
| -------------------------    | ----------         | --------------- |
| **1. What â€“ ä¸»é¢˜æ˜ç¡®**        | å‘Šè¯‰æˆ‘ä½ æƒ³è¦ä»€ä¹ˆ    | æ¨¡ç³Šçš„é—®é¢˜ â†’ æ¨¡ç³Šçš„ç­”æ¡ˆ   |
| **2. Why â€“ ç›®çš„æ¸…æ™°**         | è®©æˆ‘çŸ¥é“ç”¨é€”æˆ–ç›®æ ‡  | æˆ‘èƒ½æ®æ­¤è°ƒæ•´æ·±åº¦ä¸è§’åº¦     |
| **3. Who â€“ ç›®æ ‡å—ä¼—**         | é¢å‘è°è§£é‡Š          | ä¸åŒå—ä¼—â†’ä¸åŒè¯­è¨€å’Œç»†èŠ‚    |
| **4. How â€“ é£æ ¼/å½¢å¼**        | å¸Œæœ›è¾“å‡ºä»€ä¹ˆå½¢å¼    | åˆ—è¡¨ï¼Ÿæ€»ç»“ï¼Ÿæ•™å­¦ï¼Ÿä»£ç ï¼ŸæŠ¥å‘Šï¼Ÿ |
| **5. Scope â€“ èŒƒå›´é™å®š**       | è¦å¤šæ·±ã€å¤šé•¿ã€å¤šä¸“ä¸š | æ§åˆ¶å›ç­”ç²’åº¦å’Œå¤æ‚åº¦      |
| **6. Restriction â€“ çº¦æŸæ¡ä»¶** | æŒ‡å®šè¯­æ°”ã€é£æ ¼ã€æ ¼å¼ | é¿å…å•°å—¦æˆ–è·‘é¢˜         |
```
### TIPS
Socratic Questioning: ->"Act as a Socratic tutor and help me understand the concept of [topic]. Ask me questions to guide my understanding."
è‹æ ¼æ‹‰åº•å¼æé—®ï¼š->"è¯·æ‰®æ¼”è‹æ ¼æ‹‰åº•å¼çš„å¯¼å¸ˆï¼Œé€šè¿‡æé—®å¼•å¯¼æˆ‘ç†è§£[ä¸»é¢˜]æ¦‚å¿µã€‚"

Multi-Level Explanations: ->"Explain [concept] to me as if Iâ€™m a child, then a high schooler, and finally an academic."
å¤šå±‚çº§è§£é‡Šï¼š->"è¯·ç”¨å°å­¦ç”Ÿã€ä¸­å­¦ç”Ÿå’Œå­¦è€…èƒ½ç†è§£çš„ä¸åŒè¡¨è¿°æ–¹å¼ï¼Œä¸ºæˆ‘è§£é‡Š[æ¦‚å¿µ]ã€‚"

Practice Questions: ->"Create practice questions for me on [topic] at beginner, intermediate, and advanced levels."
åˆ†çº§ç»ƒä¹ é¢˜ï¼š->"è¯·å›´ç»•[ä¸»é¢˜]è®¾è®¡åˆçº§ã€ä¸­çº§å’Œé«˜çº§ä¸‰ä¸ªéš¾åº¦çš„ç»ƒä¹ é¢˜ã€‚"

Summarizing and Comparing: ->"Summarize this paper and list the key concepts. Then compare it to my summary and identify any gaps."
æ‘˜è¦å¯¹æ¯”åˆ†æï¼š->"è¯·æ€»ç»“è¿™ç¯‡è®ºæ–‡çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶ä¸æˆ‘çš„æ€»ç»“å¯¹æ¯”ï¼ŒæŒ‡å‡ºé—æ¼ä¹‹å¤„ã€‚"

Key Terms and Categories: ->"Give me a list of 20 key terms in this paper and break them into five categories."
æœ¯è¯­åˆ†ç±»å½’çº³ï¼š->"è¯·åˆ—å‡ºæœ¬æ–‡çš„20ä¸ªå…³é”®æœ¯è¯­ï¼Œå¹¶å°†å…¶å½’çº³ä¸ºäº”ä¸ªç±»åˆ«ã€‚"

Bloomâ€™s Taxonomy Challenges: ->"Create a set of challenges for me to apply Bloomâ€™s taxonomy (remember, understand, apply, analyze, evaluate, create) to [topic]." Analogies and 
å¸ƒé²å§†åˆ†ç±»æ³•å®è·µï¼š->"è¯·æ ¹æ®å¸ƒé²å§†åˆ†ç±»æ³•ï¼ˆè®°å¿†ã€ç†è§£ã€åº”ç”¨ã€åˆ†æã€è¯„ä¼°ã€åˆ›é€ ï¼‰è®¾è®¡ä¸€å¥—å…³äº[ä¸»é¢˜]çš„å®è·µæŒ‘æˆ˜ã€‚"

Real-Life Examples: ->"Provide analogies and real-life examples to help me understand [concept]."
ç±»æ¯”è¿ç§»æ•™å­¦ï¼š->"è¯·é€šè¿‡ç±»æ¯”å’Œç”Ÿæ´»å®ä¾‹å¸®åŠ©æˆ‘ç†è§£[æ¦‚å¿µ]ã€‚"


ç¤ºä¾‹:
è¯·ç”¨è‹æ ¼æ‹‰åº•å¼æé—®ï¼Œé€šè¿‡æé—®å¼•å¯¼æˆ‘ç†è§£linuxçš„å¯åŠ¨è¿‡ç¨‹ï¼Œæé—®è¿‡ç¨‹ä¸­çš„æ¯æ¬¡å¯¹è¯è®°å½•ä¸Šä¸€æ¬¡çš„ä¸Šä¸‹æ–‡

- ç¤ºä¾‹
```
å¦‚ä½•é«˜æ•ˆçš„åˆ©ç”¨cursorå­¦ä¹ linux 3.2å†…æ ¸æºç ,ç»™å‡ºå…·ä½“çš„å­¦ä¹ å»ºè®®å’Œæ­¥éª¤ï¼Œä¾‹å¦‚å…ˆä»å“ªä¸ªç®€å•çš„æ¨¡å—å…¥æ‰‹æ¯”è¾ƒå¥½

åˆ†æarch/x86/kernel/syscall_table_32.Sä¸­çš„ç³»ç»Ÿè°ƒç”¨è¡¨ç»“æ„ï¼Œåˆ—å‡ºå‰10ä¸ªç³»ç»Ÿè°ƒç”¨çš„åç§°å’Œå¯¹åº”çš„å¤„ç†å‡½æ•°

è·Ÿè¸ªsys_getpidç³»ç»Ÿè°ƒç”¨çš„å®Œæ•´æ‰§è¡Œè·¯å¾„ï¼š
1. ç”¨æˆ·æ€è°ƒç”¨å…¥å£
2. é™·å…¥å†…æ ¸çš„æœºåˆ¶
3. å®é™…å¤„ç†å‡½æ•°
4. è¿”å›ç”¨æˆ·æ€çš„è¿‡ç¨‹

è§£é‡Štask_structç»“æ„ä½“ä¸­çš„ä¸»è¦å­—æ®µå«ä¹‰

åˆ†æè¿›ç¨‹è°ƒåº¦å™¨å¦‚ä½•é€‰æ‹©ä¸‹ä¸€ä¸ªè¿è¡Œè¿›ç¨‹

ç”»å‡ºLinux 3.2çš„å†…å­˜ç®¡ç†æ¶æ„å›¾

åˆ†æä¼™ä¼´ç³»ç»Ÿçš„å·¥ä½œåŸç†

è§£é‡ŠVFSå±‚çš„å››ä¸ªä¸»è¦å¯¹è±¡å…³ç³»

æé—®æ¨¡æ¿ï¼š"åˆ†æ[æ–‡ä»¶å]ä¸­çš„[å‡½æ•°å]å‡½æ•°ï¼š
1. å‡½æ•°çš„ä¸»è¦åŠŸèƒ½
2. è¾“å…¥å‚æ•°è¯´æ˜
3. è¿”å›å€¼å«ä¹‰
4. è°ƒç”¨å…³ç³»å›¾"

æé—®æ¨¡æ¿ï¼š"åœ¨[æ¨¡å—å]ä¸­ï¼Œä¸ºæˆ‘åˆ›å»º5ä¸ªå…³é”®æ•°æ®ç»“æ„çš„è®°å¿†å¡ç‰‡ï¼ˆå­—æ®µå+è¯´æ˜ï¼‰"

å¦‚æœæˆ‘è¦åœ¨Linux 3.2ä¸­æ·»åŠ ä¸€ä¸ªç®€å•çš„ç³»ç»Ÿè°ƒç”¨ï¼Œ
éœ€è¦ä¿®æ”¹å“ªäº›æ–‡ä»¶ï¼Ÿç»™å‡ºå…·ä½“ä»£ç ç¤ºä¾‹

# 1. ç”Ÿæˆè°ƒç”¨å›¾
"ä¸º__scheduleå‡½æ•°ç”Ÿæˆå‡½æ•°è°ƒç”¨å…³ç³»å›¾"

# 2. å¯¹æ¯”åˆ†æ
"æ¯”è¾ƒLinux 3.2ä¸æœ€æ–°å†…æ ¸åœ¨å†…å­˜ç®¡ç†æ–¹é¢çš„ä¸»è¦å·®å¼‚"

# 3. æ¼æ´åˆ†æ
"åˆ†æCVE-2012-0056æ¼æ´çš„æˆå› å’Œä¿®å¤æ–¹æ¡ˆ"

```

- ç»“æ„åŒ–æé—®æ¨¡æ¿
```
[è§’è‰²è®¾å®š] ä½ ç°åœ¨æ˜¯...
[ä»»åŠ¡ç›®æ ‡] æˆ‘å¸Œæœ›ä½ ...
[å†…å®¹èŒƒå›´] è¯·è§£é‡Š/åˆ†æ/ç”Ÿæˆå…³äº...
[è¾“å‡ºå½¢å¼] è¾“å‡ºåº”åŒ…æ‹¬...
[é£æ ¼è¦æ±‚] é£æ ¼è¦...
[é™åˆ¶æ¡ä»¶] ä¸è¦... / é¿å…...

å¥½ Prompt = è§’è‰² + ä»»åŠ¡ + ç›®æ ‡ + èŒƒå›´ + æ ¼å¼ + é£æ ¼

ä¾‹å­:
ä½ æ˜¯ä¸€åèµ„æ·±è½¯ä»¶å·¥ç¨‹å¸ˆã€‚
è¯·ç”¨æ•™å­¦é£æ ¼è§£é‡Šâ€œæ“ä½œç³»ç»Ÿå†…æ ¸çš„çº¿ç¨‹è°ƒåº¦æœºåˆ¶â€ï¼Œ
é¢å‘å¤§å­¦è®¡ç®—æœºç³»å­¦ç”Ÿã€‚
è¾“å‡ºåŒ…å«ï¼šè°ƒåº¦åŸç†ã€ç®—æ³•å¯¹æ¯”ã€ä¼˜ç¼ºç‚¹åˆ†æã€‚
ä½¿ç”¨Markdownå°æ ‡é¢˜å’Œå›¾ç¤ºç»“æ„ã€‚
å­—æ•°æ§åˆ¶åœ¨800å­—ä»¥å†…ã€‚
```

- ç¤ºä¾‹
```
æ™®é€šæé—®
    ä»€ä¹ˆæ˜¯åŒºå—é“¾ï¼Ÿ

ä¼˜åŒ–æé—®ï¼ˆç»“æ„åŒ–ç‰ˆæœ¬ï¼‰
    ä½ ç°åœ¨æ˜¯ä¸€ååŒºå—é“¾é¢†åŸŸçš„æŠ€æœ¯è®²å¸ˆã€‚
    è¯·ä»¥ç³»ç»ŸåŒ–ã€åˆ†å±‚ç»“æ„çš„æ–¹å¼è®²è§£â€œä»€ä¹ˆæ˜¯åŒºå—é“¾â€ï¼Œ
    ç›®æ ‡è¯»è€…æ˜¯æœ‰ç¼–ç¨‹åŸºç¡€çš„å·¥ç¨‹å¸ˆã€‚
    è¾“å‡ºåŒ…å«ï¼šâ‘ å®šä¹‰ â‘¡æ•°æ®ç»“æ„ â‘¢å…±è¯†æœºåˆ¶ â‘£å®‰å…¨åŸç† â‘¤åº”ç”¨åœºæ™¯ã€‚
    æ¯éƒ¨åˆ†ä½¿ç”¨å°æ ‡é¢˜å’Œç®€è¦ç¤ºä¾‹ã€‚
    é£æ ¼è¦æŠ€æœ¯å‘ã€é€»è¾‘æ¸…æ™°ã€æ— è¥é”€å£å»ã€‚
```

- ä¸åŒåœºæ™¯ä¸‹çš„ Prompt ç¤ºä¾‹
```
| ç›®æ ‡               | ä¼˜åŒ–æé—®æ¨¡æ¿                                              |
| --------------     | --------------------------------------------------- |
| ğŸ“˜ **å­¦ä¹ æ¦‚å¿µ**    | â€œè¯·åƒæˆ‘æ˜¯ä¸€åæ–°æ‰‹ç¨‹åºå‘˜ä¸€æ ·è§£é‡Š[æ¦‚å¿µ]ï¼Œç”¨ç±»æ¯”å’Œä¾‹å­è¯´æ˜åŸç†ï¼Œæœ€åæ€»ç»“3ä¸ªå…³é”®ç‚¹ã€‚â€         |
| ğŸ’» **ä»£ç è®²è§£**    | â€œè¯·é€è¡Œè§£é‡Šä¸‹é¢çš„Cä»£ç ï¼Œè¯´æ˜æ¯ä¸€è¡Œçš„ä½œç”¨å’ŒèƒŒåçš„è¯­è¨€æœºåˆ¶ã€‚â€                     |
| ğŸ§ª **è°ƒè¯•æˆ–é”™è¯¯åˆ†æ** | â€œä»¥ä¸‹æ˜¯æˆ‘åœ¨ç¼–è¯‘Cç¨‹åºæ—¶çš„é”™è¯¯ä¿¡æ¯ã€‚è¯·åˆ†æåŸå› å¹¶ç»™å‡ºè§£å†³æ­¥éª¤ã€‚å‡è®¾æˆ‘çš„ç¯å¢ƒæ˜¯Linux + gccã€‚â€ |
| ğŸ“‘ **æ€»ç»“æŠ¥å‘Š**    | â€œè¯·æŠŠä¸‹é¢å†…å®¹æ€»ç»“ä¸ºæŠ€æœ¯æŠ¥å‘Šï¼ŒåŒ…å«æ‘˜è¦ã€é—®é¢˜åˆ†æã€è§£å†³æ–¹æ¡ˆã€ç»“è®ºå››éƒ¨åˆ†ã€‚â€               |
| ğŸ’¬ **å†™ä½œæ”¹è¿›**    | â€œè¯·å¸®æˆ‘æ”¹è¿›ä¸‹é¢çš„æ®µè½ï¼Œä½¿å…¶æ›´ç®€æ´ä¸“ä¸šï¼Œä¿æŒåŸæ„ï¼Œé£æ ¼åæŠ€æœ¯æ–‡æ¡£ã€‚â€                  |

```

- è¿›é˜¶æŠ€å·§
```
è§’è‰²è®¾å®šæ³•ï¼ˆRole promptingï¼‰
    â€œä½ æ˜¯ä¸€åèµ„æ·±Cè¯­è¨€ç¼–è¯‘å™¨å·¥ç¨‹å¸ˆâ€

åˆ†æ­¥æ¨ç†æ³•ï¼ˆStep-by-step promptingï¼‰
    â€œè¯·å…ˆè§£é‡ŠåŸºæœ¬åŸç†ï¼Œå†åˆ†æå®ç°ï¼Œå†æ€»ç»“ä¼˜ç¼ºç‚¹ã€‚â€

è¿­ä»£ä¼˜åŒ–æ³•ï¼ˆRefinement promptingï¼‰
    ç¬¬ä¸€æ¬¡æé—®åï¼Œè¯´â€œè¯·ç®€åŒ–æˆè¦ç‚¹ç‰ˆâ€æˆ–â€œè¯·è¡¥å……ä»£ç å®ä¾‹â€

ç»“æ„æ§åˆ¶æ³•
æ˜ç¡®è¾“å‡ºæ ¼å¼ï¼Œä¾‹å¦‚ï¼š
ç”¨markdownæ ¼å¼è¾“å‡ºï¼ŒåŒ…å«ï¼š
1. å®šä¹‰
2. åŸç†
3. ç¤ºä¾‹
4. æ€»ç»“


é¿å…æ­§ä¹‰è¯
é¿å…â€œè®²è¯¦ç»†ä¸€ç‚¹â€â€œå¸®æˆ‘ä¼˜åŒ–â€è¿™ç§æ¨¡ç³Šè¡¨è¾¾ï¼Œ
æ”¹ä¸ºâ€œè¯·åœ¨è§£é‡Šä¸­å¢åŠ åº•å±‚åŸç†ä¸ä»£ç å®ç°ç¤ºä¾‹â€ã€‚
```

- æŠ€æœ¯å­¦ä¹ ç±»å¥½æç¤ºè¯çš„5å¤§åŸåˆ™ (LAYERæ¨¡å‹)
```
| åŸåˆ™                     | å«ä¹‰             | ç¤ºä¾‹                   |
| ----------------------   | ---------       | -------------------- |
| **L â€” Level (å±‚æ¬¡)**     | æŒ‡å®šè®²è§£æ·±åº¦     | â€œå‡è®¾æˆ‘å·²ç»æ‡‚Cè¯­è¨€ï¼Œä½†ä¸äº†è§£å†…æ ¸åŸç†â€ |
| **A â€” Audience (å—ä¼—)**  | å‘Šè¯‰æˆ‘ä½ æ˜¯è°     | â€œé¢å‘æœ‰ç¼–ç¨‹ç»éªŒçš„å·¥ç¨‹å¸ˆâ€        |
| **Y â€” Yield (äº§å‡º)**     | æ˜ç¡®è¾“å‡ºå½¢å¼     | â€œè¯·è¾“å‡ºç»“æ„åŒ–è®²è§£ï¼ŒåŒ…å«ç¤ºä¾‹å’Œå›¾è§£â€   |
| **E â€” Explain (è®²è§£æ–¹å¼)** | æ§åˆ¶è®²è§£é£æ ¼    | â€œè¯·åƒåœ¨è¯¾å ‚ä¸Šæ•™å­¦ä¸€æ ·åˆ†æ­¥éª¤è®²è§£â€    |
| **R â€” Refine (ä¼˜åŒ–)**    | ç»™å‡ºçº¦æŸä¸æ”¹è¿›è¦æ±‚ | â€œè¯­è¨€ç®€æ´ï¼Œä½¿ç”¨ç±»æ¯”ï¼Œä¸è¶…è¿‡800å­—â€  |
```

- æ¨¡æ¿
```
ä½ æ˜¯ä¸€å[æŠ€æœ¯é¢†åŸŸ]çš„èµ„æ·±å·¥ç¨‹å¸ˆå…¼è®²å¸ˆã€‚
è¯·ç³»ç»ŸåŒ–è®²è§£[æŠ€æœ¯ä¸»é¢˜]ã€‚
å‡è®¾è¯»è€…æ˜¯[ç›®æ ‡å—ä¼—]ï¼Œå·²æœ‰[ç›¸å…³çŸ¥è¯†èƒŒæ™¯]ã€‚
è®²è§£å†…å®¹åº”åŒ…å«ï¼š
1. åŸºæœ¬æ¦‚å¿µå’Œå®šä¹‰
2. å†…éƒ¨å·¥ä½œåŸç†ï¼ˆåˆ†æ­¥éª¤è¯´æ˜ï¼‰
3. å¸¸è§åº”ç”¨æˆ–ç¤ºä¾‹
4. å¯èƒ½çš„é™·é˜±æˆ–è¯¯åŒº
5. ç®€çŸ­æ€»ç»“ï¼ˆ3â€“5è¡Œï¼‰

è¾“å‡ºè¦æ±‚ï¼š
- ä½¿ç”¨ Markdown æ ¼å¼ï¼Œå¸¦æ ‡é¢˜ä¸å°èŠ‚
- è¯­è¨€æ¸…æ™°ã€ç»“æ„åˆ†æ˜
- æ—¢æœ‰ç†è®ºåˆæœ‰å®è·µè§’åº¦


ç¤ºä¾‹1ï¼šå­¦ä¹ ç½‘ç»œåè®®
ä½ æ˜¯ä¸€åè®¡ç®—æœºç½‘ç»œè®²å¸ˆã€‚
è¯·ç³»ç»Ÿè®²è§£ TCPä¸‰æ¬¡æ¡æ‰‹çš„å…¨è¿‡ç¨‹ï¼Œå‡è®¾æˆ‘å·²ç»äº†è§£IPå±‚çš„æ¦‚å¿µã€‚
è¾“å‡ºåº”åŒ…å«ï¼š
1. ä¸‰æ¬¡æ¡æ‰‹æ¯ä¸€æ­¥çš„æŠ¥æ–‡å†…å®¹å’Œç›®çš„
2. ä¸ºä»€ä¹ˆæ˜¯ä¸‰æ¬¡è€Œä¸æ˜¯ä¸¤æ¬¡æˆ–å››æ¬¡
3.æŠ¥æ–‡ä¸¢å¤±æˆ–å»¶è¿Ÿçš„å¤„ç†æœºåˆ¶
æœ€åé™„ä¸Šä¸€æ®µæ€»ç»“ã€‚
è¦æ±‚ï¼šç”¨ Markdown æ ¼å¼è¾“å‡ºã€å›¾æ–‡ç»“åˆã€æ¸…æ™°æ˜“æ‡‚ã€‚

ç¤ºä¾‹2ï¼šå­¦ä¹ ç¼–è¯‘å™¨åŸç†
ä½ æ˜¯ä¸€åç¼–è¯‘å™¨ä¸“å®¶ã€‚
è¯·ä»¥æ•™å­¦æ–¹å¼è®²è§£ Cè¯­è¨€ç¼–è¯‘è¿‡ç¨‹çš„4ä¸ªé˜¶æ®µï¼ˆé¢„å¤„ç†ã€ç¼–è¯‘ã€æ±‡ç¼–ã€é“¾æ¥ï¼‰ã€‚
å‡è®¾æˆ‘æœ‰Cè¯­è¨€åŸºç¡€ä½†ä¸äº†è§£ç¼–è¯‘å™¨å†…éƒ¨ç»“æ„ã€‚
è¯·è¯´æ˜ï¼š
    - æ¯ä¸ªé˜¶æ®µçš„è¾“å…¥ä¸è¾“å‡ºæ–‡ä»¶
    - ä¸»è¦åšäº†å“ªäº›è½¬æ¢
    - å¸¸è§çš„ç¼–è¯‘é”™è¯¯ç¤ºä¾‹
    - ç”¨gcc -E/-S/-cä¸¾ä¾‹è¯´æ˜
é£æ ¼è¦æ±‚ï¼šæ¸…æ™°ã€é€»è¾‘æ€§å¼ºã€æœ‰è¡¨æ ¼ã€‚

âœ… ç¤ºä¾‹3ï¼šå­¦ä¹ Rustç‰¹æ€§
ä½ æ˜¯ä¸€åRustè¯­è¨€è®²å¸ˆã€‚
è¯·è®²è§£ Rustçš„æ‰€æœ‰æƒä¸å€Ÿç”¨æœºåˆ¶ã€‚
å‡è®¾æˆ‘æ‡‚C++æŒ‡é’ˆï¼Œä½†åˆšå¼€å§‹å­¦Rustã€‚
è¯·ç”¨å¯¹æ¯”çš„æ–¹å¼è§£é‡Šï¼š
    1. æ‰€æœ‰æƒçš„ä¸‰æ¡æ ¸å¿ƒè§„åˆ™
    2. å€Ÿç”¨ä¸å¼•ç”¨çš„åŒºåˆ«
    3. ç”Ÿå‘½å‘¨æœŸçš„å«ä¹‰
æœ€åç»™å‡ºä¸€æ®µRustä»£ç ç¤ºä¾‹å¹¶é€è¡Œè§£é‡Šã€‚

âœ… ç¤ºä¾‹4ï¼šå­¦ä¹ ç³»ç»Ÿç¼–ç¨‹
ä½ æ˜¯ä¸€åLinuxç³»ç»Ÿå·¥ç¨‹å¸ˆã€‚
è¯·è§£é‡Š fork() ç³»ç»Ÿè°ƒç”¨çš„å·¥ä½œåŸç†ã€‚
åŒ…æ‹¬ï¼š
    - å†…æ ¸å¦‚ä½•å¤åˆ¶è¿›ç¨‹
    - çˆ¶å­è¿›ç¨‹çš„åŒºåˆ«
    - fork() è¿”å›å€¼çš„æ„ä¹‰
    - ä½¿ç”¨ç¤ºä¾‹ä»£ç ä¸è¾“å‡ºè¯´æ˜
è¯­è¨€è¦æ±‚ï¼šç®€æ´ã€å¸¦ä»£ç æ³¨é‡Šã€‚

- å¼ºåŒ–è¾“å‡ºçš„é™„åŠ æŠ€å·§
| ç›®æ ‡         | æç¤ºæŠ€å·§                   |
| -------      | ---------------------- |
| æƒ³å­¦å¾—ç³»ç»Ÿ    | â€œè¯·ä»¥è¯¾ç¨‹å½¢å¼åˆ†ç« èŠ‚è®²è§£â€          |
| æƒ³å¿«é€Ÿç†è§£    | â€œè¯·ç”¨ç±»æ¯”å’Œæ¯”å–»è§£é‡Šâ€            |
| æƒ³çœ‹åº•å±‚æœºåˆ¶  | â€œè¯·æ·±å…¥åˆ°å®ç°ç»†èŠ‚å’Œç³»ç»Ÿè°ƒç”¨å±‚é¢â€      |
| æƒ³ç»“åˆä»£ç     | â€œè¯·é™„ä¸Šç®€çŸ­C/Rustä»£ç ç¤ºä¾‹å¹¶é€è¡Œè§£é‡Šâ€ |
| æƒ³æ‰“å°æ€»ç»“ç¬”è®° | â€œè¯·è¾“å‡ºè¦ç‚¹æ€»ç»“è¡¨æ ¼ï¼Œæ–¹ä¾¿å¤ä¹ â€       |


- æŠ€æœ¯å­¦ä¹ ç±»å¥½ Prompt çš„å…¬å¼
è§’è‰² + ç›®æ ‡ä¸»é¢˜ + èƒŒæ™¯ + å†…å®¹ç»“æ„ + è¾“å‡ºæ ¼å¼ + é£æ ¼è¦æ±‚

ç¤ºä¾‹:
ä½ æ˜¯ä¸€åæ“ä½œç³»ç»Ÿè®²å¸ˆã€‚
è¯·ä»¥ç³»ç»ŸåŒ–ã€æ•™å­¦æ–¹å¼è®²è§£â€œLinux è¿›ç¨‹è°ƒåº¦æœºåˆ¶â€ã€‚
å‡è®¾æˆ‘ç†Ÿæ‚‰Cè¯­è¨€ä½†ä¸äº†è§£å†…æ ¸ã€‚
è¾“å‡ºåŒ…æ‹¬ï¼šè°ƒåº¦ç­–ç•¥ã€CFSç®—æ³•ã€æ—¶é—´ç‰‡ã€ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚
ç”¨Markdownæ ¼å¼è¾“å‡ºï¼Œå¸¦å°æ ‡é¢˜ä¸è¡¨æ ¼è¯´æ˜ã€‚

```

- ä»£ç è°ƒè¯•ç±»é«˜è´¨é‡æé—®çš„æ ¸å¿ƒåŸåˆ™ (DEBUG æ¨¡å‹)
```
| åŸåˆ™                    | å«ä¹‰         | è¦ç‚¹               |
| ---------------------   | ------      | ---------------- |
| **D â€” Describe**        | æ˜ç¡®æè¿°é—®é¢˜ | å‡ºç°ä»€ä¹ˆé”™è¯¯ï¼Ÿåœ¨ä»€ä¹ˆæƒ…å†µä¸‹ï¼Ÿ   |
| **E â€” Environment**     | æŒ‡å‡ºç¯å¢ƒ     | æ“ä½œç³»ç»Ÿã€ç¼–è¯‘å™¨ã€è¯­è¨€ç‰ˆæœ¬ç­‰   |
| **B â€” Background**      | æä¾›ä¸Šä¸‹æ–‡   | ä»£ç ç›®çš„ã€ä½ æƒ³å®ç°çš„åŠŸèƒ½     |
| **U â€” Understanding**   | è¡¨è¾¾ä½ çš„ç†è§£ | ä½ è®¤ä¸ºé—®é¢˜å¯èƒ½çš„åŸå› ï¼ˆå“ªæ€•çŒœæµ‹ï¼‰ |
| **G â€” Goal**            | æ˜ç¡®ç›®æ ‡     | æƒ³è¦ä»€ä¹ˆæ ·çš„ç»“æœæˆ–è¾“å‡º      |

- é€šç”¨æ¨¡æ¿
æˆ‘åœ¨è°ƒè¯•ä¸€æ®µ [ç¼–ç¨‹è¯­è¨€/æ¡†æ¶] ä»£ç æ—¶é‡åˆ°é—®é¢˜ã€‚

### ğŸ§© èƒŒæ™¯
- åŠŸèƒ½ç›®æ ‡ï¼šæˆ‘æƒ³å®ç° [è¯´æ˜ä»£ç åŠŸèƒ½æˆ–é€»è¾‘]
- è¿è¡Œç¯å¢ƒï¼šæ“ä½œç³»ç»Ÿ [å¦‚ Debian 12]ï¼Œç¼–è¯‘å™¨/è§£é‡Šå™¨ç‰ˆæœ¬ [å¦‚ gcc 13.2 / Python 3.11]
- ç¬¬ä¸‰æ–¹ä¾èµ–æˆ–åº“ï¼ˆå¦‚æœ‰ï¼‰

### ğŸ’» å‡ºé”™ä»£ç 
```[è¯­è¨€å]
(è¯·ç²˜è´´å‡ºé”™ä»£ç ç‰‡æ®µï¼Œè¶³ä»¥é‡ç°é—®é¢˜)

âš ï¸ é”™è¯¯ä¿¡æ¯
(å®Œæ•´ç²˜è´´é”™è¯¯æ—¥å¿—ã€ç¼–è¯‘è¾“å‡ºã€å †æ ˆä¿¡æ¯ç­‰)

ğŸ§  æˆ‘çš„ç†è§£
(å¯é€‰ï¼šä½ è®¤ä¸ºé—®é¢˜å‡ºåœ¨å“ªï¼Ÿå°è¯•è¿‡å“ªäº›ä¿®å¤åŠæ³•ï¼Ÿ)

ğŸ¯ æˆ‘çš„æœŸæœ›
è¯·å¸®æˆ‘åˆ†æï¼š
é—®é¢˜äº§ç”Ÿçš„åŸå› 
å¦‚ä½•ä¿®å¤
æ˜¯å¦æœ‰æ›´å¥½çš„å†™æ³•/æœ€ä½³å®è·µ


## ğŸ§© å…­ã€è°ƒè¯•ç±»æé—®çš„é™„åŠ æŠ€å·§

| ç›®æ ‡        | æç¤ºæŠ€å·§ |
|------       |-----------|
| æƒ³è¦è¯¦ç»†åˆ†æ | â€œè¯·é€è¡Œè§£é‡Šä»£ç è¡Œä¸ºï¼Œå¹¶è¯´æ˜å“ªä¸€è¡Œå¯èƒ½å‡ºé”™â€ |
| æƒ³å­¦è°ƒè¯•æ–¹æ³• | â€œè¯·å‘Šè¯‰æˆ‘å¦‚ä½•ç”¨ gdb / strace / lldb æ¥å®šä½è¿™ä¸ªé—®é¢˜â€ |
| æƒ³è¦é‡æ„å»ºè®® | â€œè¯·æä¾›æ›´å®‰å…¨æˆ–æ›´ç®€æ´çš„å®ç°æ–¹å¼â€ |
| æƒ³åšæ€§èƒ½ä¼˜åŒ– | â€œè¯·å¸®æˆ‘åˆ†æè¿™æ®µä»£ç å¯èƒ½çš„æ€§èƒ½ç“¶é¢ˆâ€ |
| éœ€è¦è·¨è¯­è¨€è§£é‡Š | â€œè¯·æ¯”è¾ƒè¿™æ®µCä»£ç ä¸Rustä¸­ç­‰ä»·å†™æ³•çš„å†…å­˜è¡Œä¸ºå·®å¼‚â€ |

---

## ğŸ§¾ ä¸ƒã€æ€»ç»“ï¼šè°ƒè¯•ç±»é«˜æ•ˆ Prompt é»„é‡‘å…¬å¼

> ğŸ§  **èƒŒæ™¯ + ç¯å¢ƒ + ä»£ç  + é”™è¯¯ + ç†è§£ + æœŸæœ›**

ç¤ºä¾‹ï¼š
æˆ‘åœ¨ Linux ä¸Šç”¨ gcc ç¼–è¯‘ä¸€ä¸ªåŠ¨æ€åº“æ—¶å‡ºé”™ã€‚

**èƒŒæ™¯ï¼š** æƒ³å†™ä¸€ä¸ª collectd æ’ä»¶  
**å‘½ä»¤ï¼š** `gcc -fPIC -shared -o plugin.so plugin.c -I/usr/include/collectd`  
**é”™è¯¯ï¼š** `fatal error: plugin.h: No such file or directory`  
**ç¯å¢ƒï¼š** Debian 12, gcc 13.2  
**æˆ‘çš„ç†è§£ï¼š** å¯èƒ½æ˜¯ include è·¯å¾„ä¸å¯¹ã€‚  
**è¯·å¸®æˆ‘åˆ†æï¼š** å¤´æ–‡ä»¶è·¯å¾„åœ¨å“ªé‡Œï¼Ÿæ­£ç¡®ç¼–è¯‘å‚æ•°æ˜¯ä»€ä¹ˆï¼Ÿcollectd æ’ä»¶ä¸€èˆ¬æ€ä¹ˆç¼–è¯‘ï¼Ÿ

```

- Ultimate Learning Prompt for Any Topic
```
I want to learn the topic: <TOPIC>.
Please act as my expert instructor and provide ALL of the following:

High-level overview
    What the topic is
    Why it matters
    Where it is used in real systems

Core concepts explained simply
    Define the essential terms
    Give short analogies for each concept
    Provide visual ASCII diagrams when helpful

Progressive deep dive
    Structure the learning in levels:
        Level 1: Beginner explanation
        Level 2: Intermediate technical concepts
        Level 3: Expert-level architecture & internal mechanisms
        Level 4: Real-world engineering considerations (performance, design, pitfalls)

Hands-on examples
    Provide practical examples relevant to <TOPIC>, such as:
        Code examples (C / Rust / Go / Python depending on context)
        Command-line examples
        Minimal complete working examples (MCWE)

Mini-projects / exercises
    Give me exercises at three difficulty levels:
        Easy
        Medium
        Hard
        Include expected outputs or hints.

Common mistakes & misunderstandings
Explain the top mistakes learners make
Show correct vs incorrect examples

Links between concepts
    Explain how this topic connects to:
        Operating systems
        Networking
        Memory management
        Distributed systems
        Security
        (Choose relevant ones depending on <TOPIC>)

Interview-style questions
    Provide 10 conceptual questions + 10 deep technical questions + answers.

Learning roadmap
    Tell me what to study next after this topic.
    Include recommended order and estimated time.

Optional: generate visual summaries
    Such as:
        ASCII architecture diagrams
        Flowcharts
        Tables summarizing differences or pros/cons

Before starting, ask me 3 clarifying questions to tailor the material to my background and goals.
```

- ç”¨äºç”Ÿæˆé«˜è´¨é‡ Anki å¡ç‰‡çš„ä¸“å®¶çº§æç¤ºè¯
```
I want to learn the topic: <TOPIC>.

Act as my expert instructor and generate high-quality Anki-style flashcards that are accurate, clear, and optimized for long-term technical retention.

Please create the cards with ALL of the following characteristics:

1. **Card Format**
   - Use Q: (front) and A: (back)
   - One concept per card
   - Avoid overly long answers
   - Prefer clear definitions, contrasts, examples, diagrams

2. **Card Types (mix them)**
   - Concept cards (definitions)
   - Reverse cards (Aâ†’Q)
   - Cloze deletion cards
   - Understanding tests ("why", "what if", "compare")
   - Code interpretation cards (for C/Python when appropriate)
   - ASCII diagram cards (for system / kernel / network topics)

3. **Content Requirements**
   - Start with core fundamentals of <TOPIC>
   - Add deeper internal mechanisms (since I am intermediate level)
   - Include real examples whenever possible
   - For networking/kernel topics, emphasize:
        - call paths
        - state machines
        - data structures
        - key APIs
   - Include common misconceptions and contrast them

4. **Difficulty Levels**
   - Tag each card as: [Basic], [Intermediate], or [Advanced]

5. **Number of Cards**
   - Generate 30 cards initially
   - Ensure they progressively increase in complexity

6. **Output Format**
   - Provide clean plain-text output.
   - No numbering; each card separated by a blank line.

Before generating the cards, ask me 2â€“3 clarifying questions to tailor the difficulty, language, and coding examples.

```

- prompt 1
```
walk through a real Linux NIC driver, end-to-end, at code level, but still readable.use virtio_net as the main example(considering RX/TX rings, DMA, NAPI, SKB, etc.) å¦‚æœéœ€è¦çš„ï¼Œå¯ä»¥ç”¨å¦‚ä¸‹çš„æ–¹å¼è¿›è¡Œå±•ç¤º
1.çº¯è‹±æ–‡ ç»˜åˆ¶ ASCII å›¾
2.å›¾ä¸‹æ–¹ ç”¨æ™®é€šæ–‡å­—æ·»åŠ ä¸­æ–‡è¯´æ˜
ç»“æœä¿å­˜ä¸ºMarkdownæ ¼å¼çš„æ–‡ä»¶

Explain SKB(struct sk_buff) internals with diagrams, which should be a driver-level + stack-level explanation, with ASCII diagrams, field breakdowns, and how data flows without copies, header offsets which is critical for protocol stack, SKB lifecycle for tx path and rx path, linear and no-linear SKBs, common SKB helper APIs, how SKB ties to RX/TX rings, etc.å¦‚æœéœ€è¦çš„ï¼Œå¯ä»¥ç”¨å¦‚ä¸‹çš„æ–¹å¼è¿›è¡Œå±•ç¤º
1.çº¯è‹±æ–‡ ç»˜åˆ¶ ASCII å›¾
2.å›¾ä¸‹æ–¹ ç”¨æ™®é€šæ–‡å­—æ·»åŠ ä¸­æ–‡è¯´æ˜
ç»“æœä¿å­˜ä¸ºMarkdownæ ¼å¼çš„æ–‡ä»¶

If needed, you can present it in the following way:
1. Pure English ASCII diagram
2. Below the diagram, add Chinese explanations in plain text
Save the result as a Markdown file
```

- Structured Prompt Template (General Technical Topics)
```
I want to learn the topic: <TOPIC>.

Please act as an expert systems engineer and instructor.
Explain this topic in a clear, structured, and progressive way.

Follow this exact structure:

1. High-level overview
   - What the topic is
   - Why it exists (the problem it solves)
   - Where it is used in real systems

2. Architecture overview
   - Describe the overall architecture
   - Identify major components and their responsibilities
   - Show how components interact
   - Include a clean ASCII architecture diagram (aligned, readable)

3. Key components (deep but clear)
   For each major component:
   - Purpose
   - Inputs / outputs
   - Key data structures
   - Important invariants or rules
   - Common variations or implementations

4. Core workflows (step-by-step)
   - Explain the main workflows end-to-end
   - Show control flow and data flow
   - Use ASCII sequence diagrams or flow diagrams where helpful

5. Internal mechanisms (under-the-hood)
   - Explain how it actually works internally
   - Algorithms, state machines, memory layout, or concurrency model
   - Highlight performance and correctness considerations

6. Practical examples
   - Minimal working examples (MCWE)
   - Realistic code snippets (C / C++ / Rust / Go / Python as appropriate)
   - Explain what each part of the code does
   - Show how the example maps back to the architecture

7. Common mistakes and pitfalls
   - Typical misunderstandings
   - Incorrect vs correct approaches
   - Real-world bugs and how to avoid them

8. Mental models and summaries
   - Provide 2â€“3 strong mental models
   - Summarize key takeaways in bullet points
   - Optional comparison table if alternatives exist

9. Real-world engineering considerations
   - Performance bottlenecks
   - Scalability concerns
   - Debugging and observability
   - Security or reliability implications

10. What to learn next
    - Related topics
    - Suggested learning order
    - Why each next topic matters

Constraints:
- Break explanations into small, digestible sections
- Prefer diagrams over long text when possible
- Use precise technical language but explain it clearly
- Do not skip steps or hand-wave important details

```

```
Explain <TOPIC> as if I am reading production source code.

- Explicitly connect concepts to real implementations
- Show how the abstractions map to actual code paths
- Call out invariants, ownership rules, and lifetimes
- Use ASCII diagrams for memory layout and control flow
- Prefer correctness and clarity over oversimplification

Assume I have an intermediate programming background.

```

- Structured Prompt: Learning Linux Kernel Source Code (v3.2)
```
I want to systematically learn the Linux kernel source code (version 3.2).

Please act as a senior Linux kernel maintainer and systems instructor.
Teach me by reading and explaining the actual source code, not just concepts.

Assume:
- I have intermediate C skills
- I understand OS fundamentals
- I want to learn how the kernel really works internally

Follow this exact structure:

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Subsystem context (big picture)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- What kernel subsystem are we studying?
- What problem does it solve?
- Where it sits in the overall kernel architecture
- How this subsystem interacts with others

Include a clean ASCII architecture diagram showing:
- This subsystem
- Adjacent subsystems
- Data/control flow

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2. Directory & file map (code navigation)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- List the main directories and files involved (relative to kernel root)
- Explain the responsibility of each file
- Explain why the code is split this way

Example format:
  kernel/
    sched/
      core.c   â†’ main scheduler logic
      fair.c   â†’ CFS implementation

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3. Core data structures
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
For each important struct:
- Show the struct definition (simplified if large)
- Explain each field
- Explain ownership and lifetime rules
- Explain how and where it is allocated/freed

Explain invariants that must always hold.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4. Entry points & call paths
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Identify key entry points (syscalls, interrupts, callbacks)
- Trace the main call paths step-by-step
- Show the function call chain in order

Use ASCII call graphs or sequence diagrams.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5. Core workflows (code-driven)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Explain major workflows such as:
- Initialization
- Fast path (performance-critical)
- Slow path (exceptional cases)
- Error handling paths

For each workflow:
- Start from the triggering event
- Walk through the exact functions involved
- Explain state changes and side effects

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6. Important algorithms & mechanisms
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Scheduling, locking, memory management, or protocol logic
- Why these algorithms were chosen
- Tradeoffs and limitations (especially in v3.2)

Explain with diagrams where appropriate.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7. Concurrency & synchronization
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- What concurrency model is used?
- What locks are involved?
- Where preemption, interrupts, or RCU are used
- What race conditions the code prevents

Explain what would break if synchronization is wrong.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
8. Performance considerations
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Hot paths vs cold paths
- Cacheline considerations
- Lock contention
- Scalability limits in v3.2

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
9. Common pitfalls & bugs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Typical mistakes kernel developers make here
- Subtle bugs this code avoids
- Historical issues or known limitations in v3.2

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
10. How to read this code yourself
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- What functions to read first
- What to ignore initially
- Suggested reading order
- Grep / cscope tips

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
11. Summary & mental model
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- One-paragraph summary
- Key invariants
- Mental model to keep while reading code

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
12. What to study next
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Related kernel subsystems
- Why they matter
- Recommended learning order

```

- Learn Boundaries & Contracts in C Architectures
```
You are a senior systems architect with decades of experience designing
large, long-lived C codebases (databases, OS components, network services).

Your task is to teach me how to identify, design, and enforce
BOUNDARIES and CONTRACTS in typical C architectures.

Do NOT focus on patterns by name alone.
Focus on responsibilities, dependency rules, and invariants.

--------------------------------------------------
STEP 1 â€” Define What a Boundary Is (in C)
--------------------------------------------------

Explain:
- What a boundary means in C (where the language gives no enforcement)
- Why boundaries exist
- What problems boundaries prevent over time

Explicitly distinguish between:
- Conceptual boundaries
- Code-level boundaries

--------------------------------------------------
STEP 2 â€” Identify Common Architectural Layers in C
--------------------------------------------------

List common architectural layers used in real C systems, such as:
- Application / Policy layer
- Domain / Service layer
- Core / Mechanism layer
- Infrastructure / OS layer

For each layer:
- Primary responsibility
- Allowed dependencies
- Forbidden dependencies
- Typical volatility (how often it changes)

--------------------------------------------------
STEP 3 â€” Boundary Types and Contracts
--------------------------------------------------

Identify and explain the major types of boundaries in C, including:

- API boundaries
- Data ownership boundaries
- Control flow boundaries
- Error propagation boundaries
- Configuration / policy boundaries
- Visibility / symbol boundaries

For EACH boundary type:
- What contract is enforced
- What is allowed
- What is forbidden
- What breaks when the contract is violated

--------------------------------------------------
STEP 4 â€” Contracts as C Interfaces
--------------------------------------------------

Show how contracts are expressed in C using:
- Header files
- Opaque structs
- Function signatures
- Naming conventions
- Documentation invariants

Provide small but realistic C code snippets for each technique.

--------------------------------------------------
STEP 5 â€” Allowed Interaction Patterns Between Layers
--------------------------------------------------

Describe and illustrate:
- Direct downward calls
- Dependency injection via function pointers
- Callbacks without layer inversion
- Data passed across layers safely

For each interaction:
- Why it is allowed
- What rules must be followed

--------------------------------------------------
STEP 6 â€” Forbidden Interactions (Anti-Patterns)
--------------------------------------------------

List common boundary violations in C systems, such as:
- Upward dependencies
- Leaking internal structs
- Shared global state
- Policy decisions in low layers

Show short C examples of each violation and explain why it is harmful.

--------------------------------------------------
STEP 7 â€” Contracts Over Time (Evolution)
--------------------------------------------------

Explain how boundaries and contracts help when:
- Features are added
- Performance is optimized
- Code is refactored
- Teams change

Explain what happens when contracts are vague or undocumented.

--------------------------------------------------
STEP 8 â€” Mapping Boundaries to Real Systems
--------------------------------------------------

Apply the concepts to at least one real C system
(e.g., SQLite, Redis, or a POSIX service).

Identify:
- Major boundaries
- Key contracts
- Where the system is strict vs pragmatic

--------------------------------------------------
STEP 9 â€” Boundary Review Checklist
--------------------------------------------------

Provide a practical checklist I can use during code review to evaluate:
- Whether boundaries are respected
- Whether contracts are clear
- Where architecture is at risk of decay

--------------------------------------------------
RULES
--------------------------------------------------

- Architecture-first explanations
- Use precise language
- Avoid buzzwords
- Prefer tables and diagrams where useful
- Treat this as professional-level training



- Coach Advice (Important)

Most C codebases fail not because of performance,
but because boundaries erode silently.

If you master:
    Where boundaries are
    What contracts they enforce
    How violations creep in
Youâ€™ll outgrow 90% of C developers architecturallyâ€”even very senior ones.
```

- Cursor Prompt: Learn Boundaries & Contracts in a Specific C Project
```
You are a senior systems architect reviewing a real-world C codebase.

Your task is to help me learn how boundaries and contracts are designed,
enforced, and violated over time in the following project:

PROJECT:
[project name + repo path]

Do NOT explain what the project does at a high level.
Treat it as an architectural artifact under review.

Focus on:
- Where boundaries exist
- What contracts they enforce
- How violations creep in
- How architecture decays in C systems

--------------------------------------------------
STEP 1 â€” Identify the Major Architectural Boundaries
--------------------------------------------------

Scan the codebase and identify its major architectural boundaries.

For each boundary, explain:
- Boundary name
- What lies on each side of the boundary
- Why the boundary exists
- What kind of change it is meant to absorb

Present the result as a table.

--------------------------------------------------
STEP 2 â€” Map Boundaries to Code Locations
--------------------------------------------------

For each identified boundary, map it to concrete code elements:
- Directories
- Source files
- Header files
- Key data structures

Explain how the boundary is expressed in C
(e.g., headers, opaque structs, naming, file layout).

--------------------------------------------------
STEP 3 â€” Contracts Enforced at Each Boundary
--------------------------------------------------

For each boundary, describe the contracts enforced across it:

- API contracts (function signatures, headers)
- Data ownership and lifetime contracts
- Control flow contracts (who calls whom)
- Error propagation contracts
- Performance contracts (hot path vs cold path)

Show small but representative C code snippets
that illustrate each contract.

--------------------------------------------------
STEP 4 â€” Dependency Rules & Direction
--------------------------------------------------

Explain the dependency rules for each boundary:

- Which side may depend on which
- Which includes are allowed or forbidden
- Whether dependency inversion is used

Provide a textual dependency diagram and explain
why reversing any dependency would be harmful.

--------------------------------------------------
STEP 5 â€” How Violations Creep In (Architecture Decay)
--------------------------------------------------

Analyze realistic ways this projectâ€™s boundaries can be violated over time:

- Convenience-driven shortcuts
- Performance-driven exceptions
- Debugging or logging leaks
- Feature creep
- Team or ownership changes

For each violation type:
- Show what the code smell looks like
- Explain why it seems harmless at first
- Explain the long-term architectural damage

--------------------------------------------------
STEP 6 â€” Existing Safeguards (or Lack Thereof)
--------------------------------------------------

Explain how the project currently prevents violations:

- Coding conventions
- File layout discipline
- Comments or documentation
- Review culture implied by the code

Also explain what is NOT protected and relies on discipline alone.

--------------------------------------------------
STEP 7 â€” Stability vs Volatility Analysis
--------------------------------------------------

Identify:
- Stable boundaries that rarely change
- Volatile boundaries that absorb frequent change

Explain how contracts protect stable parts
and where instability leaks across layers.

--------------------------------------------------
STEP 8 â€” Stress-Test the Architecture
--------------------------------------------------

Evaluate the architecture under these hypothetical changes:

1) Add a major new feature
2) Optimize performance on a hot path
3) Remove or replace a subsystem
4) Hand the project to a new team

For each case:
- Which boundaries hold
- Which contracts are stressed or broken
- Where refactoring would be required

--------------------------------------------------
STEP 9 â€” Architecture Lessons Extracted
--------------------------------------------------

Summarize reusable lessons from this project:

For each lesson:
- Boundary or contract principle
- How this project applies it (or fails to)
- How I should apply it in my own C projects

--------------------------------------------------
RULES
--------------------------------------------------

- Architecture-first analysis
- Use concrete code references
- No vague praise or generic advice
- Prefer structured output (tables, diagrams)
- Treat this as a professional architecture review

```

- Example Prompt
For each of the following prompts:


1ï¸âƒ£ Prompt â€” Ops Tables (Manual Polymorphism)
You are a Linux kernel maintainer.

Teach me how the Linux kernel (v3.2) implements object-oriented design
using ops tables (function pointer tables).

Focus on architectural intent, not syntax.

----------------------------------------
GOALS
----------------------------------------

- Understand why ops tables exist
- Understand the xxx->ops->yyy() pattern
- Understand contracts between caller and callee
- Learn how to apply this pattern in user-space C

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Explain what ops tables represent conceptually
2. Explain why the kernel avoids inheritance and virtual functions
3. Analyze at least 6 real examples:
   - VFS (file_operations)
   - net_device_ops
   - uart_ops
   - block_device_operations
   - usb_driver ops
   - tty_operations
4. For each example:
   - who owns the ops table
   - who calls it
   - what invariants are guaranteed
   - what violations look like
5. Extract a reusable user-space design pattern

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Architecture-first explanations
- Minimal code snippets
- Explicit contracts

2ï¸âƒ£ Prompt â€” Inversion of Control (IoC)
You are a Linux kernel architect.

Teach me how inversion of control is enforced in Linux kernel v3.2.

----------------------------------------
GOALS
----------------------------------------

- Understand framework-driven execution
- Understand why drivers never call each other
- Learn how IoC enables scalability

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Explain IoC in kernel terms
2. Analyze:
   - driver model (probe/remove)
   - VFS call paths
   - netdev open/transmit paths
3. Explain how control flow is inverted
4. Identify forbidden call directions
5. Show how violating IoC breaks kernel architecture
6. Translate IoC into user-space frameworks

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Call-flow diagrams (textual)
- Clear layering rules

3ï¸âƒ£ Prompt â€” Ownership & Lifetime Discipline
You are a Linux kernel memory and lifetime expert.

Teach me how strict ownership and lifetime rules are enforced
in Linux kernel v3.2.

----------------------------------------
GOALS
----------------------------------------

- Understand single-owner rule
- Understand explicit ownership transfer
- Understand how lifetime errors are prevented

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Define ownership vs reference
2. Analyze ownership in:
   - sk_buff
   - struct file
   - task_struct
3. Explain refcounting rules
4. Explain common lifetime bugs
5. Show how these rules can be used in user-space C

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Rule-based explanations
- Bug-driven examples

4ï¸âƒ£ Prompt â€” Refcount + RCU Pattern
You are an RCU and concurrency maintainer.

Teach me how refcounting and RCU work together
in Linux kernel v3.2.

----------------------------------------
GOALS
----------------------------------------

- Understand why RCU exists
- Understand reader vs writer contracts
- Learn safe object reclamation

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Explain why refcount alone is insufficient
2. Explain RCU mental model
3. Analyze at least 5 real kernel examples combining both
4. Explain what goes wrong if contracts are violated
5. Translate pattern to user-space design

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Mental models
- Timeline diagrams (text)

5ï¸âƒ£ Prompt â€” Fast Path vs Slow Path Separation
You are a Linux kernel performance engineer.

Teach me how fast paths and slow paths are separated
in Linux kernel v3.2.

----------------------------------------
GOALS
----------------------------------------

- Understand performance-driven architecture
- Learn how hot paths are protected from complexity

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Define fast path vs slow path
2. Analyze examples from:
   - networking
   - block I/O
   - scheduler
3. Explain how slow paths are isolated
4. Show how mixing paths causes regressions
5. Apply this idea to user-space systems

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Performance reasoning
- Before/after examples

6ï¸âƒ£ Prompt â€” Context-Aware Programming
You are a Linux kernel concurrency expert.

Teach me how Linux kernel v3.2 enforces context-aware programming.

----------------------------------------
GOALS
----------------------------------------

- Understand execution contexts
- Understand why sleeping is forbidden sometimes
- Learn context-safe design

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Explain kernel execution contexts
2. Analyze:
   - IRQ handlers
   - softirqs
   - process context
3. Explain allowed and forbidden operations per context
4. Show real bugs caused by context misuse
5. Translate to user-space async systems

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Rule tables
- Context comparison

7ï¸âƒ£ Prompt â€” Embedded State Machines
You are a Linux kernel protocol designer.

Teach me how state machines are implemented
in Linux kernel v3.2.

----------------------------------------
GOALS
----------------------------------------

- Understand enum + switch FSMs
- Understand ops-based state pattern
- Learn maintainable FSM design

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Analyze TCP FSM
2. Analyze at least 2 other kernel FSMs
3. Explain state transitions and invariants
4. Show why FSMs are split across files
5. Apply FSM patterns to user-space protocols

----------------------------------------
OUTPUT STYLE
----------------------------------------

- State transition explanations
- Failure analysis

8ï¸âƒ£ Prompt â€” Policy vs Mechanism Separation
You are a Linux kernel architect.

Teach me how Linux kernel v3.2 separates policy from mechanism.

----------------------------------------
GOALS
----------------------------------------

- Understand long-term maintainability
- Learn extensible architecture design

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Define policy vs mechanism
2. Analyze scheduler classes
3. Analyze VFS and block layer
4. Show how policy is swapped without touching mechanism
5. Apply this principle in user-space libraries

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Architectural diagrams (text)

9ï¸âƒ£ Prompt â€” Zero-Cost Abstractions
You are a Linux kernel performance specialist.

Teach me how Linux kernel v3.2 achieves abstraction without overhead.

----------------------------------------
GOALS
----------------------------------------

- Understand zero-cost abstractions
- Learn when macros beat functions
- Learn tradeoffs

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Analyze inline functions
2. Analyze ops tables vs virtual dispatch
3. Analyze container_of and macros
4. Show performance reasoning
5. Apply to user-space systems code

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Cost analysis
- Assembly-level reasoning (lightweight)

ğŸ”Ÿ Prompt â€” Failure-First Design
You are a Linux kernel reliability engineer.

Teach me how Linux kernel v3.2 is designed for failure-first behavior.

----------------------------------------
GOALS
----------------------------------------

- Understand explicit error handling
- Learn robust cleanup patterns

----------------------------------------
ANALYSIS TASKS
----------------------------------------

1. Analyze probe error paths
2. Analyze goto-based cleanup
3. Explain why exceptions are avoided
4. Show how partial failure is handled
5. Apply failure-first design to user-space C

----------------------------------------
OUTPUT STYLE
----------------------------------------

- Error-path walkthroughs
- Cleanup invariants

For each prompt, produce an output according to the specified style:

Present it in the following way:
1. Pure English ASCII diagram
2. Below the diagram, add Chinese explanations in plain text

Save the result as a Markdown file


- C++ Patterns
You are a senior C++ architect and systems engineer.

My goal is to MASTER design patterns in C++, not by memorizing names,
but by understanding:
- the engineering problems they solve
- the specific C++ language features that enable them
- how to apply them safely in real-world projects

For EACH pattern below, do ALL of the following:

----------------------------------------------------
1. Problem the Pattern Solves
- What concrete design pressure leads to this pattern?
- What goes wrong if the pattern is NOT used?
- What symptoms in real code indicate this pattern is needed?

----------------------------------------------------
2. Core Idea (C++-Specific)
- Explain the idea in precise C++ terms
- Avoid abstract OOP theory unless absolutely necessary
- Emphasize ownership, lifetime, and compile-time vs runtime tradeoffs

----------------------------------------------------
3. C++ Grammar & Language Features
Explicitly list and explain:
- C++ syntax and features used (e.g. virtual, templates, constexpr, RAII)
- STL facilities involved (containers, algorithms, smart pointers)
- Compile-time vs runtime mechanisms

----------------------------------------------------
4. Canonical C++ Implementation
- Provide a complete, minimal, compilable C++ example
- Follow modern C++ best practices (C++17+)
- Use RAII, strong typing, and clear ownership semantics
- Avoid unnecessary cleverness

----------------------------------------------------
5. Typical Usage in Real Projects
- Where this pattern commonly appears in real C++ systems
- Typical domains (systems, networking, GUI, game engines, libraries)
- Mention well-known libraries, frameworks, or standard library examples

----------------------------------------------------
6. Common Mistakes & Misuse
- How developers overuse or misuse this pattern
- Performance or maintainability pitfalls
- When the pattern makes code WORSE

----------------------------------------------------
7. When NOT to Use This Pattern
- Explicit anti-use cases
- Simpler alternatives
- Tradeoffs vs other patterns

----------------------------------------------------
8. Pattern Variations & Modern C++ Alternatives
- How modern C++ simplifies or replaces this pattern
- Template-based vs virtual-based forms
- C++20/23 improvements if applicable

----------------------------------------------------
9. Mental Model Summary
- A one-paragraph intuition for when this pattern "clicks"
- How to recognize it during code reviews

----------------------------------------------------
Patterns to cover (in this exact order):

I. Creational Patterns
1. Singleton
2. Factory Method
3. Abstract Factory
4. Builder
5. Prototype

II. Structural Patterns
6. Adapter
7. Bridge
8. Composite
9. Decorator
10. Facade
11. Flyweight
12. Proxy

III. Behavioral Patterns
13. Strategy
14. State
15. Command
16. Observer
17. Iterator
18. Visitor
19. Template Method
20. Mediator
21. Memento
22. Chain of Responsibility
23. Interpreter

IV. C++-Centric / Modern Patterns
24. RAII (as a foundational pattern)
25. Type Erasure
26. CRTP (Curiously Recurring Template Pattern)
27. Policy-Based Design
28. PIMPL Idiom
29. Value-Semantic Design
30. Non-Virtual Interface (NVI)

----------------------------------------------------
Additional constraints:

- Prefer composition over inheritance
- Favor value semantics where possible
- Explicitly discuss ownership and lifetime
- Compare runtime polymorphism vs compile-time polymorphism
- Show how STL already implements many of these ideas
- When relevant, compare with C or Linux kernel patterns

----------------------------------------------------
End with:

1. A summary table:
   Pattern â†’ Problem Solved â†’ Runtime Cost â†’ Compile-Time Cost

2. A decision guide:
   â€œIf you see X problem in code â†’ consider Y patternâ€

3. A recommended subset of patterns that:
   - Every C++ engineer MUST master
   - Patterns that should be used sparingly

Do not be verbose for its own sake.
Clarity and correctness are more important than coverage.

Present it in the following way if needed:
1. Pure English ASCII diagram
2. Below the diagram, add Chinese explanations in plain text
Save the result for each pattern as a Markdown file



## ask ChatGPT to give a structured Cursor prompt to learn a topic
```
I did not touch docker before, I want to systematically learn docker, provide me a structured Cursor prompt in detail in pure Markdown format that I can copy directly, the prompt should cover the following items: the docker architecture, why it is designed like this, how it works, how to use it for real projects,if there is any opensource repo to reference it would be good

Output Expectations
- Use precise technical language
- Prefer step-by-step reasoning
- Use ASCII diagrams where clarity improves
- Do not summarize prematurely
- Do not oversimplify
- Treat this as mentoring a future systems architect
```



## Promts
- Explanation and Learning
```
Explain [topic/concept] step by step, starting from the fundamentals and building up to advanced aspects. Use analogies where helpful, and include real-world examples.

Break down [complex topic] into its core components. For each component, provide:
- A clear definition
- Why it matters
- A simple example
- Common pitfalls or misconceptions

Teach me [skill/topic] as if I'm a complete beginner. Structure your response as a mini-lesson with sections: 1) Key concepts, 2) Practical steps, 3) Common mistakes, 4) Practice exercises.
```

- Creative Writing
```
Write a [genre] short story (approximately [word count] words) about [premise/setting]. The main character is [description], facing [central conflict]. Include vivid sensory details and end with [type of ending, e.g., twist, hopeful resolution].

Generate a [poetic form, e.g., sonnet, haiku sequence] on the theme of [theme]. Use [specific style/imagery constraints, e.g., nature metaphors, modern urban setting].

Describe [scene/object/character] in rich, immersive detail suitable for a novel. Focus on [specific senses or mood, e.g., atmosphere of tension, visual contrasts].
```

- Problem Solving and Reasoning
```
Solve the following problem: [state problem clearly]. Show your reasoning step by step, explain each decision, and verify the final answer.

You are an expert [domain] consultant. Analyze this situation: [describe situation]. Provide:
1. Key issues
2. Possible causes
3. Recommended solutions with pros/cons
4. Next steps

Think through this puzzle/question step by step before giving the answer: [state puzzle]. Use chain-of-thought reasoning and consider alternative approaches.
```

- Coding and Technical Tasks
```
Write a [language] function that [clearly describe functionality]. Include:
- Type hints/signatures
- Docstring
- Error handling
- Example usage
- Time/space complexity analysis

Review this code: [paste code]. Identify bugs, performance issues, and style problems. Suggest specific improvements and provide the refactored version.

Explain how [algorithm/data structure] works. Include:
- High-level overview
- Step-by-step pseudocode
- Real code example in [language]
- Use cases and limitations
```

- Analysis and Summarization
```
Summarize the key points of [text/article/document] in bullet points. Highlight main arguments, evidence, and conclusions. Keep it under [word count] words.

Compare and contrast [item A] and [item B] across these dimensions: [list dimensions, e.g., cost, performance, usability]. Present results in a clear table.

Analyze the strengths and weaknesses of [idea/strategy/product]. Provide balanced evidence and end with an overall recommendation.
```

- Programming Fundamentals
```
Explain the concept of [specific concept, e.g., recursion, object-oriented inheritance, memory management] in [language, e.g., Python/C++/Java]. Start with a clear definition, provide a simple real-world analogy, then show a minimal working code example, followed by a more complex example. Finally, list common errors beginners make and how to avoid them.

Teach me how to implement [data structure or pattern, e.g., linked list, binary search tree, singleton pattern] from scratch in [language]. Provide:
- Step-by-step pseudocode
- Full implementation with comments
- Time and space complexity analysis
- Test cases with expected outputs

Walk me through debugging this code: [paste code snippet]. Identify potential bugs, explain why they occur, suggest fixes, and provide the corrected version with explanations of changes.
```

- Algorithms and Data Structures
```
Explain [algorithm, e.g., Dijkstra's, merge sort, dynamic programming] in detail. Include:
- Problem it solves
- Step-by-step breakdown with a small example
- Pseudocode
- Big-O analysis
- When to use it versus alternatives

Compare [algorithm A] and [algorithm B] for solving [problem type]. Present in a table format covering time/space complexity, ease of implementation, and real-world use cases. Recommend which to use in [specific scenario].
```

- Mathematics for Computing
```
Teach me [mathematical topic, e.g., linear algebra for machine learning, probability theory, graph theory] with a focus on computer science applications. Structure the response as:
1. Core concepts and definitions
2. Key theorems/formulas with proofs or derivations
3. Computational examples (with code if applicable)
4. Practice problems with solutions

Derive and explain [specific theorem or formula, e.g., Bayes' theorem, Fourier transform]. Show the mathematical steps clearly using LaTeX, then demonstrate its application in [technical context, e.g., machine learning, signal processing].
```

- Machine Learning and Data Science
```
Explain how [ML concept, e.g., gradient descent, convolutional neural networks, overfitting] works. Provide:
- Intuitive explanation with analogy
- Mathematical formulation
- Pseudocode or simple implementation
- Tips for tuning hyperparameters

Guide me through building a [specific model, e.g., linear regression, decision tree, neural network] for [task/dataset description]. Include data preprocessing steps, model training code in [library/language], evaluation metrics, and interpretation of results.
```

- Systems and Architecture
```
Describe the architecture of [system/component, e.g., operating systems kernel, CPU cache hierarchy, distributed systems]. Break it down into layers/components, explain interactions, and include diagrams described in text (or suggest ASCII art).

Explain [systems concept, e.g., virtual memory, concurrency with threads vs. processes, TCP/IP handshake] step by step. Include real-world implications, potential pitfalls, and how modern systems handle them.
```

- General Concepts
```
Provide an overview of the Gang of Four (GoF) design patterns. Categorize them into Creational, Structural, and Behavioral patterns. For each category, list the patterns, briefly state their primary intent, and explain how design patterns in general promote software reusability, flexibility, and maintainability.

Explain the key principles behind effective use of design patterns (e.g., SOLID principles, favoring composition over inheritance). Illustrate how violating or misapplying these principles can lead to anti-patterns, with one concrete example.
```

- Creational Patterns
```
Explain the [Creational pattern, e.g., Singleton, Factory Method, Abstract Factory, Builder, Prototype] design pattern in detail. Include:
- Intent and motivation
- UML class diagram description (text-based)
- Key participants and their responsibilities
- A complete code example in [language, e.g., Java, Python, C++]
- Pros, cons, and common pitfalls

Implement the [Creational pattern, e.g., Singleton, Builder] in [language]. Provide:
- Thread-safe version where applicable
- A realistic usage scenario (e.g., configuration manager, complex object construction)
- Explanation of how it solves the problem better than alternative approaches

Compare the Factory Method and Abstract Factory patterns. Highlight:
- Structural differences
- When to prefer one over the other
- Code examples in [language] demonstrating both in the same domain (e.g., GUI component creation)
```

- Structural Patterns
```
Describe the [Structural pattern, e.g., Adapter, Decorator, Proxy, Facade, Composite] design pattern. Cover:
- Problem it solves
- Structure with text-based UML
- Implementation steps
- Full working example in [language]
- Real-world use cases and trade-offs

Compare the Adapter and Facade patterns. Provide:
- Key differences in intent and structure
- Scenarios where Adapter is more appropriate vs. Facade
- Side-by-side code examples in [language] applied to legacy system integration
```

- Behavioral Patterns
```
Explain the [Behavioral pattern, e.g., Observer, Strategy, Command, State, Template Method] design pattern thoroughly. Include:
- Motivation and applicability
- Participants and collaborations
- Sequence diagram description
- Complete implementation in [language]
- Advantages, disadvantages, and modern alternatives if any

Compare the Strategy and State patterns. Discuss:
- How they handle behavior variation
- Structural and runtime differences
- Practical example in [language] (e.g., game character behavior or payment processing) showing both approaches

Analyze when to use the Observer pattern versus event/delegate systems in modern frameworks (e.g., C# events, JavaFX properties). Provide a code comparison in [language] and discuss performance and decoupling implications.
```

- Architectural Styles
```
Provide a comprehensive overview of [architectural style, e.g., monolithic, layered, microservices, event-driven, serverless]. Include:
- Core characteristics and structure
- Text-based description of a typical diagram (e.g., UML or C4 model)
- Advantages and disadvantages
- Real-world examples of systems using this style

Compare [style A, e.g., monolithic] and [style B, e.g., microservices] architectures. Present the comparison in a table covering:
- Scalability
- Deployment complexity
- Fault isolation
- Development team organization
- Suitable use cases

Explain the MVC (Model-View-Controller), MVVM, and Clean/Hexagonal architecture patterns. For each:
- Describe the layers/components and their responsibilities
- Provide a simple code structure example in [language]
- Discuss when to choose one over the others
```

- Core Principles
```
Explain the key architectural principles (e.g., separation of concerns, modularity, scalability, resilience) and how they relate to quality attributes (e.g., performance, maintainability, security). Provide concrete examples of applying these principles in system design.

Describe how the SOLID principles apply at the architectural level rather than just the class level. Illustrate with a before-and-after example of refactoring a poorly architected system to align with SOLID.
```

- System Design and Components
```
Walk through designing a [system type, e.g., e-commerce platform, real-time chat application, high-throughput API service]. Include:
- High-level components (e.g., frontend, backend services, database, cache, message queue)
- Data flow and interaction diagrams (described in text or ASCII)
- Technology choices with justification
- Scalability and reliability considerations

Explain common architectural components such as API gateways, service meshes, caching strategies (e.g., Redis, CDN), and message brokers (e.g., Kafka, RabbitMQ). For each, describe:
- Role in the architecture
- Integration patterns
- Trade-offs in synchronous vs. asynchronous communication
```

- Evaluation and Trade-offs
```
Analyze the trade-offs when migrating from a monolithic to a microservices architecture. Cover:
- Technical challenges (e.g., distributed transactions, data consistency)
- Organizational impacts (e.g., team structure, DevOps requirements)
- Metrics for evaluating success
- Mitigation strategies for common pitfalls

Evaluate the suitability of [architectural approach, e.g., serverless, CQRS, event sourcing] for [specific scenario, e.g., startup MVP, enterprise data processing]. Provide:
- Pros and cons with evidence
- Alternative approaches
- Decision framework (e.g., cost, latency, complexity)

Discuss architectural decision records (ADRs) and how to document key trade-offs. Provide a template ADR for a hypothetical decision (e.g., choosing between relational and NoSQL databases) and explain its structure and benefits.
```

- Kernel Initialization and Core Infrastructure
```
Analyze the kernel boot process in Linux v3.2. Trace the execution flow starting from arch/x86/boot/header.S through start_kernel() in init/main.c. Highlight key initialization steps for subsystems (e.g., memory, scheduling, interrupts), and explain the role of setup_arch() and rest_init().

Examine the kernel build system in v3.2 (Kbuild and Makefiles). Walk through the top-level Makefile and explain how it processes Kconfig files, generates .config, and orchestrates compilation of built-in objects versus modules. Provide examples of key rules and variables.
```

- Process Management and Scheduling
```
Explain the process descriptor and task management in Linux v3.2. Focus on the struct task_struct in include/linux/sched.h, key fields (e.g., state, prio, policy), and how tasks are managed via the runqueue. Trace process creation from do_fork() in kernel/fork.c.

Describe the Completely Fair Scheduler (CFS) in v3.2. Analyze the core data structures (e.g., struct rq, struct cfs_rq, struct sched_entity) in kernel/sched_fair.c, explain the red-black tree usage for scheduling, and walk through the pick_next_task_fair() logic.
```

- Memory Management
```
Detail the virtual memory subsystem in Linux v3.2. Explain the role of struct mm_struct, the page table hierarchy for x86 (e.g., struct page, pgd_t), and key functions in mm/memory.c such as do_page_fault() and handle_mm_fault().

Analyze slab allocator implementation in v3.2. Trace the code in mm/slab.c (or mm/slub.c if enabled), explain cache creation (kmem_cache_create()), object allocation/free, and differences between slab, slob, and slub allocators available in this version.
```

- Virtual File System and Block I/O
```
Explain the Virtual File System (VFS) layer in Linux v3.2. Describe key structures (e.g., struct super_block, struct inode, struct dentry, struct file) in include/linux/fs.h, and trace a file read operation from sys_read() through the VFS to a specific filesystem (e.g., ext2).

Examine the block I/O layer in v3.2. Focus on the request queue and bio structures in block/* and drivers/block/*. Walk through submission of a read request via submit_bio(), elevator merging, and I/O scheduling algorithms available at that time.
```

- Device Drivers and Networking
```
Describe the interrupt handling and device driver framework in v3.2. Explain request_irq()/free_irq() in kernel/irq/, the struct irqaction, and bottom-half mechanisms (tasklets and workqueues). Provide an example flow for a simple character driver.

Analyze the network protocol stack in Linux v3.2. Trace packet reception from a device driver (e.g., netif_rx()) through the softirq (NET_RX_SOFTIRQ), skb processing in net/core/dev.c, and delivery to the IP layer in net/ipv4/ip_input.c.
```


- Deep System Understanding Prompt
```
# Role
You are a senior systems engineer and teacher.

# Objective
Help me deeply understand **[SYSTEM / PROJECT / COMPONENT]**.

# Context
- My background: [your background]
- My goal: [learning / debugging / design]

# What Problem It Solves
Explain:
- What real-world problems this system addresses
- What would break or be harder without it

# Why It Is Designed This Way
Cover:
- Key design constraints
- Trade-offs and rejected alternatives
- Historical or ecosystem reasons

# How It Works (Layered)
Explain from:
1. High-level architecture
2. Core abstractions
3. Critical data structures
4. Control flow
5. Performance considerations

# Key Invariants & Guarantees
List:
- What must always be true
- What the system assumes
- What it explicitly does NOT guarantee

# Real-World Usage
Show:
- Typical usage patterns
- Common mistakes
- When NOT to use it

# Mental Model
Provide a simple mental model or analogy.

# Summary
Condense the essence into 5 bullet points.
```

- Learning-by-Building Prompt
```
# Role
Act as a pragmatic mentor who teaches by building.

# Goal
Teach me **[TOPIC]** by incrementally building a minimal system.

# Constraints
- Avoid unnecessary abstractions
- Prefer clarity over cleverness
- Each step must compile or run

# Step-by-Step Plan
1. Define the smallest useful version
2. Add one feature at a time
3. Explain WHY before HOW

# For Each Step
Explain:
- What we are adding
- Why it is needed
- What would go wrong if we skip it

# Failure Modes
At each step:
- What bugs typically appear
- How to detect them
- How to fix them

# Final Reflection
- What concepts were actually essential
- What was optional

```

- Design Review Prompt (Architect Mindset)
```
# Role
You are a strict but fair software architect.

# Artifact to Review
- System / design / code: **[DESCRIPTION or LINK]**

# Evaluation Criteria
Review it against:
- Correctness
- Simplicity
- Extensibility
- Performance
- Debuggability

# Architecture Breakdown
Identify:
- Core responsibilities
- Dependency directions
- Ownership of state

# Design Smells
Call out:
- Over-coupling
- Leaky abstractions
- Premature optimization
- Hidden global state

# Alternatives
Propose:
- At least one simpler design
- One more scalable design

# Verdict
Answer:
- What this design gets right
- What will hurt in 6â€“12 months

```

- Debugging & Root Cause Analysis Prompt
```
# Role
Act as a senior engineer debugging a production issue.

# Problem Description
- Symptoms:
- Logs / errors:
- Expected behavior:

# Environment
- OS / runtime:
- Version info:
- Reproducibility:

# Hypotheses
List possible root causes ranked by likelihood.

# Investigation Plan
For each hypothesis:
- What evidence to look for
- How to validate or falsify it

# Root Cause
Explain:
- The exact failure mechanism
- Why it was not caught earlier

# Fix
Provide:
- Minimal fix
- Proper fix
- Preventive measures

# Lessons Learned
Generalize the takeaway.

```

- Concept-to-Implementation Prompt
```
# Role
You are both a theoretician and a practical engineer.

# Concept
Explain **[CONCEPT]**.

# Intuition First
Explain it with:
- Plain language
- Simple analogy

# Formal Definition
Provide:
- Precise terminology
- Constraints and assumptions

# Implementation Mapping
Show:
- How the concept maps to code
- Typical data structures
- Control flow patterns

# Example
Give:
- A minimal working example
- A real-world example

# Pitfalls
List:
- Common misunderstandings
- Incorrect implementations

# When to Use / Avoid
Provide clear decision rules.

```

- Comparison & Trade-off Prompt
```
# Role
Act as an unbiased technical advisor.

# Options to Compare
- Option A:
- Option B:
- (Optional) Option C:

# Comparison Axes
Compare across:
- Complexity
- Performance
- Memory
- Operational cost
- Learning curve

# Decision Table
Summarize trade-offs concisely.

# Use-Case Mapping
For each option:
- Best scenarios
- Worst scenarios

# Recommendation
Give:
- Default choice
- When to override the default

```

- Teaching with Zero Distractions Prompt
```
# Role
Act as a minimalist teacher.

# Topic
**[TOPIC]**

# Rules
- No frameworks
- No advanced optimizations
- No unrelated features

# Core Elements Only
Explain only:
- The essential components
- Their interactions

# Rejection Over Acceptance
Focus on:
- What inputs/states are invalid
- Why rejecting is critical

# One Diagram (Textual)
Describe the system in a single diagram-like explanation.

# Summary
If I remember only one thing, it should be this: **[...]**

```